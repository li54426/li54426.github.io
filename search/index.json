[{"content":" content {:toc} 5 浏览器插件 插件名称 说明 onetab 将不看的页面保存到一个标签页中 itab Holmes 使用Alt+Shif+H即可搜索书签；当然你也可以在搜索框中输入*+Tab来搜索； Markdown Here 写博文时可以使用markdown, 输入markdown -\u0026gt; 点击图标 markdown here基本渲染css 微信公众号毫秒级排版，让你的排版充满审美愉悦感。复制代码到“markdown here基本渲染css”即可 markdownload 将文章保存为md格式 mpmath Markdown Nice 微信公众号排版 tampermonkey 俗称油猴插件, 使用它你将发现新的世界 Adblock Plus 广告拦截 Cookie-Editor - Microsoft Edge Addons 设置cookie Dark Reader 将网页变成黑暗模式 globle speed 设置视频播放速度 Refined Leetcode - Microsoft Edge Addons 增强 LeetCode-cn 刷题体验 A+ 文本大小更改器 - Microsoft Edge Addons alt + 上下箭头 来更改字体大小 学习 强国 插件 自动学习强国 火狐安装组件提示 “此附加组件无法安装，因为他有可能已经损坏” 解决方法\n解决方案：\n火狐地址栏输入 “about:config”, 回车会提示可能失去质保，点击 “ 我保证会小心”； 搜索 “xpinstall.signatures.required”，双击 “true” 自动改为”false“; 将组件拖入浏览器安装，并检查是否安装成功。 6 油猴脚本 脚本名称 说明 显示力扣周赛难度分 显示题目对应 周赛难度分 的浏览器插件 微信公众号 阅读 微信公众号文章阅读模式 (greasyfork.org) 网页宽屏 (greasyfork.org) 微信 Bilibili 小程序链接转直链 (greasyfork.org) 万能验证码自动输入（升级版） (greasyfork.org) b773cd0b68a64bc88d9722310ab30a7e webAi组件\n用小组件自定义你的新标签页,支持暗黑模式，已整合 WetabAI 组件\nWetab是一款可以亲手打造属于自己的高颜值主页的小组件新标签页插件，跟Infinity New Tab新标签页一样美观大气，跟iTab iTab新标签页一样主打小组件功能。iOS苹果小组件卡片设计，内置倒计时、纪念日、天气、热搜、计算器、等超酷小组件，让信息一目了然，标签页整洁美观。 Wetab好看、好用，还好玩，让你的标签页充满无限可能： 1.自定义新标签页中的小组件和图标，支持随意拖拽布置，任意搭配。 2.自定义生日倒计时组件，发工资倒计时小组件，节假日小组件等。 3.快速添加常用网站或小组件到主页。 4.自定义搜索引擎，快捷切换百度/谷歌/必应等搜索引擎，还可以自定义添加其他搜索引擎。 5.自定义壁纸，海量高清壁纸任你选择，包括自然、海洋、建筑、动物等类别。 6.笔记和待办小组件让你的灵感不会溜掉，任务更加清晰。 7.自定义深色或浅色模式，也可以跟随系统设置。 8.自定义左侧栏，支持图标分类。办公娱乐更加得心应手，可设置左侧栏隐藏或显示。 9.自定义底部栏，收纳常用网站，一键进入更方便，可设置底部栏隐藏或显示。 10.登录/注册Wetab账号，可在不同设备备份、同步你的数据。 11.你可以接收到我们向你发送的消息通知。 12.阅读榜单小组件 13.支持图标大小调节 14.热搜榜单小组件，支持微博热搜、百度热搜、微信24小时热文榜、哔哩哔哩热门、抖音热门视频、今日头条、少数派、CSDN。 15.支持图标宽度调整 16.支持图标尺寸调整，可调大、中、小 三种模式。 17.换算器小组件。支持计算器、住房贷款计算、个人所得税计算、长度单位、重量单位、面积单位、体积单位、温度单位、速度单位、进制转换、热能、压强、功率、力转换等。 18.支持日历小组件 19.每日一言小组件 20.新闻小组件 21.习惯养成小组件 22.系统状态小组件，实时显示CPU、电池、内存的使用情况。 23.货币汇率换算小组件。 24.股票小组件 25.历史上的今天小组件 26.游戏资讯小组件 27.电影日历小组件 28.豆瓣阅读榜单小组件 29.WeTabAi组件，自由访问AI大模型 30.动态壁纸、渐变背景 31.新增AIPPT组件，AI写论文 在线版地址：https://web.wetab.link/ 问题反馈：https://support.qq.com/product/422565 官方网站：https://www.wetab.link/zh/\n","date":"2024-07-01T16:36:14Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} 1 C++ 11 之前的初始化方式 C++ 11 之前初始化的方式可以分为：直接初始化、拷贝初始化和大括号列表初始化\n直接初始化 这个最好理解，直接用显式的构造调用初始化，基本数据类型同样适用\n1 2 int j(0); MyClass myclass(123); //Foo is a class 拷贝初始化 1 2 int i = 0; MyClass myclass; //Foo is a class 大括号列表初始化 这种列表初始化方式仅限于有限的几种类型：数组和 POD 类型（plain old data 类型，指的是这样一些数据类型：基本数据类型、指针、union、数组、构造函数是 trivial 的 struct 或者 class 等与 C 相兼容的数据类型，可以按照 C 的方式来处理（运算、拷贝等））\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 列表初始化 C11 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; map = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; // 如果有些元素没有指定, 那么就会默认初始化 int arr[4] = { 1, 2, 3 }; // 默认值的初始化, 全部是 0 int a[26] ={}; int a[26]{}; struct A{ int i; struct B{ int j; int k; } b; } a = { 1, { 2, 3 } }; //POD类型 C++ 11 提供了统一的列表初始化方式 以下内容来自chatgpt\nC++列表初始化（List Initialization）是一种用于初始化对象、数组和容器的新语法。它在C++11标准中引入，并在后续的C++14、C++17和C++20中得到进一步扩展和改进。列表初始化通过使用花括号 {} 来简化初始化语法，同时提高代码的安全性和可读性。\n列表初始化的类型 列表初始化主要有以下几种类型：\n直接列表初始化：\n直接在对象创建时使用花括号进行初始化。\n1 2 int x{5}; // 直接列表初始化 double y{3.14}; 拷贝列表初始化： 使用等号和花括号进行初始化。\n1 2 int x = {5}; // 拷贝列表初始化 double y = {3.14}; 聚合初始化： 用于聚合类型（如结构体、数组等）的初始化。\n1 2 3 4 5 6 7 struct Point { int x; int y; }; Point p = {1, 2}; // 聚合初始化 int arr[] = {1, 2, 3, 4}; // 数组的聚合初始化 范围for循环： 使用范围for循环遍历列表初始化的容器。\n1 2 3 4 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; for (int n : vec) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } 标准库容器的列表初始化： 初始化标准库容器，如 std::vector、std::array 等。\n1 2 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; std::array\u0026lt;int, 4\u0026gt; arr = {1, 2, 3, 4}; 列表初始化的优势 避免窄化转换： 列表初始化不会允许从浮点到整数、较大范围整数到较小范围整数等潜在的危险转换。\n1 int x{3.14}; // 错误，不能从double到int的窄化转换 统一的初始化语法： 提供了一种统一的对象初始化语法，提高了代码的一致性和可读性。\n1 2 3 int x{5}; double d{3.14}; std::vector\u0026lt;int\u0026gt; vec{1, 2, 3, 4}; 更简洁的代码： 列表初始化语法通常比传统的构造函数调用更简洁和直观。\n1 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4}; // 比 vec.push_back(1); vec.push_back(2); 等更简洁 列表初始化的示例代码 以下是一些具体的列表初始化示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; struct Point { int x; int y; }; int main() { // 直接列表初始化 int a{10}; double b{3.14}; // 拷贝列表初始化 int c = {15}; double d = {2.71}; // 聚合初始化 Point p = {1, 2}; int arr[3] = {4, 5, 6}; // 标准库容器的列表初始化 std::vector\u0026lt;int\u0026gt; vec = {7, 8, 9, 10}; std::array\u0026lt;int, 4\u0026gt; arr2 = {11, 12, 13, 14}; // 输出测试 std::cout \u0026lt;\u0026lt; \u0026#34;a: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;c: \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;, d: \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Point p: (\u0026#34; \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;arr: \u0026#34;; for (int i : arr) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;vec: \u0026#34;; for (int i : vec) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;arr2: \u0026#34;; for (int i : arr2) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 以上代码展示了不同情况下的列表初始化使用方法及其输出结果。列表初始化不仅能使代码更清晰，还能防止许多潜在的错误，是C++11及以后标准推荐的初始化方式。\n","date":"2024-06-15T22:22:02Z","permalink":"https://li54426.github.io/p/cpp%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/","title":"CPP的初始化方式"},{"content":" content {:toc} ","date":"2024-04-09T10:21:32Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} TVBox 1简介 1.1 介绍 TVBOX开源版是一款基于GitHub社区官方代码仓生成的安卓应用。其前身就是之前很火的猫影视 TV，延续了猫影视采用的「套壳」与「视频源」分离的结构形式；这样有个好处，哪怕视频源倒闭了，壳子软件可以一直用。\n「猫影视」就采用的是这种模式，之前我也早就在储物间有提供，用过的粉丝应该都觉得好用，但影视猫还良心的给我们留了点〝遗产〞，原团队在 Github 开源了一个名为 TVBox 的项目，此 APP 功能界面与影视猫几乎保持一致： https://github.com/CatVodTVOfficial/TVBoxOSC，不过原项目这里并没有给大家提供编译好的 APP\n但这世上似乎永远不缺少英雄，o0HalfLife0o 大佬好心的提供已签名可安装的最新测试版 APK：https://github.com/o0HalfLife0o/TVBoxOSC/releases/\n安装完成后，用户导入电视源配置便可以正常使用该软件，这款应用配置源非常丰富，支持sp源、APP源、采集站源和聚合源等多种来源，几乎可以满足用户对不同类型影视资源的观影需求，无论是影视作品还是电视直播都可以在线观看。\n以 TVbox 为参照的各种 TVbox 改版，开始陆续发布上线。.例如 TVbox_pro、pluto-player、TVbox 影视仓、TVbox_taka、tvboxq 版、宝盒 (tvbox 改版)、tvbox 蜂蜜版、TVBOX 魔改版等等。这其中有的是与原版采用同样的壳源分离模式，有的则是内置了部分资源接口。\n1.2 源 下面是几个我在使用的源:\nhttp://pandown.pro/tvbox/tvbox.json\nhttps://agit.ai/Yoursmile7/TVBox/raw/branch/master/XC.json\n饭太硬 | 导航 (xn\u0026ndash;sss604efuw.top)\n1.3 收集的资源 链接:https://caiyun.139.com/m/i?105CqOWrry45X 提取码:n7Pu 复制内容打开移动云盘PC客户端，操作更方便哦\n在 Github 上其实有很多程序员在维护自用的 TVBOX 接口，而 Github 上的代码多数都是公开的，所以你懂的\n搜索方法也很简单，在 github.com 上搜索关键词：TVBOX，然后再右上角 Sort 筛选这里，选择 Recently upload 最近更新\n1.4 使用教程 本地源\n在配置界面，选择 [上传文件] 在弹出的系统文件管理界面中，按之前的保存路径找到本地包， 确认上传，点确定；本地包就会自动解压到本地根目录。 下面这里就会显示出刚刚解压出来的本地包文件夹，点开 找到接口文件，点击 [使用] 2 不同版本 2.1 黑盒版本 TVBox_takagen99_20230816 版本\n简单, 俗称黑版 没有其他内容 2.2 蜂蜜2.3.0 安装后名称为影视\n蜂蜜版也就是 FongMi 版 TVBox 电视盒子是一款最新的 TVBox 新的优化版本 FongMi 版，做了很多优化，最好用的就是自动跳过失效的线路，其他的版本会一直卡在那里，最新的 FongMi 版 tvbox 会自动选择最好最流畅的线路进行播放，非常好用。\n程序足足比原生 tvbox 大 2 倍，也就 40M 左右\n内置版本比较方便的就是无需扫码配置接口了，另外遇到什么问题打不开软件了只需要重置一下软件数据就能继续用了，这个是内置比较方便的，尤其老人使用哈。\n颖式壳子在很早之前就更新了接口补齐的功能了，也就是在接口的地方输入字母a就会自动补齐接口格式变为本地接口前缀assets://，这个时候只需要再输入一下字母a，就可以调用软件自带的多仓接口了，操作起来是非常方便的！\n​\nmlabalabala/box: TVBox 的一个可以处理多源的版本，支持安卓 4.4 (github.com)\n2.3 521魔改壳子 一款基于蜂蜜版本制作来的支持多仓，支持浏览器的壳子，界面做的很好，只是大佬更新上比较佛系，都是看到蜂蜜版本有了什么好的功能然后再去搬运一把，之前还搞了很多创意的功能，现在只是定期搬搬砖了\n2.4 yuan_影视仓 5.0.6 版本： 影视仓支持阿里网盘，只需要添加阿里 token，即可查看阿里网盘里面的 4k 影视资源。影视仓支持多仓，只需要内置多仓地址，即可切换地址源，解锁众多影视资源。也可以添加单仓地址源。影视仓更新的比较勤快。版本更新快。 支持dlnc投屏, 推荐使用 目前影视仓总共有 3 个发行版本，蓝色和红色图标为手机版本，适配手机最好，竖屏形式。\n蓝色是街机游戏版，提供了街机模拟器，小霸王，世嘉等模拟器，用来回味童年经典。 红色版本是短视频版本，内置了快手短视频。 我目前自己主要用手机端了～，这两个功能都是看剧无聊时用来打发时间的，大家按需下载即可。其他功能一致\n而橙色版本是横屏版本，主要用于 TV 端，或者平板，手机版也可用于平板，看自己需求，但是手机版不可安装到电视端，没有适配，如果你需要在电视端安装，安装橙色版本\nOK猫颖2.3.0 比较有意思的是OK大佬完全不跟着蜂蜜大佬原来的路线走哈，大佬新的版本居然又支持了clan的格式了，这个功能蜂蜜大佬可是在退网前才刚关掉的，另外首页显示分类的功能，蜂蜜大佬也是故意不放的，OK大佬则是特意搞了，还放了开关设置，真的很不错哈！\n在资源筛选这块，除了豆瓣就是360还有2345这些站的资源比较强了，筛选的内容比较细致，随手写了规则，然后从其他接口里面偷来的接口直接用到了大全的接口上，感觉还可以，热门的资源基本都可以做到秒b，唯一的缺点就是咚慢还有宗义的资源解析看运气，貌似大部分的解析在这两块内容都比较差劲哈！\n资源站 源仓库 (yckceo.com)\n饭太硬 | 导航 (xn\u0026ndash;sss604efuw.top)\n2 TV 和手机通用会员 腾讯视频 之小爱音箱提取版魔改版 哔哩哔哩 之小爱音箱提取版 / 哔哩哔哩TV版 百度网盘TV版 ( 需要会员 ) 尝试修复经典的 bilibili tv 1.6.6 版本 2021年,安卓电视上最好用的网络浏览器是什么? 目前(2022年)用到遥控器体验最好的电视浏览器:TV Bro(开源) jiopages(阿三出品)主力使用\nTV Bro跟jiopages浏览器有一拼,只有5M,速度快,开源,可过滤广告,设置收藏 火狐TV版(可用,兼容性广,官方停止更新,不再推荐) TCL雷鸟BrowseHere浏览器(内存占用稍大,遥控操作稍有卡顿 ","date":"2024-04-08T21:59:02Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} 1 概述 原作者地址\n文档地址：https://as.js.cool\n1.1 已经实现功能 云盘每日签到 公共号每日签到 公众号抽奖 每日任务 - 上传 每日任务 - 云笔记（官方下线） APP 抽奖（摇一摇） 浇水种树 - 云盘 APP 浇水种树 - 邮箱 APP 每月任务 - 邮箱 APP - 可直接完成的 热门任务 - 分享文件每月 7 次 邮箱 APP 开盲盒 每月任务 - PC 端登录 合成大芝麻每月 1 次 每月分享 20 次 每月上传 1 G AI 猜字谜 自动领取每月备份奖励（APP / 邮箱） 更多每月任务适配中，敬请不要期待 需要的 信息 代码 ： npmmirror 镜像站\ngitee asuna: 介绍剧吐ʚ♡⃛ɞ(ू・ᴗ・ू❁) (gitee.com)\n列表不需要额外的设计，直接简单粗暴，A 列是当前账号的手机号，B 列是之前复制的 authorization，C 列是之前复制的 auth_token（支持多账号，放多行）\n参数1 参数2 参数3 手机号 authorization auth_token 金山文档（WPS 云文档）使用详细教程 1 准备工作 1.1 创建账号 官网 https://www.kdocs.cn/\n如果你未曾拥有金山文档账号，请先注册一个账号，然后登录。详细步骤略。\n1.2 创建文档\n点击首页的 +新建\n然后选择 智能表格 或者 表格（这里以表格为例）\n然后创建一个空白表格\n表格介绍 字母 ABCD。。。 表示表格的列\n数字 1234。。。 表示表格的行\nA1 表示第一行第一列（左上角那个格子），那么 B2 呢？\n最底部有个 Sheet1 （中文叫做 单元格），新建的表格只有一个单元格，你可以点击后面的 + 添加（选择工具表）\n鼠标左键双击 Sheet1 这个单元格名称，然后就能输入你想要的名称了，比如 夸克网盘。\n鼠标左键单击 Sheet1 这个单元格，就是选中这个单元格（有多个单元格时有效，例如图中 Sheet2 绿色加粗的，所以我当前选择的是 Sheet2）。\n试试让自己拥有 alipan，quark 以及 推送 三个单元格吧。成功后进入下一章节。\n2 表格设计 表格设计是为了写入 网络传输所需要的cookie信息等\n1 点击刚才创建的 推送 单元格 推送配置设计如下：\n表格如图所示，每两列为一个配置单元（每个单元之间允许空列，可有可没有，例如 C 列就是空的，但是 EF 之间没有空）\n单元的第首行首列放置推送名，如 email，pushplus。base 比较特殊。（如果没有放推送名，下面写的东西就会被忽略掉）\n除第一行外，每个单元第一列为配置名称，第二列为值，中间允许空行（如 email 的第 4 行所示）\n注意：图中表格的颜色是为了方便演示添加的，无实际意义，你不必和我的一样。\n运行简单的脚本 以阿里云盘签到为例\n选择 alipan 单元格，在 A1 填上你的 token（如何获取不在本教程范围内，请自行完成）。每一行表示一个用户，故 A2 可以是你的第二个账号，A3 呢？以此类推。。。\n3 创建脚本 点击头部菜单栏的 效率 选择高级开发 选择 AirScript 脚本编辑器 点击文档共享脚本后面的 + 加号 粘贴脚本代码（示例代码：https://npmmirror.com/package/@asunajs/dist/files?version 点击后选择 alipan.wps.js） 点击输入框上面的操作栏的第六个，一个六边形图标那个（鼠标放上去显示服务授权） 点击添加服务 添加 网络API，邮箱API 点击输入框上面的操作栏的第四个，一个三角形图标那个（鼠标放上去显示运行 F5） 允许服务授权 当看到成功提示时，恭喜你，你已经成功运行了脚本。\n4 定时运行 这里就不放图了\n点击头部菜单栏的 效率 选择 高级开发 选择 定时任务 右边出来的抽屉中点击蓝色的 创建任务 选择每天，再选个具体时间（不推荐晚上接近 12 点，也不推荐凌晨） 选择你创建的脚本 然后点击确定 恭喜你，你已经成功设置了定时任务。\n5 附件 移动云盘签到模板\n哔哩哔哩签到\n","date":"2024-04-08T21:44:44Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} ","date":"2024-04-06T13:53:18Z","permalink":"https://li54426.github.io/p/","title":""},{"content":"1 邮件设置转发 进入邮箱（例如126，QQ邮箱等），点击设置选择转发选项， 然后填写转发的目的邮箱就行 2 邮件设置短信提醒 进入139邮箱APP（因为移动作为运营商，其业务范围一定包括短信，且该项业务免费） 右下角我的，打开设置 选择邮件到达通知 ","date":"2024-04-05T23:09:34Z","permalink":"https://li54426.github.io/p/%E9%82%AE%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%BD%AC%E5%8F%91/","title":"邮件设置转发"},{"content":" content {:toc} 1 自动查找答案 在我们的生活中有这样的场景，需要做一些题目，而这些题目是知道答案的（例如，校规校纪，防火检查等）\n代码的功能为: 读取问题、查询题库并生成查询结果的 Python 脚本。这个脚本可以处理文本预处理、从文本中提取题目、读取题库、进行查询并将结果保存到 Excel 文件等多个功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 import re import pandas as pd ##########-读取查询列-######### # 文本预处理 filepath = \u0026#34;./auto/question.txt\u0026#34; with open(filepath, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: text = f.read() text_new = text.replace(\u0026#39;（\u0026#39;, \u0026#39;(\u0026#39;) text_new = text_new.replace(\u0026#39;）\u0026#39;, \u0026#39;)\u0026#39;) with open(filepath, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(text_new) # 打开txt文件并读取内容 with open(\u0026#34;./auto/question.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: content = file.read() # print(\u0026#34;contect=\u0026#34;, content) # 把题目导出来 pattern = r\u0026#39;(\\d+\\.+)(.+?)(?=(\\(|\\。|\\n|$))\u0026#39; matches = re.findall(pattern, content, flags=re.DOTALL) # [(\u0026#39;1. \u0026#39;, \u0026#39;质量流量计不能够直接测出的参数是（ ）\u0026#39;),.....] # print(\u0026#34;maches=\u0026#34;, matches) matches = [(ma[0], ma[1] ) for ma in matches] print(\u0026#34;maches=\u0026#34;, matches) # 将数据转换成 DataFrame 格式 # 将数据转换成 DataFrame 格式, 并修改列名为 \u0026#34;序号\u0026#34; 和 \u0026#34;答案\u0026#34; df = pd.DataFrame(matches, columns=[\u0026#39;序号\u0026#39;, \u0026#39;问题\u0026#39;]) # 使用 slice() 方法将 content 列的字符串长度截断为 20 df[\u0026#39;问题\u0026#39;] = df[\u0026#39;问题\u0026#39;]#.str.slice(20) # print(\u0026#34;df=\u0026#34;, df) # 将数据保存到 Excel 文件中 df.to_excel(\u0026#39;./auto/问题列表.xlsx\u0026#39;, index=False) ######### 读取题库 ############## dic = [] # 读取单选题 df= pd.read_excel(\u0026#34;./auto/diction.xlsx\u0026#34;, sheet_name=\u0026#34;one\u0026#34;, usecols=[0,1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values #print(df) dic1= [(question, ans) for question, ans in value_array] dic.extend(dic1) # 读取多选题 df= pd.read_excel(\u0026#34;./auto/diction.xlsx\u0026#34;, sheet_name=\u0026#34;two\u0026#34;, usecols=[0,1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values dic1= [(question, ans) for question, ans in value_array] dic.extend(dic1) # 读取判断题 df= pd.read_excel(\u0026#34;./auto/diction.xlsx\u0026#34;, sheet_name=\u0026#34;bool\u0026#34;, usecols=[0,1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values dic1= [(question, ans) for question, ans in value_array] dic.extend(dic1) # dic = [(\u0026#39;修改后的《安全生产法》由习近平主席于2014年签署第十三号令予以公布，自2014年（）起施行。\u0026#39;, \u0026#39;C\u0026#39;),(),,,,] # print(\u0026#34;\\n\\n\\ndic=\u0026#34;, dic) ########### 进行查询 ############### res= [] num = 0 for match in matches: # 查询id, 查询题目 id = match[0] qu = match[1] # 题目过短, 自己进行处理 if(len(qu)\u0026lt;=5): res.append((id, \u0026#34;没有答案\u0026#34;)) continue flag = 0 # 开始从题库中查询 for allqu, ans in dic: if qu in allqu: res.append((id, ans)) flag =1 num+=1 break if(flag ==0): res.append((id, \u0026#34;没有答案\u0026#34;)) # print(\u0026#34;res=\u0026#34;, res) print(\u0026#34;共查询到\u0026#34;, num , \u0026#34;/\u0026#34;, len(res),\u0026#34;个结果\u0026#34;) # 输出为 execl, 一共两列 data = { \u0026#39;题号\u0026#39;: [item[0] for item in res], \u0026#39;答案\u0026#39;: [item[1] for item in res] } df=pd.DataFrame(data) df.to_excel(\u0026#34;./auto/查询结果.xlsx\u0026#34;,sheet_name=\u0026#34;Sheet1\u0026#34;, header=None, index=False) ############ 如果没有搜索到答案 ########### print(\u0026#34;下面请输入没有搜索到答案的问题\u0026#34;) for i in range(100): s = input(\u0026#34;请输入问题：(右键即黏贴)\\n\u0026#34;) for ques, ans in dic: if s in ques: print(ans,\u0026#34;\\n\\n\\n\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 import re import pandas as pd # 文本预处理 filepath = \u0026#34;./auto/question.txt\u0026#34; with open(filepath, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: text = f.read() text_new = text.replace(\u0026#39;（\u0026#39;, \u0026#39;(\u0026#39;) text_new = text_new.replace(\u0026#39;）\u0026#39;, \u0026#39;)\u0026#39;) with open(filepath, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(text_new) # 打开txt文件并读取内容 with open(\u0026#34;./auto/question.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: content = file.read() # 把题目导出来 pattern = r\u0026#39;(\\d+\\.+)(.+?)(?=(\\(|\\。|\\n|$))\u0026#39; matches = re.findall(pattern, content, flags=re.DOTALL) matches = [(ma[0], ma[1]) for ma in matches] print(\u0026#34;matches=\u0026#34;, matches) # 将数据转换成 DataFrame 格式 df = pd.DataFrame(matches, columns=[\u0026#39;序号\u0026#39;, \u0026#39;问题\u0026#39;]) # 使用 slice() 方法将 content 列的字符串长度截断为 20 df[\u0026#39;问题\u0026#39;] = df[\u0026#39;问题\u0026#39;] # .str.slice(20) # 将数据保存到 Excel 文件中 df.to_excel(\u0026#39;./auto/问题列表.xlsx\u0026#39;, index=False) # 读取题库 dic = [] excel_file = pd.ExcelFile(\u0026#34;./auto/diction.xlsx\u0026#34;) # 读取所有表格的数据 for sheet_name in excel_file.sheet_names: df = pd.read_excel(excel_file, sheet_name=sheet_name, usecols=[0, 1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values dic1 = [(question, ans) for question, ans in value_array] dic.extend(dic1) # 进行查询 res = [] num = 0 for match in matches: # 查询id, 查询题目 id = match[0] qu = match[1] # 题目过短, 自己进行处理 if len(qu) \u0026lt;= 5: res.append((id, \u0026#34;没有答案\u0026#34;)) continue flag = 0 # 开始从题库中查询 for allqu, ans in dic: if qu in allqu: res.append((id, ans)) flag = 1 num += 1 break if flag == 0: res.append((id, \u0026#34;没有答案\u0026#34;)) print(\u0026#34;共查询到\u0026#34;, num, \u0026#34;/\u0026#34;, len(res), \u0026#34;个结果\u0026#34;) # 输出为 execl, 一共两列 data = { \u0026#39;题号\u0026#39;: [item[0] for item in res], \u0026#39;答案\u0026#39;: [item[1] for item in res] } df = pd.DataFrame(data) df.to_excel(\u0026#34;./auto/查询结果.xlsx\u0026#34;, sheet_name=\u0026#34;Sheet1\u0026#34;, header=None, index=False) # 如果没有搜索到答案 print(\u0026#34;下面请输入没有搜索到答案的问题\u0026#34;) for i in range(100): s = input(\u0026#34;请输入问题：(右键即黏贴)\\n\u0026#34;) for ques, ans in dic: if s in ques: print(ans, \u0026#34;\\n\\n\\n\u0026#34;) 2 子文件夹内容移出并重命名为子文件夹名称 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @echo off setlocal enabledelayedexpansion rem 遍历当前文件夹下的每个子文件夹 for /d %%F in (*) do ( set \u0026#34;folder_name=%%~nxF\u0026#34; rem 将子文件夹下的文件重命名为文件夹名字 for %%G in (\u0026#34;%%~F\\*\u0026#34;) do ( move \u0026#34;%%~G\u0026#34; \u0026#34;%%~dpF\\!folder_name!_%%~nxG\u0026#34; ) rem 将子文件夹下的所有文件移动到当前文件夹下 move \u0026#34;%%~F\\*\u0026#34; . rem 删除空的子文件夹 rd \u0026#34;%%~F\u0026#34; ) 3 生成目录树 tree 命令用于在命令行界面显示目录结构树，它会递归地列出指定目录及其子目录中的所有文件和文件夹，并以树状结构进行展示。这个命令通常在命令行界面中使用，对于需要快速了解目录结构的情况非常有用。\n使用 tree 命令，你可以快速了解指定目录中的文件和文件夹的组织结构，包括子目录、文件名、文件大小等信息，从而更方便地进行文件管理和导航。\n常见用法示例：\ntree: 显示当前目录下的目录结构树。 tree /F: 显示目录结构树时，包括文件名。 tree /A: 显示所有文件和文件夹，包括隐藏文件和系统文件。 tree /L n: 限制目录层级，只显示前 n 层的目录结构。 tree /A /F \u0026gt; tree.txt: 将目录结构树输出到文本文件 tree.txt 中。 总的来说，tree 命令是一个方便的工具，用于在命令行界面快速查看和分析目录结构。\n1 tree \u0026gt;tree.txt D:. │ shilei_mymuduo.zip │ tree.txt │ __.DS_Store │ 推荐课程学习路径.pdf │ 目录树.bat │ 重写muduo库.pdf │\n└─视频 01项目介绍_ev.mp4 02.1_IO的阻塞和非阻塞_ev.mp4 02.2_IO的阻塞和非阻塞_勘误_ev.mp4 03 IO的同步和异步_IO的同步和异步_ev.mp4 04 阻塞\u0026amp;非阻塞\u0026amp;同步\u0026amp;异步总结_阻塞\u0026amp;非阻塞\u0026amp;同步\u0026amp;异步总结_ev.mp4 05 Linux的五种IO模型简介_Linux的五种IO模型简介_ev.mp4 06 Linux的五种IO模型详解_Linux的五种IO模型详解_ev.mp4 07 良好的网络服务器该怎么设计_良好的网络服务器该怎么设计_ev.mp4 08 Reactor模型详解_Reactor模型详解_ev.mp4\n1 DIR /S \u0026gt; dirs.txt D:\\正在看的视频\\cpp_手写C++ Muduo网络库项目-掌握高性能网络库实现原理 的目录\n2023/07/17 16:44 . 2023/07/17 16:44 .. 2023/07/17 16:44 0 dirs.txt 2023/07/15 15:10 4,224 shilei_mymuduo.zip 2023/07/17 16:39 3,464 tree.txt 2023/07/15 15:10 4,096 __.DS_Store 2023/07/15 15:10 97,797 推荐课程学习路径.pdf 2023/07/17 16:44 17 目录树.bat\n2023/07/15 16:20 466 子文件夹内容移出并重命名为子文件夹名称.bat 55 个文件 3,519,689,412 字节\n所列文件总数: 62 个文件 3,520,852,047 字节 5 个目录 53,564,571,648 可用字节\n自动提交脚本 只是一个博客, 提交的信息就不重要了, 只提交一个 时间信息就好 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @echo off setlocal enabledelayedexpansion REM 获取当前日期和时间 for /f \u0026#34;tokens=1-4 delims=/ \u0026#34; %%i in (\u0026#34;%date%\u0026#34;) do ( set year=%%l set month=%%j set day=%%k ) for /f \u0026#34;tokens=1-3 delims=:.\u0026#34; %%i in (\u0026#34;%time%\u0026#34;) do ( set hour=%%i set minute=%%j set second=%%k ) REM 构建提交信息 set commit_message=%year%-%month%-%day% %hour%:%minute%:%second% REM 添加文件到暂存区 git add . REM 提交代码，并包含日期和时间作为提交信息 git commit -m \u0026#34;%commit_message%\u0026#34; REM 推送到远程仓库 git push endlocal 自动生成 markdown 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash filename=$(date +\u0026#34;%Y-%m-%d-.md\u0026#34;) cat \u0026gt; \u0026#34;$filename\u0026#34; \u0026lt;\u0026lt; EOF --- layout: blog banana: true category: default title: date: $(date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) background: green tags: - default - memcache --- * content {:toc} EOF echo \u0026#34;文件已生成：$filename\u0026#34; 请帮我生成批处理代码，实现以下功能，将当前目录下的子文件夹中的 png 文件 复制到，当前目录的上一级的 assets 文件夹下子文件夹blog 文件夹下\n请帮我生成批处理代码，实现以下功能，将当前目录下的子文件夹中的 md 文件中的 “assets/” 修改为 “/assets/blog/”\n","date":"2024-04-05T17:05:44Z","permalink":"https://li54426.github.io/p/%E7%AD%94%E6%A1%88%E6%9F%A5%E6%89%BE/","title":"答案查找"},{"content":" content {:toc} 什么是node . js Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时，用于构建快速、可扩展的网络应用。它允许开发者使用 JavaScript 来编写服务器端的代码，而不仅仅局限于浏览器端的脚本。Node.js 的特点包括：\n事件驱动: Node.js 使用基于事件驱动的非阻塞 I/O 模型，这意味着它可以处理大量并发连接而不需要为每个连接创建新的线程，从而提高了性能和扩展性。 跨平台: Node.js 可以在多种操作系统上运行，包括 Windows、macOS 和各种 Linux 发行版。 轻量和高效: Node.js 采用了 Chrome V8 引擎，具有快速的代码执行速度，同时也是相对较轻量的运行时环境。 丰富的模块库: Node.js 提供了大量的内置模块和第三方模块，使得开发者可以方便地构建各种类型的应用程序，包括 Web 服务器、RESTful API、实时通讯应用等。 总之，Node.js 提供了一种高效、灵活的方式来构建服务器端的应用程序，使得开发者可以利用 JavaScript 的优势来开发各种类型的后端应用。\n","date":"2024-03-05T14:48:37Z","permalink":"https://li54426.github.io/p/%E5%9B%BE%E5%BA%8A/","title":"图床"},{"content":" content {:toc} 图片测试 这是上传到gitee云的 png 文件\n这是上传到gitee云的 webp 文件\n如何批量下载小红书的图片 首先下载油猴插件 其次安装该脚本Picviewer CE+ (greasyfork.org) 使用脚本下载图片 脚本使用 打开连接 按住g 右上角命令-下载当前所有 快捷键\n打开图库（加功能键为全局）9 打开大图a 打开当前图片C 打开放大镜观察m 下载d ","date":"2023-11-30T14:58:22Z","permalink":"https://li54426.github.io/p/%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%9A%84%E5%9B%BE%E7%89%87/","title":"如何批量下载小红书的图片"},{"content":" content {:toc} 1 基础 1.1 不知道具体行数,直到文件末尾( EOF ) 输入样例:\n1 2 3 1 2 3 4 5 6 输入代码\n1 2 3 4 5 6 7 8 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; } } 1.2 有具体行数 输入样例:\n输入 n+1 行 第一行为n 接下来 n 行代表\u0026hellip;. 1 2 5 1 2 3 4 5 代码\n1 2 3 4 5 6 7 8 9 10 11 12 // 输入 n+1 行 // 第一行为xxx // 第二行为 xxx #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt; n; for(int i = 0; i\u0026lt; n; ++i){ // ... } } 2 string 2.1 多组数据, 空格分隔每个字符串 输入样例\n1 2 aaa bbb ccc aaa bbb ccc 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1, s2; while (cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2) { //... } return 0; } 2.2 输入一行为一个字符串 operator \u0026gt;\u0026gt; 有个问题, 遇到空格就停止 1 my name is li54426 1 2 3 4 5 6 7 8 9 #include\u0026lt;sstream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;iostream\u0026gt; int main{ string line; // 获取一整行数组 getline(cin, line); } 2.3 多组数据, 一行为一个字符串 数据格式为\n1 2 asd ddd ddd adsfa ddsf dfasd 1 2 3 4 5 6 7 int main(){ string line; while(getline(cin, line)) { //依靠geline读入一行 cout\u0026lt;\u0026lt; s\u0026lt;\u0026lt; endl; } } 2.4 输入一行字符串, 从中查找数字 输入格式\n1 \u0026#34;type:directReductionCoupon,price:50,isStackable:false\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 // \u0026#34;type:directReductionCoupon,price:50,isStackable:false\u0026#34; // 需要分离出来数字等 int main(){ string s; cin\u0026gt;\u0026gt; s; int base = ss.find(\u0026#34;price\u0026#34;); int end = ss.find(\u0026#34;,\u0026#34;, base); string numstr = ss.substr(base+6 , end- base-6); double price = stod(numstr ); } 3 进阶\u0026mdash;stringstream 的使用 3.1 输入方式为每行一个数组 输入样例\n1 2 3 1 2 3 4 5 0 0 0 0 0 代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;sstream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;iostream\u0026gt; int main{ vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; tree; string line; while(getline(cin, line)) { //依靠geline读入一行 stringstream ss(line); //每行先读入字符串，然后再区分每个数字 int num; int sum=0; vector\u0026lt;int\u0026gt; nums; nums.clear(); while(ss \u0026gt;\u0026gt; num){ nums.push_back(nums); } tree.push_back(nums); } } 3.2 输入方式为每行一个数组, 数字之间用逗号分隔 输入样例\n1 2 1,2,3 4,5,6 代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 1,2,3 // sum = 6 #include\u0026lt;sstream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;iostream\u0026gt; int main(){ string line; while(getline(cin, line) ) { //依靠geline读入一行 stringstream ss(line); //每行先读入字符串，然后再区分每个数字 int num; int sum=0; while(ss\u0026gt;\u0026gt; num){ // 将逗号输出出去 ss.get(); sum += num; } //计算总和 cout\u0026lt;\u0026lt; \u0026#34;sum = \u0026#34;\u0026lt;\u0026lt; sum\u0026lt;\u0026lt; endl; } } string流类基础 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 输入流 stringstream ss; ss \u0026lt;\u0026lt; \u0026#34;GodFishhh\u0026#34;; // 输出为字符串形式 cout \u0026lt;\u0026lt; ss.str() \u0026lt;\u0026lt; endl; // 偷看下一个字符, 流内还有字符 // \u0026#34;asdfasdf\u0026#34;, 哪怕运行一万次, 也是输出 a int peek(); // 获取字符 int get(); ostringstream oss; oss \u0026lt;\u0026lt; \u0026#34;GodFishhh and AFish\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 20030331 \u0026lt;\u0026lt; endl; // 成员函数str()的无参数形式 cout \u0026lt;\u0026lt; oss.str() \u0026lt;\u0026lt; endl; // 成员函数str()的有参数形式 // oss.str(\u0026#34;with parameter\u0026#34;); oss.str(\u0026#34;after \u0026#34;); cout \u0026lt;\u0026lt; oss.str() \u0026lt;\u0026lt; endl; ss \u0026lt;\u0026lt; \u0026#34;AFish\u0026#34;\u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ss.str(); // 清空 ss.clear(); ","date":"2023-10-05T16:29:20Z","permalink":"https://li54426.github.io/p/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/","title":"ACM输入输出总结"},{"content":" content {:toc} 论文降重 你是一个期刊收录系统,你熟练使用文本相似度算法如余弦相似度,Jaccard,曼哈顿距离等,来判断原文与相似内容之间的相似度接下来,我将给你原文与相似内容.你需要给我两者的相似度结果,然后,你需要对原文进行改写,使相似度降低到-1,然后重新计算原文与相似内容的相似度最终,你会把修改后的原文给我以及他与相似内容的想似度\n原文内容: 智能车辆的任务并不是都可以卸载的，车辆任务按照其关键程度分为三类：关键任务（Crucial Tasks，CTs）、高优先级应用程序（High-Priority Tasks，HPTs）和低优先级应用程序（Low-Priority Tasks，LPTs）。\nCTs是和车辆安全相关的应用，是保证车辆和乘客安全的关键应用程序，如车辆控制、系统监控和事故预防等。由于CTs和安全紧密相关，因此享有最高的优先级，必须保留充足的计算资源给它，不能因为HPTs和LPTs的存在而影响CTs的正常运行，因此这类任务也不允许卸载，只允许在本地执行，不属于计算任务卸载的范畴。该类任务的实例是：车辆控制、碰撞预警、红绿灯警告、网上车辆诊断、道路湿滑检测等。\nHPTs包括与驾驶相关的应用和可选的安全增强应用，这类应用程序对车辆而言是重要但不是必须的，拥有较高的执行优先级，例如实时路径规划和路况提醒等。这类应用允许出现延迟或卸载失败的情况，但不能影响CTs。该类任务的实例是：地图导航、平视显示器、视野增强、车辆传感等。\nLPTs是一类为用户提供影音娱乐服务的应用程序，它的优先级较低，例如语音识别，它允许驾驶员发出各种声音命令，通过语音识别命令计算机做一些响应，而不会使驾驶员分心。该类任务的实例是：虚拟现实、语音识别、视频处理、在线游戏等。\nHPTs和IPTs已经被部署到越来越多的车辆上，由于HPTs和LPTs不会涉及到安全，因此可以将其进行卸载，来提高资源的利用率。\nprompt_论文润色 充当论文润色者（拿摘要部分举例）\n请你充当一名论文编辑专家，在论文评审的角度去修改以下论文，使其更加流畅，优美。下面是具体要求：\n能让读者快速获得文章的要点或精髓，让文章引人入胜；能让读者了解全文中的重要信息、分析和论点；帮助读者记住论文的要点 字数限制在 300 字以下 请你在摘要中明确指出您的模型和方法的创新点，强调您的贡献。 用简洁、明了的语言描述您的方法和结果，以便评审更容易理解论文 下文是论文的摘要部分，请你修改它：\n充当论文润色者（拿摘要部分举例）\n请你充当一名论文编辑专家，在论文评审的角度去修改以下论文，使其更加流畅，优美。下面是具体要求：\n能让读者快速获得文章的要点或精髓，让文章引人入胜；能让读者了解全文中的重要信息、分析和论点；帮助读者记住论文的要点 字数限制在 300 字以下 请你在摘要中明确指出您的模型和方法的创新点，强调您的贡献。 用简洁、明了的语言描述您的方法和结果，以便评审更容易理解论文 写研究进展 参考北大核心期刊,总结《车联网中的任务卸载算法》,写一篇5000字左右的专业学术论文,要求引用文献有中文和英文,不少于20篇.\n论文润色 润色指标：\n1 删除不必要的内容 2 加强段落之间的过渡 3 修正拼写和语法错误 4 优化段落结构 5 替换过时的词汇或短语 6 增加更多的细节和具体内容 7 澄清表达意思 8 调整字母大小写规范 9 提高段落可读性 10 替换文章中的垃圾词语\n通过模仿下面的的内容进行修改：\n","date":"2023-09-30T14:10:07Z","permalink":"https://li54426.github.io/p/gpt-%E6%8F%90%E7%A4%BA%E8%AF%8D/","title":"GPT 提示词"},{"content":" content {:toc} 数值类型的问题 整型与浮点型 在 C++ 中，当一个浮点数和一个整数进行乘法运算时，整数会被隐式地转换成与浮点数相同的类型，然后进行乘法运算。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void test1(){ float f=3.5; int m =6; long k=21; cout\u0026lt;\u0026lt; \u0026#34;k/2=\u0026#34;\u0026lt;\u0026lt; k/2\u0026lt;\u0026lt; endl; double ss=f * m + k/2; cout\u0026lt;\u0026lt;\u0026#34;ss=\u0026#34;\u0026lt;\u0026lt; ss\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt; \u0026#34;m * f =\u0026#34; \u0026lt;\u0026lt; m* f\u0026lt;\u0026lt; endl; } // 输出结果如下 // k/2=10 // ss=31 // m * f =21 // sizeof a = 12 整型与大整形 在 C++ 中，当一个表达式中同时包含 int 和 long long 类型时，会发生类型转换的情况如下：\n若参与运算量的类型不同，则先转换成同一类型，然后进行运算。 转换按数据长度增加的方向进行，以保证精度不降低。如 int 型和 long 型运算时，先把 int 量转成 long 型后再进行运算 1 2 3 4 5 6 7 8 9 10 11 12 13 void test1(){ int m =6; long k=21; cout\u0026lt;\u0026lt; \u0026#34;sizeof(int) = \u0026#34;\u0026lt;\u0026lt; sizeof(int)\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;sizeof= int + long= \u0026#34;\u0026lt;\u0026lt; sizeof(m + k)\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;sizeof = long + int= \u0026#34;\u0026lt;\u0026lt; sizeof(k + m)\u0026lt;\u0026lt; endl; } sizeof(int) = 4 sizeof= int + long= 8 sizeof = long + int= 8 整型与参数模板 如果在使用模板函数时, 可以设置初值为 long long类型 例如 0LL 1 accumulate(nums.begin(), nums.end(), 0LL); 数位补足 1 2 3 4 5 6 7 8 9 10 11 void test2(){ union{ char name[10]; int n; }a; cout\u0026lt;\u0026lt; \u0026#34;sizeof a = \u0026#34;\u0026lt;\u0026lt; sizeof a \u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; sizeof (int) \u0026lt;\u0026lt;endl; } // sizeof a = 12 // sizeof int = 4 string 与 char * char *赋值 当你尝试将一个字符串字面值（例如：\u0026ldquo;test\u0026rdquo;）赋值给一个字符数组时，会发生错误。这是因为字符串字面值在 C++ 中被视为一个常量字符数组，并且具有固定的大小，无法直接赋值给一个已经定义的字符数组。 a = 'c' 也是错误的, 必须是 a[0] = 'c'; 1 2 3 4 5 6 7 8 9 10 11 void test_string_char(){ char a[5]; // 错误示例 a =\u0026#34;test\u0026#34;; // 正确示例 strcpy(a, \u0026#34;test\u0026#34;); cout\u0026lt;\u0026lt; a\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;success\u0026#34;\u0026lt;\u0026lt; endl; } 作用域 变量的作用域 不同作用域内可以重复定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; using namespace std; int n = 0; int main(){ int n = 1; cout\u0026lt;\u0026lt; \u0026#34;全局n=\u0026#34;\u0026lt;\u0026lt; ::n\u0026lt;\u0026lt; endl; int n = 1; cout\u0026lt;\u0026lt; \u0026#34;函数内n=\u0026#34;\u0026lt;\u0026lt; n\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; { int n = 2; cout\u0026lt;\u0026lt; \u0026#34;括号内n=\u0026#34;\u0026lt;\u0026lt; n\u0026lt;\u0026lt; endl;; } } // 全局n=0 // 函数内 n=1 // 括号内 n=2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: bool isMatch(string s, string p) { // s is long , p is short return dp(s, 0, p, 0); } bool dp(string \u0026amp;s, int i, string \u0026amp;p, int j){ // * 的作用可以复制, 也可以擦除 int len1 = s.size(), len2= p.size(); if(i\u0026lt; len1 \u0026amp;\u0026amp; j\u0026lt; len2){ if(s[i] == p[j] || p[j] == \u0026#39;.\u0026#39;){ // 特赦情况 if(j\u0026lt; len2-1 \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39;){ // cout\u0026lt;\u0026lt; \u0026#34;s[i] == p[j] || p[j] == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39; \u0026#34;\u0026lt;\u0026lt; \u0026#34;i=\u0026#34;\u0026lt;\u0026lt; i\u0026lt;\u0026lt; \u0026#34;\\tj=\u0026#34;\u0026lt;\u0026lt;j \u0026lt;\u0026lt; endl; return dp(s, i+1, p, j) || dp(s, i, p, j+2); }else{ return dp(s, i+1, p, j+1); } }else{ if(j\u0026lt; len2 -1 \u0026amp;\u0026amp; p[j+1] ==\u0026#39;*\u0026#39;){ return dp(s, i, p, j+2); }else{ return 0; } } }else if(i == len1){ while(j\u0026lt; len2-1 \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39;){ j+=2; } return j == len2; } return 0; } }; ","date":"2023-09-22T21:08:05Z","permalink":"https://li54426.github.io/p/c-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/","title":"C++的一些基础问题"},{"content":" content {:toc} 模板推荐\nChinese English resume template 中英双语简历模板 - Overleaf, Online LaTeX Editor 中文简历模板（Chinese Resume Template） - Overleaf, Online LaTeX Editor 推荐使用以上两个简历, 知乎推荐的简历字体太大了, 不推荐使用\n1 简历原则： 简历模板要清晰、简洁！别用花里胡哨的格式, 双栏简历达咩 简历不超过一页纸 错别字和语病不要有、字体统一 不同岗位，不同要求，不同简历 2 基本信息 证件照: 最好用白底、灰底、蓝底的职业照/证件照，这样一来既不会让你的照片在简历上显得很突兀，同时会让HR更加有印象。 个人基本情况, 姓名, 性别, 年龄, 联系方式 学历, 学位, 专业 教育背景要有, 格式可以像 大学, 专业, 时间, 主修课程: 核心课程就可 信息要全, 电话, 邮箱, 籍贯等等 3 项目/ 实习经历 【建议】 项目经历是简历中非常重要的一部分，它能够展示你在实际工作中的能力和经验。如果你还没有项目经历，建议你尽快参与一些项目，可以是学校的实践课程、实习或者自己的个人项目。通过参与项目，你可以锻炼自己的团队合作能力、问题解决能力和项目管理能力，同时也能够丰富你的简历内容，提高竞争力。\n【示例】 以下是我简历中的项目经历：\n项目名称：在线商城网站开发\n项目描述：负责开发一个在线商城网站，包括用户注册登录、商品浏览购买、订单管理等功能。 - 职责：担任前端开发工程师，负责网站的页面设计和前端代码编写。 工作成果：成功完成网站的前端开发工作，实现了用户友好的界面和良好的用户体验。网站上线后，用户访问量增加了xx%，销售额提升了xx%。 项目名称：智能家居系统设计 - 项目描述：参与设计一个智能家居系统，包括家庭安防、智能控制等功能。 - 职责：担任软件工程师，负责系统的需求分析、系统设计和代码编写。 - 工作成果：成功完成系统的设计和开发工作，实现了远程监控、智能控制等功能。系统上线后，用户满意度提高了xx%，故障率降低了xx%。 3. 项目名称：数据分析与挖掘 - 项目描述：参与一个数据分析与挖掘项目，对大量的数据进行分析和挖掘，提取有价值的信息。 - 职责：担任数据分析师，负责数据清洗、特征提取和模型建立。 - 工作成果：成功完成数据分析和挖掘工作，提取出了关键指标和规律，并提供了有针对性的决策建议。项目完成后，公司的利润增长了xx%。 以上是我在简历中的项目经历，通过这些项目，我不仅提升了自己的技能和经验，也取得了一定的成绩和成就。 4 职业技能 (专业技能) 【建议】 职业技能是简历中非常重要的一部分，它能够展示你的专业能力和技术水平。对于已有的职业技能，建议你在描述时要更加具体和有针对性，可以提供一些相关项目经验或成果，以突出你的实际应用能力。另外，可以考虑添加一些与职位要求相关的技能，以提高简历的匹配度。\n计算机二级\u0026hellip;. 5 其他模块 语言能力 六级等 获奖经历 自我评价 兴趣爱好 所有的模板你都可以放心用，按你的经验，简历要尽量保证在一页以内。目前的简历内容比较少，有大量的留白，非常容易被pass，要补充内容尽可能将简历达到一页。如果当前的模块无法达到1页，想下有没有其他经历适合放到简历上。\n","date":"2023-09-10T19:19:59Z","permalink":"https://li54426.github.io/p/%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C%E6%95%99%E8%AE%AD/","title":"简历制作教训"},{"content":" content {:toc} 函数模板不能使用 auto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 bool cmp(pair\u0026lt;int, int\u0026gt; \u0026amp;a, pair\u0026lt;int, int\u0026gt; \u0026amp;b){ if( a.first == b.first){ a.second = b.second; return 1; } return 0; } class Solution { public: vector\u0026lt;int\u0026gt; smallestSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 找一个最短的子数组, 使得 | 之后的值最大 // 按位或的性质? // 从x=nums[i]出发,OR的结果至多有多少种? // 关键:1不能变成0, 0可以变成1至多能变多少次?变29次,总共30种 int len = nums.size(); vector\u0026lt;int\u0026gt; res(len, 0); vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; ors; for(int i= len-1; i\u0026gt;-1; --i){ ors.push_back({nums[i], i}); for(int j = 0; j\u0026lt; ors.size(); ++j){ ors[j].first |= nums[i]; } auto it = unique(ors.begin(), ors.end(), cmp); ors.resize(it - ors.begin()); res[i] = ors[0].second-i +1; } return res; } }; 在 C++ 中，使用 auto 关键字可以让编译器自动推导变量的类型。然而，在函数模板中，编译器无法自动推导函数参数的类型，因此必须使用显示的类型。\n在给定的代码中，cmp 函数被用作 unique 函数的比较函数。unique 函数是一个函数模板，它接受两个迭代器和一个比较函数作为参数，并在指定范围内移除相邻的重复元素。\n因为 cmp 函数是作为比较函数传递给 unique 函数的，所以编译器无法自动推导参数的类型。因此，参数类型必须显式地指定为 pair\u0026lt;int, int\u0026gt;\u0026amp;，以便 unique 函数正确调用 cmp 函数进行比较。\n如果将参数类型改为 auto，编译器将无法确定参数类型，从而无法正确调用 cmp 函数，导致编译错误。\nlambda表达式 使用 auto 1 2 vector\u0026lt;int\u0026gt; aaaa (7, 0); unique (aaaa.begin (), aaaa.end (), [](auto a, auto b){return a== b;} ); 对于标准库算法函数（如 unique），它们是在 C++98/03 标准中定义的，不支持使用模板参数推导，因此无法直接使用 lambda 表达式作为比较函数。\n在 C++11 引入 lambda 表达式之前，为了使用自定义比较函数，我们通常需要使用函数指针或函数对象来传递函数。这要求我们定义一个具体的函数或函数对象，并显式地指定其类型。\n然而，在 C++11 之后的版本（包括 C++11、C++14 和 C++17），lambda 表达式提供了更简洁和灵活的方式来定义匿名函数，并可以在标准库算法中直接使用。\n所以，你可以使用 lambda 表达式作为比较函数传递给 unique 函数，而不需要使用函数指针或函数对象。这种语法糖使代码更简洁、可读性更好，并且能够自动推导参数类型。\n总而言之，C++11 以后的标准支持 lambda 表达式作为比较函数的直接传递，而之前的标准则需要使用函数指针或函数对象来传递自定义函数。\n","date":"2023-08-23T11:43:45Z","permalink":"https://li54426.github.io/p/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E-auto-%E5%85%B3%E9%94%AE%E5%AD%97/","title":"函数模板与 auto 关键字"},{"content":" content {:toc} 1024 相关/ 项目 1 简介 拿到邀请码以后再去注册\n主要功能\n在线多人协作, 包括代码 code 在线分享: 类似于 kaggle 助手: gpt Git版本管理: Git Commit,管理你的代码版本 数据库: 云端数据库 建议 创建 github仓库\n‌‌‌⁢⁤﻿‍⁣‍‌‬‌‌﻿﻿﻿⁡⁣⁤‌⁡﻿⁣⁤‬⁣‬﻿﻿‍⁡⁢⁡⁣‬⁣⁡⁡⁤⁡‌1024Code 组队协作编程流程说明文档（后端） - 飞书云文档 (feishu.cn)\n产品简介 | 1024Code 文档中心\n2 github 联动 添加公钥到 GitHub/Gitee/GitLab\n打开个人中心设置页面复制个人的 SSH 公钥：添加到你的 GitHub/Gitee/GitLab 账户中：\n创建一个和代码空间同名的远程仓库，或在已存在的远程仓库中复制该仓库地址，如：git@github.com:li382112772/SimpleNES.git 3 创建团队 登录1024Code账号,进入工作台后,点击我的团队区域的\u0026quot;创建团队\u0026ldquo;功能按钮创建团队. 上传团队头像,填写团队名称以及团队简介信息后创建团队. 在团队工作台成员页面,添加或使用链接邀请成员加入团队. 在对团队成员列表里,可以更改成员角色、移出团队成员,可更改的角色包括:\n成员:可自由创建团队代码空间,可见团队所有代码空间,但不可编辑自己未加入协作的代码空间 管理员:可自由创建团队代码空间,可见并可主动加入所有团队代码空间进行协作编辑,可处理团队加入申请、可管理团队 所有者:拥有管理员全部权限的同时,可移交团队给其他成员(将其他成员设为所有者) 4 1024 创建代码空间 进入团队工作台,点击新建按钮选择 Go1.17环境模版,给团队创建代码空间: 代码空间创建成功后,在终端 shell中使用 git clone命令从服务端 Demo仓库(https://github.com/RaymondCode/simple-demo) clone项代码 或者直接Fork现成的项目demo代码空间:抖音项目服务端Demo - 1024Code 邀请队员加入代码空间协作\n在代码空间中点击协作浮窗,搜索添加或链接邀请队员加入代码空间进行实时协作编程. 使用git功能从远程仓库同步代码\n首先前往GitHub/GitLab网站创建一个项目,作为这次组队项目的远程代码仓库,并各自创建分支,以方便团队成员之间异步协作. 之后,打开1024Code代码空间git功能侧边窗口,按照操作提示流程连接远程仓库,同步1024Code代码仓库代码和GitHub/GitLab远程库代. 连接App调试接口\n按照项目要求下载apk 安装App后.在App中设置服务端地址,即1024Code代码空间浏览器输出窗口中的URL地址,进行接口调试,如下图: 注意:1024Code代码空间浏览器输出窗口中的URL地址,如https:/e398ab9bee48dc435e6fd167398b57c3-app.1024paas.com,伴随着代码空间所在容器的释放和重启激活(代码空间长时间无操作或者关闭页面后代码空间所在容器会被释放掉,再次打开后会重启一个容器),该URL地址会变.当服务端URL地址改变后,需要在App中重新设置下服务端地址. 此外,1024Code浏览器输出端口暂时仅支持8080端口,参照demo代码空间, listen and serve on 0.0.0.0:8080.\n5 1024 的问题 使用git clone命令克隆项目代码报错 1024Code IDE环境默认为国内网络环境,国内网络环境连接 GitHub,使用git clone命令会有不稳定的情况导致clone失败,失败时可多次尝试. 如何安装依赖1024 Code IDE代码空间基于Linux环境,并使用了Nixos来管理系统依赖,常用的第三方依赖我们可以使用npm install的方式进行安装,系统级依赖,如node.js和npm包,需要通过nix的方式,具体可参照:https://docs.1024code.com/Tutorials/practice 项目编译被 Killed 1024Code默认提供了1G内存大小的容器环境给每个代码空间,部分项目编译及运行时需要的内存大小瞬时超过1G,内存不足系统会kill掉该进程.遇到这种情况,大家在群里联系我们,青训营期间我们可以直接帮大家调大代码空间容器内存大小. 6 环境问题 1024Code 使用 NixOS 对 IDE 进行环境管理（不支持 sudo 和 apt），我们需要通过修改代码空间的 nix 配置文件 .1024nix，在 .1024nix 的 packages 中添加新的依赖项。 .1024nix 为受限的隐藏文件，所以需要我们在 shell 中用 vim 命令对文件进行修改，或者使用 cp 命令将.1024nix 复制成新文件到文件树打开进行修改， 如 cp .1024nix 1。修改后，再执行 cp 1 .1024nix 命令，使 “1” 文件中的内容覆盖.1024nix 文件中的内容；然后点击运行按钮，重新运行项目，以更新环境基础依赖。 需要哪个包可以提前在nixos.org搜索下； 1 2 3 4 5 6 7 # 复制为可见副本 cp .1024nix 1 # 修改 # 将副本修改为 配置文件 cp 1 .1024nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { pkgs ? import \u0026lt;nixpkgs\u0026gt; {} }: pkgs.mkShell { shellHook = \u0026#39;\u0026#39; alias ll=\u0026#34;ls -l\u0026#34; export PS1=\u0026#34;\\[\\e[0m\\]\\w\\[\\e[0m\\]#\\[\\e[0m\\] \u0026#34; export LANG=en_US.UTF-8 export GO111MODULE=on export GOPROXY=https://goproxy.cn,direct export PATH=$PATH:~/go/bin \u0026#39;\u0026#39;; packages = [ # env pkgs.go_1_17 pkgs.mysql57 pkgs.mongodb pkgs.ffmpeg pkgs.minio pkgs.redis pkgs.postgresql # lsp pkgs.gopls pkgs.glibcLocales ]; } 7 go 如何设置 数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) func main() { db, err := sql.Open(\u0026#34;mysql\u0026#34;, getConnectionString()) if err != nil { log.Fatal(err) } defer db.Close() err = db.Ping() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Connected to MySQL database!\u0026#34;) } func getConnectionString() string { server := os.Getenv(\u0026#34;MYSQL_HOST\u0026#34;) port := os.Getenv(\u0026#34;MYSQL_PORT\u0026#34;) user := os.Getenv(\u0026#34;MYSQL_USER\u0026#34;) password := os.Getenv(\u0026#34;MYSQL_PASSWORD\u0026#34;) database := \u0026#34;mydatabase\u0026#34; return fmt.Sprintf(\u0026#34;%s:%s@tcp(%s:%s)/%s\u0026#34;, user, password, server, port, database) } ","date":"2023-08-15T16:24:03Z","permalink":"https://li54426.github.io/p/1024-code-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","title":"1024 code 使用说明"},{"content":" content {:toc} 引用来实现多态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; using namespace std; class Base { public: virtual void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Base class.\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Derived class.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Derived derivedObj; Base\u0026amp; baseRef = derivedObj; // 使用基类引用引用派生类对象 baseRef.print(); // 调用的是 Derived 类中的 print 函数 return 0; } 不涉及多态时, 删除对象会发生什么 结果, 还能运行函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; using namespace std; class Base { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Base class.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base * p = new Base(); delete(p); p-\u0026gt; print(); cout\u0026lt;\u0026lt; \u0026#34;success\u0026#34;\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;iostream\u0026gt; using namespace std; class Base { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Base class.\u0026#34; \u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;a = \u0026#34;\u0026lt;\u0026lt; a \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } int a = 0; }; int main() { Base * p = new Base(); p-\u0026gt;print(); // a = 0; delete(p); p-\u0026gt; print(); // a = 5898 return 0; } ","date":"2023-08-14T15:09:19Z","permalink":"https://li54426.github.io/p/c-%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%A5%87%E6%80%AA%E7%9A%84%E4%BA%8B%E6%83%85/","title":"c++中那些奇怪的事情"},{"content":" content {:toc} 0 jekyII + github pages 运行博客的问题 我的typora中的图片设置为复制到assets文件夹下，因此github page生成博客的时候会发生图片加载失败的问题。\n这是上传到 gitee 云的 png 文件 加载失败\n这是上传到 gitee 云的 webp 文件 加载成功\n一共有两种解决方案\n图片转换为 webp 文件，上传\n存储到到固定目录下，如果你的图片存在根目录assets中img文件夹下，写相对位置assets/img，例如![图片](assets/img/1.png)\n使用base64编码\n在截屏快捷键截屏后直接复制 base64 编码到 Markdown 编辑器\n3.2 引用图片和其它资源 很多时候，你需要在文章中引用图片、下载或其它数字资源。尽管 Markdown 和 Textile 在链接这些资源时的语法并不一样，但你只需要关心在站点的哪些地方保存这些文件。\n由于 Jekyll 的灵活性，有很多方式可以解决这个问题。一种常用做法是在工程的根目录下创建一个文件夹，命名为　assets 或者 downloads，将图片文件，下载文件或者其它的资源放到这个文件夹下。然后在任何一篇文章中，它们都可以用站点的根目录来进行引用。这和你站点的域名 / 二级域名和目录的设置相关，下面有一些例子（Markdown 格式）来演示怎样利用 site.url 变量来解决这个问题。\n在文章中引用一个图片\n1 2 … 从下面的截图可以看到： ![有帮助的截图]({{ site.url }}/assets/screenshot.jpg) 链接一个读者可下载的 PDF 文件：\n1 … 你可以直接 [下载 PDF]({{ site.url }}/assets/mydoc.pdf). 1 简介 1.1 Jekyll 究竟是什么？ Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如 Markdown）和我们的 Liquid 渲染器转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的。\n站点内容页面，可以使用 markdown 或 html 来编写，但 markdown 编写的 md 文件，在浏览器地址访问的时候依然使用 html 文件后缀。且html优先级更高\n官方文档\n1 2 3 4 5 6 7 8 9 10 11 12 $ jekyll build # =\u0026gt; 当前文件夹中的内容将会生成到 ./_site 文件夹中。 $ jekyll build --destination \u0026lt;destination\u0026gt; # =\u0026gt; 当前文件夹中的内容将会生成到目标文件夹\u0026lt;destination\u0026gt;中。 $ jekyll build --source \u0026lt;source\u0026gt; --destination \u0026lt;destination\u0026gt; # =\u0026gt; 指定源文件夹\u0026lt;source\u0026gt;中的内容将会生成到目标文件夹\u0026lt;destination\u0026gt;中。 $ jekyll build --watch # =\u0026gt; 当前文件夹中的内容将会生成到 ./_site 文件夹中， # 查看改变，并且自动再生成。 1.2 目录结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . ├── _config.yml ├── _drafts | ├── begin-with-the-crazy-ideas.textile | └── on-simplicity-in-technology.markdown ├── _includes | ├── footer.html | └── header.html ├── _layouts | ├── default.html | └── post.html ├── _posts | ├── 2007-10-29-why-every-programmer-should-play-nethack.textile | └── 2009-04-26-barcamp-boston-4-roundup.textile ├── _site ├── .jekyll-metadata └── index.html config.yml 里写有整个站点的主要配置项 _includes 可以在模板中随时包含的文件 _layouts 布局文件，在博客头配置中可以选择 _posts 下的所有目录中的所有博客 注意: .yml 文件中，字段的冒号后面必须有空格！\n2 头部信息(设置信息) 2.1 头信息 变量名称 描述 layout 如果设置的话，会指定使用该模板文件。指定模板文件时候不需要文件扩展名。模板文件必须放在 _layouts 目录下。 permalink 如果你需要让你发布的博客的 URL 地址不同于默认值 /year/month/day/title.html，那你就设置这个变量，然后变量值就会作为最终的 URL 地址。 published 如果你不想在站点生成后展示某篇特定的博文，那么就设置（该博文的）该变量为 false。 date 这里的日期会覆盖文章名字中的日期。这样就可以用来保障文章排序的正确。日期的具体格式为 YYYY-MM-DD HH:MM:SS +/-TTTT；时，分，秒和时区都是可选的。 category 除过将博客文章放在某个文件夹下面外，你还可以指定博客的一个或者多个分类属性。这样当你的站点生成后，这些文章就可以根据这些分类来阅读。categories 可以通过 YAML list，或者以逗号隔开的字符串指定。 tags 类似分类 categories，一篇文章也可以给它增加一个或者多个标签。同样，tags 可以通过 YAML 列表或者以逗号隔开的字符串指定。 2.2 格式 传统的块格式使用连字符 + 空格来开始列表中的新项目。\n1 2 3 4 --- # Favorite movies - Casablanca - North by Northwest - The Man Who Wasn\u0026#39;t There 可选的内联格式由逗号+空格分隔，并括在括号中\n1 2 --- # Shopping list [milk, pumpkin pie, eggs, juice] 2.3 默认值 假设您想添加一个默认的布局给站点中的所有页面和文章。 你要将这添加到你的 _config.yml 文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 defaults: - scope: path: \u0026#34;\u0026#34; type: \u0026#34;posts\u0026#34; values: layout: \u0026#34;my-site\u0026#34; - scope: path: \u0026#34;projects\u0026#34; type: \u0026#34;pages\u0026#34; # 以前的 `page`， 在 Jekyll 2.2 里。 values: layout: \u0026#34;project\u0026#34; # 覆盖之前的默认布局 author: \u0026#34;Mr. Hyde\u0026#34; 2.4 路径的组织方式 总体设置\n1 2 3 4 5 6 7 8 9 #产生路径方式 permalink: pretty permalink: /:categories/:title.html # 可以使用分类的方式 permalink: /:categories/:title.html # 这是默认的方式 permalink: /:year/:month/:day/:title.html https://xxxx.github.io/algorithm/2023/07/30/problem-string/ 单独设置\n1 2 3 --- permalink: /about/ --- Permalink Style URL Template date /:categories/:year/:month/:day/:title:output_ext pretty /:categories/:year/:month/:day/:title/ ordinal /:categories/:year/:y_day/:title:output_ext weekdate4.0 /:categories/:year/W:week/:short_day/:title:output_ext (W will be prefixed to the value of :week) none /:categories/:title:output_ext 3 其他 3.1 github 某些 样式 Jekyll Themes\ncotes2020/jekyll-theme-chirpy：一个用于技术写作的最小、响应迅速且功能丰富的 Jekyll 主题。 (github.com)\n博客模板 1\nartemsheludko/bef: Bef is a responsive jekyll theme https://artemsheludko.github.io/bef/\nleopardpan/leopardpan.github.io: 个人博客，看效果进入\n再用 2023 依旧更新\n","date":"2023-07-31T19:55:34Z","permalink":"https://li54426.github.io/p/jekyll%E8%BF%9B%E9%98%B6%E8%AE%BE%E7%BD%AE/","title":"jekyll进阶设置"},{"content":" content {:toc} 规范 1 2 3 4 5 \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;body\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;footer\u0026gt; type: 必填 commit 类型，有业内常用的字段，也可以根据需要自己定义 feat 增加新功能 fix 修复问题 / BUG style 代码风格相关无影响运行结果的 perf 优化 / 性能提升 refactor 重构 revert 撤销修改 test 测试相关 docs 文档 / 注释 chore 依赖更新 / 脚手架配置修改等 workflow 工作流改进 ci 持续集成 types 类型定义文件更改 wip 开发中 undef 不确定的分类 scope: commit 影响的范围，比如某某组件、某某页面 subject: 必填 简短的概述提交的代码，建议符合 50/72 formatting body: commit 具体修改内容，可以分为多行，建议符合 50/72 formatting footer: 其他备注，包括 breaking changes 和 issues 两部分 ","date":"2023-07-30T19:08:53Z","permalink":"https://li54426.github.io/p/commit-%E8%A7%84%E8%8C%83/","title":"commit 规范"},{"content":" content {:toc} 0 代码风格 C++ 风格指南 Cpplint 是一个 Python 脚本，作为一款开源免费的代码静态检测工具，Google 也使用它作为自己的 C++ 代码检测工具，也就是说，只要你想代码遵从 Google C++ 代码规范，那么 Cpplint 将会提供很好的代码静态检测支持。 1. 命名规则 文件名要全部小写, 可以包含下划线 (_) 或连字符 (-), 依照项目的约定. 如果没有约定, 那么“_”更好. 内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中. 类名称的每个单词首字母均大写, 不包含下划线: 形如MyExcitingClass, MyExcitingEnum. 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 常量 声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以“k”开头, 大小写混合.const int kDaysInAWeek = 7; 函数名的每个单词首字母大写 (即“驼峰变量名”或“帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 StartRpc() 而非 StartRPC()). 较好的起名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int price_count_reader; // 用于读取价格计数器 int num_errors; // 错误数量 int num_dns_connections; // DNS 连接数量 int count; // 计数器 int error_count; // 错误数量 int num_completed_connections; // 完成的连接数量 int web_gateway_connections; // Web 网关连接数量 int page_cache_reader; // 用于读取页面缓存 int customer_id; // 客户 ID // 类内变量名的规范 string table_name; // 好 - 用下划线. string tablename; // 好 - 全小写. string tableName; // 差 - 混合大小写 // 常量命名规范 const int kDaysInAWeek = 7; 2 注释风格 下面的规则描述了如何注释以及在哪儿注释\n三层的注释\n文件注释\n类注释\n函数注释\n变量注释/ 实现注释\n使用 // 或 /* */, 统一就好.\n文件注释描述了该文件的内容. 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释\n我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.\n1 2 3 4 5 6 7 8 9 ReturnType LongClassName::ReallyReallyReallyLongFunctionName( Type par_name1, // 4 space indent Type par_name2, Type par_name3) { DoSomething(); // 2 space indent ... } ","date":"2023-07-30T18:47:50Z","permalink":"https://li54426.github.io/p/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/","title":"代码风格"},{"content":" content {:toc} 0 需要的文件 问题文件 question.txt 题库文件 diction.xlsx 输出为查询结果.xlsx 1 读取查询列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ##########-读取查询列-######### # 文本预处理 filepath = \u0026#34;./auto/question.txt\u0026#34; with open(filepath, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: text = f.read() text_new = text.replace(\u0026#39;（\u0026#39;, \u0026#39;(\u0026#39;) text_new = text_new.replace(\u0026#39;）\u0026#39;, \u0026#39;)\u0026#39;) with open(filepath, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(text_new) # 打开txt文件并读取内容 with open(\u0026#34;./auto/question.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: content = file.read() # print(\u0026#34;contect=\u0026#34;, content) # 把题目导出来 pattern = r\u0026#39;(\\d+\\.+)(.+?)(?=(\\(|\\。|\\n|$))\u0026#39; matches = re.findall(pattern, content, flags=re.DOTALL) # [(\u0026#39;1. \u0026#39;, \u0026#39;质量流量计不能够直接测出的参数是（ ）\u0026#39;),.....] 2 读取题库 1 2 3 4 5 6 7 8 ######### 读取题库 ############## dic = [] # 读取单选题 df= pd.read_excel(\u0026#34;./auto/diction.xlsx\u0026#34;, sheet_name=\u0026#34;one\u0026#34;, usecols=[0,1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values #print(df) dic1= [(question, ans) for question, ans in value_array] dic.extend(dic1) 3 进行查题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ########### 进行查询 ############### res= [] num = 0 for match in matches: # 查询id, 查询题目 id = match[0] qu = match[1] # 题目过短, 自己进行处理 if(len(qu)\u0026lt;=5): res.append((id, \u0026#34;没有答案\u0026#34;)) continue flag = 0 # 开始从题库中查询 for allqu, ans in dic: if qu in allqu: res.append((id, ans)) flag =1 num+=1 break if(flag ==0): res.append((id, \u0026#34;没有答案\u0026#34;)) # print(\u0026#34;res=\u0026#34;, res) print(\u0026#34;共查询到\u0026#34;, num , \u0026#34;/\u0026#34;, len(res),\u0026#34;个结果\u0026#34;) # 输出为 execl, 一共两列 data = { \u0026#39;题号\u0026#39;: [item[0] for item in res], \u0026#39;答案\u0026#39;: [item[1] for item in res] } df=pd.DataFrame(data) df.to_excel(\u0026#34;./auto/查询结果.xlsx\u0026#34;,sheet_name=\u0026#34;Sheet1\u0026#34;, header=None, index=False) ############ 如果没有搜索到答案 ########### print(\u0026#34;下面请输入没有搜索到答案的问题\u0026#34;) for i in range(100): s = input(\u0026#34;请输入问题：(右键即黏贴)\\n\u0026#34;) for ques, ans in dic: if s in ques: print(ans,\u0026#34;\\n\\n\\n\u0026#34;) 4 总体代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 import re import pandas as pd ##########-读取查询列-######### # 文本预处理 filepath = \u0026#34;./auto/question.txt\u0026#34; with open(filepath, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: text = f.read() text_new = text.replace(\u0026#39;（\u0026#39;, \u0026#39;(\u0026#39;) text_new = text_new.replace(\u0026#39;）\u0026#39;, \u0026#39;)\u0026#39;) with open(filepath, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(text_new) # 打开txt文件并读取内容 with open(\u0026#34;./auto/question.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: content = file.read() # print(\u0026#34;contect=\u0026#34;, content) # 把题目导出来 pattern = r\u0026#39;(\\d+\\.+)(.+?)(?=(\\(|\\。|\\n|$))\u0026#39; matches = re.findall(pattern, content, flags=re.DOTALL) # [(\u0026#39;1. \u0026#39;, \u0026#39;质量流量计不能够直接测出的参数是（ ）\u0026#39;),.....] # print(\u0026#34;maches=\u0026#34;, matches) matches = [(ma[0], ma[1] ) for ma in matches] print(\u0026#34;maches=\u0026#34;, matches) # 将数据转换成 DataFrame 格式 # 将数据转换成 DataFrame 格式, 并修改列名为 \u0026#34;序号\u0026#34; 和 \u0026#34;答案\u0026#34; df = pd.DataFrame(matches, columns=[\u0026#39;序号\u0026#39;, \u0026#39;问题\u0026#39;]) # 使用 slice() 方法将 content 列的字符串长度截断为 20 df[\u0026#39;问题\u0026#39;] = df[\u0026#39;问题\u0026#39;]#.str.slice(20) # print(\u0026#34;df=\u0026#34;, df) # 将数据保存到 Excel 文件中 df.to_excel(\u0026#39;./auto/问题列表.xlsx\u0026#39;, index=False) ######### 读取题库 ############## dic = [] # 读取单选题 df= pd.read_excel(\u0026#34;./auto/diction.xlsx\u0026#34;, sheet_name=\u0026#34;one\u0026#34;, usecols=[0,1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values #print(df) dic1= [(question, ans) for question, ans in value_array] dic.extend(dic1) # dic = [(\u0026#39;修改后的《安全生产法》由习近平主席于2014年签署第十三号令予以公布，自2014年（）起施行。\u0026#39;, \u0026#39;C\u0026#39;),(),,,,] # print(\u0026#34;\\n\\n\\ndic=\u0026#34;, dic) ########### 进行查询 ############### res= [] num = 0 for match in matches: # 查询id, 查询题目 id = match[0] qu = match[1] # 题目过短, 自己进行处理 if(len(qu)\u0026lt;=5): res.append((id, \u0026#34;没有答案\u0026#34;)) continue flag = 0 # 开始从题库中查询 for allqu, ans in dic: if qu in allqu: res.append((id, ans)) flag =1 num+=1 break if(flag ==0): res.append((id, \u0026#34;没有答案\u0026#34;)) # print(\u0026#34;res=\u0026#34;, res) print(\u0026#34;共查询到\u0026#34;, num , \u0026#34;/\u0026#34;, len(res),\u0026#34;个结果\u0026#34;) # 输出为 execl, 一共两列 data = { \u0026#39;题号\u0026#39;: [item[0] for item in res], \u0026#39;答案\u0026#39;: [item[1] for item in res] } df=pd.DataFrame(data) df.to_excel(\u0026#34;./auto/查询结果.xlsx\u0026#34;,sheet_name=\u0026#34;Sheet1\u0026#34;, header=None, index=False) ############ 如果没有搜索到答案 ########### print(\u0026#34;下面请输入没有搜索到答案的问题\u0026#34;) for i in range(100): s = input(\u0026#34;请输入问题：(右键即黏贴)\\n\u0026#34;) for ques, ans in dic: if s in ques: print(ans,\u0026#34;\\n\\n\\n\u0026#34;) ","date":"2023-07-30T17:55:31Z","permalink":"https://li54426.github.io/p/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9F%A5%E9%A2%98/","title":"自动化查题"},{"content":" content {:toc} 修改 从原作者项目地址进行 clone 原作者项目地址在这里 进行修改 上传 设置说明 修改_config.yml 的 links 为您的菜单 修改_config.yml 的 paginate 为您的按照多少页分页 修改自己的网图标\\style\\favicons\\favicon.ico 修改自己的网标志\\style\\favicons\\logo-liberxue.png 在_layouts\\blog.html中, 将 本文由 \u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;liberxue\u0026lt;/a\u0026gt; 创作 改为您的github名字 修改\\about.md中的内容, 它对应着文章中的关于这一页 在_layouts\\default.html中, 将 本文由 \u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;liberxue\u0026lt;/a\u0026gt; 创作 改为您的github名字 使用说明 打开\\_posts 文件夹是博客文章所在的位置，文件夹中的内容就是你的博客, 博客格式为 markdown 文件名格式为2015-06-11-xxxx.md, 不能有中文, 因为文件名会成为这篇博文的链接 当天的blog不会上传 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 layout: blog book: true title: \u0026#34;《美丽新世界》之幸福和自由思考\u0026#34; background: green background-image: http://ot1cc1u9t.bkt.clouddn.com/17-7-15/78939382.jpg date: 2017-07-03 23:13:54 category: 书籍 tags: - 美丽新世界 可选项目 // 设置颜色 background: green background: blue background: purple // 设置路径 redirect_from: - /about/ 颜色说明 蓝色: 软件/ API/ 提升效率 绿色: 语言相关 紫色: 算法/ 周赛 ","date":"2023-07-30T16:28:49Z","permalink":"https://li54426.github.io/p/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Egithub%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/","title":"如何基于github快速建立博客站点"},{"content":" content {:toc} 基础应用 1 相关概念与快速开始 Git的安装与使用教程（超详细！！！）_9.冄2.7.號的博客-CSDN博客_git安装教程\n版本控制是什么?\n一种记录一个或若干文件内容变化,以便将来查阅特定版本修订情况的系统 为什么需要版本控制?\n更好的关注变更,了解到每个版本的改动是什么,方便对改动的代码进行检查,预防事故发生也能够随时切换到不同的版本,回滚误删误改的问题代码; 什么是 git\nGit 是一款免费、开源的分布式版本控制系统，他是著名的 Linux 发明者 Linus Torvalds 开发的 GitHub 主要提供基于 git 的版本托管服务。也就是说现在 GitHub 上托管的所有项目代码都是基于 Git 来进行版本控制的，所以 Git 只是 GitHub 上用来管理项目的一个工具而已，GitHub 的功能可远不止于此！ 1.1 GitHub 基本概念 Repository\n仓库的意思，即你的项目，你想在 GitHub 上开源一个项目，那就必须要新建一个 Repository，如果你开源的项目多了，你就拥有了多个 Repositories 。 Issue\n问题的意思，举个例子，就是你开源了一个项目，别人发现你的项目中有bug，或者哪些地方 做的不够好，他就可以给你提个 Issue ，即问题，提的问题多了，也就是 Issues ，然后你看 到了这些问题就可以去逐个修复，修复ok了就可以一个个的 Close 掉。 Star\n这个好理解，就是给项目点赞，但是在 GitHub 上的点赞远比微博、知乎点赞难的多，如果你有一个项目获得100个star都算很不容易了！ Fork\n这个不好翻译，如果实在要翻译我把他翻译成分叉，什么意思呢？你开源了一个项目，别人 想在你这个项目的基础上做些改进，然后应用到自己的项目中，这个时候他就可以 Fork 你的 项目，这个时候他的 GitHub 主页上就多了一个项目，只不过这个项目是基于你的项目基础 （本质上是在原有项目的基础上新建了一个分支，分支的概念后面会在讲解Git的时候说 到），他就可以随心所欲的去改进，但是丝毫不会影响原有项目的代码与结构。 Pull Request\n发起请求，这个其实是基于 Fork 的，还是上面那个例子，如果别人在你基础上做了改进，后 来觉得改进的很不错，应该要把这些改进让更多的人收益，于是就想把自己的改进合并到原 有项目里，这个时候他就可以发起一个 Pull Request（简称PR） ，原有项目创建人就可以收 到这个请求，这个时候他会仔细review你的代码，并且测试觉得OK了，就会接受你的PR，这 个时候你做的改进原有项目就会拥有了。 Watch\n这个也好理解就是观察，如果你 Watch 了某个项目，那么以后只要这个项目有任何更新，你 都会第一时间收到关于这个项目的通知提醒。 Gist\n有些时候你没有项目可以开源，只是单纯的想分享一些代码片段，那这个时候 Gist 就派上用 场了！ 1.2 git 目录结构 Git 的本质是一个文件系统，工作目录中的所有文件的历史版本以及提交记录（commit）都是以文件对象的方式保存在 .git 目录中的。 git下的版本库只位于工作区根目录下的 git目录 , 仅此一处 目前的Key的类型四种,分别是dsa、rsa、ecdsa、ed25519, 默认使用的是rsa, 由于一些安全问题,现在已经不推荐使用dsa和rsa了,优先推荐使用ed25519 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ├─hooks ├─info ├─logs │ └─refs │ ├─heads │ └─remotes │ └─origin ├─objects # 保存 git 对象的目录, 包括三类对象, commit,tree, blob │ ├─info │ └─pack └─refs # 保存branch和tag对应的commit ├─heads # branch 对应的 commit ├─remotes │ └─origin └─tags # tag 对应的 commit objects：这里是真正保存 Git 对象的目录，包括三类对象 commit，tree 和 blob Blob存储文件的内容 Tree存储文件的目录信息 Commit存储提交信息,一个Commit可以对应唯一版本的代码 refs 内容就是对应 Commit ID因此把ref当做指针, 指向对应的Commit来表示当前Ref对应的版本. Branch git checkout -b可以创建一个新分支, 分支一般用于开发阶段,是可以不断添加 Commit 进行迭代的 Tag标签一般表示的是一个稳定版本, 指向的Commit一般不会变更 refs/head 下保存 分支信息 1.3 密钥生成/ 设置用户名/ 缩写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 生成本地密钥 # ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 密钥默认存在 ~/.ssh/id_ed25519.pub ssh ssh-keygen -t rsa // linux 下ssh-keygen -t rsa //根据日志信息里面的 SSH KEY 存储路径找到 .ssh/id_rsa.pub 文件 //打开 git 网站，右上角用户头像，点击 settings，左侧菜单 SSH KEYS，将文件内容复制到 key 里 添加就可以了 //设置名称和邮箱 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; # 设置简写 git config --global alias.psm \u0026#39;push origin main\u0026#39; git config --global alias.plm \u0026#39;pull origin main\u0026#39; git config --global alias.st \u0026#39;status\u0026#39; git config --global alias.ci \u0026#39;commit\u0026#39; git config --global alias.br \u0026#39;branch\u0026#39; 1.3.pull \u0026amp;push/ 快速开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //推过去所需要的步骤 # 1 添加 git add . # 2 提交改变 git commit -m \u0026#34;描述\u0026#34; # 3 将本地的 main 分支的提交推送到名为 origin 的远程仓库的 main 分支。 git push origin main # 拉过来 git pull origin main git remote add origin 仓库名 1,5 git 的三种状态 Git 有三种状态，你的文件可能处于其中之一： 已提交（committed）、已修改（modified） 和 已暂存（staged）。\n已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交表示数据已经安全地保存在本地数据库中。 1.6 objects 如何将三个信息串联在一起\n通过commit找到 tree的信息, 每个 commit 都存储对应的 tree id 通过 tree 存储的信息, 获取对应的目录树结构 从 tree中 获取blob的id, 通过blob id获取对应的文件内容 2 远端仓库/ remote 2.1 http 和 git 协议有什么区别 第一组使用 HTTPS 协议，第二组使用 SSH 协议。具体选择哪种协议取决于你的需求和配置。 使用 HTTPS 协议需要提供用户名和密码，而使用 SSH 协议则需要设置密钥对。 1 2 3 4 5 6 7 # 用于查看当前项目中配置的所有远程仓库的详细信息。 git remote -v origin https://github.com/*****/tinywebserver (fetch) origin https://github.com/*****/tinywebserver (push) origin git@github.com:*****/simple-douyin.git (fetch) origin git@github.com:*****/simple-douyin.git (push) 其中\nfetch：git fetch 命令用于从远程仓库获取最新的代码和提交历史，但不会自动合并或更新你的本地分支。它将远程仓库的内容下载到你的本地仓库，使你能够查看和比较远程分支与本地分支之间的差异。fetch 操作不会修改你的本地分支，只会更新你的本地仓库。 push：git push 命令用于将你的本地分支的提交推送到远程仓库。它将你的本地分支的提交上传到远程仓库，并将远程仓库的相应分支更新为你的提交。push 操作会修改远程仓库的内容。 2.2 链接远程仓库 1 2 3 4 5 # 链接远程仓库，使通过网络与远程仓库进行交互。 git remote add \u0026lt;remote_name\u0026gt; \u0026lt;remote_url\u0026gt; # 设置fetch 和 push 为不同的仓库 git remote set-url --add --push origin git@github. com: my_repo/git.git 1.4 我当前在 dev分支, 运行 git push main会发生什么 如果你当前在 dev 分支，并且运行 git push main 命令，Git 会尝试将当前分支的提交推送到名为 main 的远程分支。\n然而，由于你当前在 dev 分支，而不是 main 分支，这个命令可能会失败。因为默认情况下，git push 命令会将当前分支的提交推送到与当前分支同名的远程分支。\n如果你想要将 dev 分支的提交推送到远程的 main 分支，你可以使用以下命令：\n1 git push origin dev:main 这个命令将会将本地的 dev 分支的提交推送到名为 origin 的远程仓库的 main 分支。\ngit fetch origin dev:main是什么意思 git fetch origin dev:main 命令的含义是从名为 origin 的远程仓库获取 dev 分支的最新提交，并将其存储为本地的 main 分支。\n这个命令的具体含义如下：\ngit fetch：从远程仓库获取最新的提交和分支信息。 origin：远程仓库的名称，通常是你克隆或者关联的远程仓库的默认名称。 dev：远程仓库的分支名称，你希望获取其最新提交。 main：本地分支的名称，用于存储从远程仓库获取的 dev 分支的提交。 通过运行这个命令，Git 会从 origin 远程仓库获取 dev 分支的最新提交，并将其存储为本地的 main 分支。这样，你就可以在本地的 main 分支上查看和操作从远程仓库的 dev 分支获取的提交。\n需要注意的是，这个命令会将远程 dev 分支的提交直接应用到本地的 main 分支，而不会创建新的合并提交。这种操作可能会覆盖本地 main 分支上的提交，所以请确保在运行这个命令之前，你的本地 main 分支没有重要的未提交的更改。\n查看文件内容 git cat-file 是一个用于查看 Git 对象内容的命令。Git 中的对象是存储在仓库中的基本数据单元，包括提交（commit）、树（tree）、标签（tag）和文件内容（blob）等。\n使用 git cat-file 命令，你可以通过指定对象的哈希值或引用来查看对象的内容。它的基本语法如下：\n1 cat-file -t \u0026lt;对象引用\u0026gt; 这个命令将会返回指定对象的类型。例如，git cat-file -t abc123 将会返回对象 abc123 的类型，比如 commit、tree、tag 或 blob。\n1 cat-file -p \u0026lt;对象引用\u0026gt; 这个命令将会返回指定对象的内容。例如，git cat-file -p abc123 将会返回对象 abc123 的内容，比如提交信息、文件内容等。\n通过使用 git cat-file 命令，你可以查看 Git 仓库中的对象的详细信息，这对于调试和了解仓库的内部结构非常有用。\n希望这个解释对你有帮助。如果你还有其他问题，请随时告诉我！\n3 分支操作 3.1 本地操作分支 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 查看本地分支列表 git branch # 查看远程分支列表 git branch -r # 新建一个叫 develop 的分支 git branch develop # 创建一个名为 \u0026#34;test\u0026#34; 的新分支，并从 \u0026#34;master\u0026#34; 分支进行分叉。 git branch test master # 切换 到 dev 分支 git checkout dev # 新建并且自动切换到 develop 分支 git checkout -b dev # 删除本地分支 git branch -d develop # 生成分支 git tag v1.0 # 用来切换tag git checkout v1.0 git checkout ffd9f2dd68f1eb21d36cee50dbdd504e95d9c8f7 # 后面的一长串是commit_id，是每次com mit的SHA1值，可以根据 git log 看到。 # tag\u0026lt;=\u0026gt; 稳定版本 git tag v0.0.1 3.2 想拉取远程仓库的 dev 分支怎么做 要拉取远程仓库的 dev 分支，可以按照以下步骤进行操作：\n1 git fetch origin dev 使用 git fetch origin dev 命令从远程仓库拉取 dev 分支的最新代码。这将会将远程仓库的 dev 分支代码下载到你本地仓库，不会自动合并到你当前的分支。 使用 git checkout dev 命令切换到 dev 分支。如果本地还没有 dev 分支，可以使用 git checkout -b dev origin/dev 命令创建并切换到 dev 分支。 现在你已经成功拉取了远程仓库的 dev 分支，可以开始在本地与该分支进行开发和修改。记得在操作前先保存好本地的修改，以免冲突。\n3.3 远程分支 远程分支没有新建指令, 直接 push 就好 1 2 3 4 5 6 7 8 9 10 # 删除远程分支 git push origin --delete publish # 通过将 \u0026lt;source\u0026gt; 设置为空，就表示没有要推送的本地分支，而只是请求删除远程分支 git push origin :develop # 如果你远程的分支想取名叫 develop2 ，那执行以下代码： git push origin develop:develop2 # 把 develop 分支推送到远程仓库 git push origin develop 当我们使用git clone 时, 克隆下了远端的仓库的哪个分支\n当你使用 git clone 命令克隆远程仓库时，默认情况下会克隆远程仓库的主分支（通常是 master 分支或者 main 分支）。 如果你想要克隆远程仓库的特定分支，可以使用 --branch 参数指定分支名称。例如，要克隆远程仓库的 develop 分支，可以运行以下命令：\n1 git clone --branch develop \u0026lt;remote_repository_url\u0026gt; 拉取远端其他分支\n1 2 # 在本地创建一个名为 dev 的分支, 并拉取远端分支 git fetch origin dev:dev 3.4 合并分支 Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 快照 。在进行提交操作时，Git 会保存一个提交对象（commit object）。 Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 1 2 3 4 5 6 7 # 我们在一个 featureA 分支开发完了一个功能，这个时候需要合并到主分支 master 上去 git checkout master git merge featureA # 也可以这么写 git checkout master git rebase featureA 区别\nrebase 跟 merge 的区别你们可以理解成有两个书架，你需要把两个书架的书整理到一起去， 第一种做法是 merge ，比较粗鲁暴力，就直接腾出一块地方把另一个书架的书全部放进去，虽然暴力，但是这种做法你可以知道哪些书是来自另一个书架的； 第二种做法就是rebase ，他会把两个书架的书先进行比较，按照购书的时间来给他重新排序，然后重新放置好，这样做的好处就是合并之后的书架看起来很有逻辑，但是你很难清晰的知道哪些书来自哪个书架的。 3.5 遇到冲突时的分支合并 有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 现在在 master分支, 想要合并 dev 的内容 $ git merge dev Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. $ git status On branch master You have unmerged paths. (fix conflicts and run \u0026#34;git commit\u0026#34;) Unmerged paths: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to mark resolution) both modified: index.html no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) 任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突 解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看 起来像下面这个样子：\n1 2 3 4 5 6 7 8 9 # HEAD 所指向的版本 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD:index.html \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt;contact : email.support@github.com\u0026lt;/div\u0026gt; ======= # 合并所指向的版本 \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt; please contact us at support@github.com \u0026lt;/div\u0026gt; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; iss53:index.html 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内 容。同时 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; , ======= , 和 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 这些行被完全删除了。\n3.6 多人合作冲突 远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移 动它们以精确反映远程仓库的状态。它们以\u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt; 的形式命名。\n假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。Git 也会给你一个与 origin 的master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\n隔离性\n如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。 如果要与给定的远程仓库同步数据，运行 git fetch \u0026lt;remote\u0026gt; 命令 4 常见开发场景 1、本地仓库有文件，远程服务器上面是新建的仓库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1 初始化仓库 git init test # 2 在仓库中新建文件编辑内容（例如test.txt） # 3 添加到暂存区 git add test.txt # 提交修改 git commit test.txt -m \u0026#39;提交test.txt\u0026#39; # 关联远程仓库, origin也是默认仓库的名字，也可以命名为其它的名字 git remote add origin git@gitee.com:blueses/test.git # 把本地仓库的master分支与远程仓库的master分支关联起来 # 把本地仓库的master分支的文件推送到远程仓库的master分支中 git push -u origin master 2、远程服务器上面有很多代码，要拉取到本地开始开发 1 2 3 4 # 直接克隆 git clone git@gitee.com:blueses/test.git # add、commit、pull、push 三步走 5 其他操作 / igonre ignore .gitignore 文件用于告诉 Git 哪些文件或目录应该被忽略，不纳入版本控制。当你在项目中创建一个 .gitignore 文件并列出要忽略的文件或模式时，Git 将不会跟踪或记录这些文件的更改。\n.gitignore 文件的作用有以下几个方面：\n忽略生成的文件：在开发过程中，你可能会生成一些临时文件、日志文件、编译输出文件等。通过在 .gitignore 文件中列出这些文件的模式，你可以告诉 Git 忽略它们，避免将它们纳入版本控制。 忽略敏感信息：有时，你可能会在项目中包含一些敏感信息，如密码、API 密钥等。通过将这些敏感文件的路径添加到 .gitignore 文件中，你可以确保它们不会被意外地提交到版本库中。 忽略操作系统和编辑器生成的文件：不同的操作系统和编辑器可能会生成一些特定的文件，如临时文件、缓存文件、配置文件等。通过 .gitignore 文件，你可以告诉 Git 忽略这些与特定环境相关的文件。 .gitignore 文件使用简单的模式匹配规则来指定要忽略的文件或目录。你可以使用通配符、路径模式和其他规则来匹配文件名或路径。\n需要注意的是，.gitignore 文件只对尚未被 Git 跟踪的文件起作用。如果某个文件已经被 Git 跟踪并提交到版本库中，那么即使将其添加到 .gitignore 文件中，Git 仍然会继续跟踪该文件。\n工作说明\n.gitignore 是一个文本文件，其中的每一行代表一个模式，表示匹配规则，开发人员需要忽略的模式相关的模式都应该放到.gitignore 文件中\n.gitignore 一般放在代码库的根目录下，这是官方推荐的做法。但是你也可以把它放置在代码库里边的任意目录下，代码库可以有多个.gitignore 文件，其中的匹配模式的路径是相对当前.gitignore 所在目录的。\ngit add . 会追踪 gitignore的对象么 git add . 命令会将当前目录下的所有文件和文件夹添加到 Git 的暂存区，但它不会追踪 .gitignore 文件中指定的被忽略的对象。\n.gitignore 文件的作用是告诉 Git 忽略某些文件或目录，不将它们纳入版本控制。当你运行 git add . 命令时，Git 会将所有未被忽略的文件添加到暂存区，但被 .gitignore 文件指定的被忽略的文件不会被添加到暂存区。\n这意味着，.gitignore 文件中指定的被忽略的文件或目录不会被 git add . 命令追踪或添加到暂存区。它们将保持未被跟踪的状态，不会被包含在提交中。\n如果你想要确保被 .gitignore 文件指定的被忽略的文件不会被 git add . 命令添加到暂存区，你可以使用 git add --ignore-errors . 命令。这个命令会忽略被忽略的文件，并继续添加其他未被忽略的文件到暂存区。\n需要注意的是，一旦某个文件被添加到暂存区并提交到版本库中，.gitignore 文件对该文件将不再起作用。如果你想要从版本库中移除已经提交的文件，你需要使用 git rm --cached \u0026lt;file\u0026gt; 命令。\n希望这解答了你的问题！如果还有其他问题，请随时问我。我会尽力帮助你！\n提交操作 1 2 3 4 5 6 7 8 9 # 修改最近一个的 commit 信息, 修改之后, commit id 会改变 # 老的 不会删除 git commit --amend # 对最近三个commit的修改, 合并commit, 修改具体的 commit message, 删除某个commit git rebase -i HEAD~3 # 该命令可以指定删除所有提交中的某个文件或者全局修改邮箱地址等操作 filter --branch 日志操作 1 2 git reflog expire --expire=now --all git gc --prune=now 拉取操作概念辨析 Clone拉取完整的仓库到本地目录,可以指定分支,深度. Fetch将远端某些分支最新代码拉取到本地,不会执行merge操作,会修改refs/remote内的分支信息,如果需要和本地代码合并需要手动操作. Pull拉取远端某分支,并和本地代码进行合并,操作等同于 git fetch + git merge,也可以通过 git pull \u0026ndash;rebase 完成 git fetch + git rebase 操作. 可能存在冲突,需要解决冲突. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 初始化一个新的 Git 仓库： git init # git remote add origin 远程仓库URL git remote add origin git@github.com:username/repo.git # 将远程仓库内容下载到本地： git pull origin 主分支名称 # 首次拉取代码时一定会存在当前分支与远程分支不同步的问题，我们可以指定使用 rebase 策略将你的更改应用到远程更改之上： git pull --rebase origin main # 如何查看我有没有 ssh 权限修改 github 的内容 ssh -T git@github.com # # 如果你想要将本地分支与远程仓库的同名分支进行关联， git push -u origin \u0026lt;本地分支名称\u0026gt; # 可以使用 git push / git pull # 将会将本地的 main 分支推送到远程仓库 origin 的 master 分支。 git push origin main:master 高级应用 6 github action Github Action 官方文档：https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#name\n是 Github 推出的持续集成工具\n持续集成是什么？ 简单说就是自动化的打包程序 —— 如果是前端程序员，这样解释比较顺畅：\n每次提交代码到 Github 的仓库后，Github 都会自动创建一个虚拟机（Mac / Windows / Linux 任我们选），来执行一段或多段指令（由我们定），例如：\nnpm install npm run build Yaml 是什么？ 我们集成 Github Action 的做法，就是在我们仓库的根目录下，创建一个 .github 文件夹，里面放一个 *.yaml 文件 —— 这个 Yaml 文件就是我们配置 Github Action 所用的文件。\n它是一个非常容易地脚本语言，如果我们不会的话，也没啥大事继续往下看就成了。\n参考文档：五分钟学习 YAML\nGithub Action 的使用限制 每个 Workflow 中的 job 最多可以执行 6 个小时 每个 Workflow 最多可以执行 72 小时 每个 Workflow 中的 job 最多可以排队 24 小时 在一个存储库的所有 Action 中，一个小时最多可以执行 1000 个 API 请求 并发工作数：Linux：20，Mac：5（专业版可以最多提高到 180 / 50） 什么是 Workflow？ Workflow 是由一个或多个 job 组成的可配置的自动化过程。我们通过创建 YAML 文件来创建 Workflow 配置。\n一、如何定义 Workflow 的名字？ name\nWorkflow 的名称，Github 在存储库的 Action 页面上显示 Workflow 的名称。\n如果我们省略 name，则 Github 会将其设置为相对于存储库根目录的工作流文件路径。\n1 name: Greeting from Mona on: push 二、如何定义 Workflow 的触发器？ on\n触发 Workflow 执行的 event 名称，比如：每当我提交代码到 Github 上的时候，或者是每当我打 TAG 的时候。\n1 // 单个事件 on: push // 多个事件 on: [push,pull_request] 事件大全：https://docs.github.com/en/actions/reference/events-that-trigger-workflows#about-workflow-events\n三、Workflow 的 job 是什么？ 答：一个 Workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。\n1、如何定义一个 job？ 1 jobs: my_first_job: name: My first job my_second_job: name: My second job 答：通过 job 的 id 定义。\n每个 job 必须具有一个 id 与之关联。\n上面的 my_first_job 和 my_second_job 就是 job_id。\n2、如何定义 job 的名称？ jobs.\u0026lt;job_id\u0026gt;.name\nname 会显示在 Github 上\n3、如何定义 job 的依赖？job 是否可以依赖于别的 job 的输出结果？ jobs.\u0026lt;job_id\u0026gt;.needs\n答：needs 可以标识 job 是否依赖于别的 job—— 如果 job 失败，则会跳过所有需要该 job 的 job。\n1 jobs: job1: job2: needs: job1 job3: needs: [job1, job2] jobs.\u0026lt;jobs_id\u0026gt;.outputs：用于和 need 打配合，outputs 输出 =》need 输入\njobs 的输出，用于和 needs 打配合：可以看到 ouput\n1 jobs: job1: runs-on: ubuntu-latest # Map a step output to a job output outputs: output1: ${{ steps.step1.outputs.test }} output2: ${{ steps.step2.outputs.test }} steps: - id: step1 run: echo \u0026#34;::set-output name=test::hello\u0026#34; - id: step2 run: echo \u0026#34;::set-output name=test::world\u0026#34; job2: runs-on: ubuntu-latest needs: job1 steps: - run: echo ${{needs.job1.outputs.output1}} ${{needs.job1.outputs.output2}} 4、如何定义 job 的运行环境？ jobs.\u0026lt;job_id\u0026gt;.runs-on\n指定运行 job 的运行环境，Github 上可用的运行器为：\nwindows-2019 ubuntu-20.04 ubuntu-18.04 ubuntu-16.04 macos-10.15 1 jobs: job1: runs-on: macos-10.15 job2: runs-on: windows-2019 5、如何给 job 定义环境变量？ jobs.\u0026lt;jobs_id\u0026gt;.env\n1 jobs: job1: env: FIRST_NAME: Mona 6、如何使用 job 的条件控制语句？ jobs.\u0026lt;job_id\u0026gt;.if\n我们可以使用 if 条件语句来组织 job 运行\n四、Step 属性是什么？ 答：每个 job 由多个 step 构成，它会从上至下依次执行。\nstep 运行的是什么？ step 可以运行：\ncommands：命令行命令 setup tasks：环境配置命令（比如安装个 Node 环境、安装个 Python 环境） action（in your repository, in public repository, in Docker registry）：一段 action（Action 是什么我们后面再说） 每个 step 都在自己的运行器环境中运行，并且可以访问工作空间和文件系统。\n因为每个 step 都在运行器环境中独立运行，所以 step 之间不会保留对环境变量的更改。\n1 # 定义 Workflow 的名字 name: Greeting from Mona # 定义 Workflow 的触发器 on: push # 定义 Workflow 的 job jobs: # 定义 job 的 id my-job: # 定义 job 的 name name: My Job # 定义 job 的运行环境 runs-on: ubuntu-latest # 定义 job 的运行步骤 steps: # 定义 step 的名称 - name: Print a greeting # 定义 step 的环境变量 env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat # 运行指令：输出环境变量 run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 五、Action 是什么？ 我们可以直接打开下面的 Action 市场来看看：\nAction 其实就是命令，比如 Github 官方给了我们一些默认的命令：\n比如最常用的，check-out 代码到 Workflow 工作区：\n1、我们应该如何使用 Action？ jobs.\u0026lt;job_id\u0026gt;.steps.uses\n比如我们可以 check-out 仓库中最新的代码到 Workflow 的工作区：\n1 steps: - uses: actions/checkout@v2 当然，我们还可以给它添加个名字：\n1 steps: - name: Check out Git repository uses: actions/checkout@v2 再比如说，我们如果是 node 项目，我们可以安装 Node.js 与 NPM：\n1 steps: - uses: actions/checkout@v2 - uses: actions/setup-node@v2-beta with: node-version: \u0026#39;12\u0026#39; 2、上面我们为什么要用：@v2 和 @v2-beta 呢？ 答：首先，正如大家所想，这个 @v2 和 @v2-beta 的意思都是 Action 的版本。\n我们如果不带版本号的话，其实就是默认使用最新版本的了。\n但是 Github 官方强烈要求我们带上版本号 —— 这样子的话，我们就不会出现：写好一个 Workflow，但是由于某个 Action 的作者一更新，我们的 Workflow 就崩了的问题。\n3、上面的 with 参数是什么意思？ 答：有的 Action 可能会需要我们传入一些特定的值：比如上面的 node 版本啊之类的，这些需要我们传入的参数由 with 关键字来引入。\n具体的 Action 需要传入哪些参数，还请去 Github Action Market 中 Action 的页面中查看。\n具体库的使用和参数，我们可以去官方的 Action 市场查看：\n六、我们如何运行命令行命令？ 上文说到，steps 可以运行：action 和 command-line programs。\n我们现在已经知道可以使用 uses 来运行 action 了，那么我们该如何运行 command-line programs 呢？\n答案是：run\nrun 命令在默认状态下会启动一个没有登录的 shell 来作为命令输入器。\n1、如何运行多行命令？ 每个 run 命令都会启动一个新的 shell，所以我们执行多行连续命令的时候需要写在同一个 run 下：\n单行命令 1 - name: Install Dependencies run: npm install 多行命令 1 - name: Clean install dependencies and build run： | npm ci npm run build 2、如何指定 command 运行的位置？ 使用 working-directory 关键字，我们可以指定 command 的运行位置：\n1 - name: Clean temp directory run: rm -rf * working-directory: ./temp 3、如何指定 shell 的类型？（使用 cmd or powershell or python？？） 使用 shell 关键字，来指定特定的 shell：\n1 steps: - name: Display the path run: echo $PATH shell: bash 下面是各个系统支持的 shell 类型：\n七、什么是矩阵？ 答：就是有时候，我们的代码可能编译环境有多个。比如 electron 的程序，我们需要在 macos 上编译 dmg 压缩包，在 windows 上编译 exe 可执行文件。\n这种时候，我们使用矩阵就可以啦～\n比如下面的代码，我们使用了矩阵指定了：2 个操作系统，3 个 node 版本。\n这时候下面这段代码就会执行 6 次 —— 2 x 3 = 6！！！\n1 runs-on: ${{ matrix.os }} strategy: matrix: os: [ubuntu-16.04, ubuntu-18.04] node: [6, 8, 10] steps: - uses: actions/setup-node@v1 with: node-version: ${{ matrix.node }} 下一篇文章：《实战：electron 通过 Github Action 自动打包，并上传到 Github 的 release 中》 敬请期待！！！！！\n2 github 妙用 1.3 建立图片存储仓库 建立 public 仓库\n设置 -\u0026gt; 开发者设置 -\u0026gt; 个人访问令牌-\u0026gt; 生成新令牌-\u0026gt; 设置有效期\n申请的Token只会显示一次，当你第二次在打开该页面时就无法看到该Token了。如果忘记了Token，唯一的办法就是重新生成一个\n注意如果上传的文件和仓库里的文件重名，会上传失败\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //注意: \u0026#34;repo\u0026#34;: \u0026#34;Github用户名/仓库名称\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;之前你申请的Token\u0026#34;, { \u0026#34;picBed\u0026#34;: { \u0026#34;current\u0026#34;: \u0026#34;github\u0026#34;, \u0026#34;github\u0026#34;: { \u0026#34;repo\u0026#34;: \u0026#34;xxx/xxx\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;xxxxxxxxx\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;images/\u0026#34;, \u0026#34;customUrl\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;picgoPlugins\u0026#34;: {} } 工作流 分支管理工作流 特点特点特点 Git Flow 分支类型丰富,规范严格 Github Flow 只有主干分支和开发分支,规则简单 Gitlab Flow 在主干分支和开发分支之上构建环境分支,版本分支,满足不同发布or环境的需要 1. git flow 包含五种类型的分支\nMaster: 主干分支\nDevelop: 开发分支\nFeature: 特性分支\nRelease: 发布分支\nHotfix: 热修复分支\n优点\n如果能按照定义的标准严格执行代码会很清晰,并且很难出现混乱. 缺点\n流程过于复杂,上线的节奏会比较慢. 由于太复杂,研发容易不按照标准执行从而导致代码出现混乱. github flow Github 的工作流,只有一个主干分支,基于 Pull Request 往主干分支中提交代码.\n选择团队合作的方式 ( 两种 )\nowner创建好仓库后, 其他用户通过 Fork的方式来创建自己的仓库, 并在 fork的仓库上进行开发 owner 创建好仓库后, 统一给团队内成员分配权限, 直接在同一个仓库内进行开发 gitlab flow Gitlab推荐的工作流是在GitFlow和 Github Flow上做出优化,既保持了单一主分支的简便,又可以适应不同的开发环境 原则:\nupstream first 上游优先 只有在上游分支采纳的代码才可以进入到下游分支,一般上游分支就是 master 代码合并 Fast-Forward\n不会产生一个merge节点,合并后保持一个线性历史,如果target分支有了更新,则需要通过 rebase操作更新 source branch 后才可以入.\nThree-Way Merge\n三方合并,会产生一个新的 merge节点\n如何选择合适的工作流 选择原则: 没有最好的,只有最合适的\n针对小型团队合作, 推荐使用Github工作流即可\n1.尽量保证少量多次,最好不要一次性提交上千行代码 提交 Pull Request 后最少需要保证有 CR 后再合入 主干分支尽量保持整洁,使用 fast-forward 合入方式,合入前进行rebase 一次混乱的开发流程 昨天看了下分支，好像大家拉的比较乱，\ndev是完成 dao 层以后的， user是 dev 加了用户登录， token 是 dev 加了 token功能 feed是 user 加了 feed 功能， publish是在user上改的 ","date":"2023-07-29T15:17:12Z","permalink":"https://li54426.github.io/p/github%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Github使用指南"},{"content":" content {:toc} 论文技巧Latex使用简介: latex摘要\u0026mdash;-快速入门 中文使用cjkutf8\n使用 % 进行注释 段与段之间要空一行 0 安装 网址 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n推荐miktex + texstudio\n安装推荐:miktix和texstudio\nmiktex console -\u0026gt; 更新 -\u0026gt;选择一个源\n###1. 公式\n####1.1 基本使用\n使用$$表示行内公式 如果需要直接使用不带编号的行间公式，则将公式用命令 \\ [ 和 \\ ] 包裹 使用带编号的公式 使用 \\begin{equation} 和 \\end{equation}\n​ 还可以用 \\tag 命令手动修改公式的编号，或者用 \\notag 命令取消为公式编号 ​ 数学模式有如下特点: 1 2 3 1 空格忽略, 2 不允许有空行, 3 所有字母当作变量处理 ####1.2 数学符号\n省略号 代码 $\\div$ \\div $\\times$ \\times 空格 \\quad 省略号$\\dots$ \\dots 上标 ^{} 下标 _{} 根号$\\sqrt[n]{}$ \\sqrt[n]{} 分数 $\\frac{}{}$ \\frac{}{} 或者 $$ \\parallel 无穷大 $\\infty $ \\infty 求和 $\\sum $ \\sum 求和有上下 \\sum \\limits^{}_{} 不等号 $\\ne $ \\ne 大于等于 $\\ge$ \\ge 小于等于 $\\le $ \\le 约等于 $\\approx $ \\approx 等价 $\\equiv $ \\equiv 范数(双竖杠) $\\Vert $ \\Vert 罗马数字 $$ \\uppercase\\expandafter{\\romannumeral2} 希腊字母 Latex代码 $\\alpha$ \\alpha $\\beta$ \\beta $\\delta$ \\delta $\\Delta$ \\delta $\\Pi$ \\Pi 1.3 公式引用 1 2 3 4 5 6 7 8 \\begin{equation} \\label{key} \\end{equation} %当引用时, 没有括号 例如 6 \\ref{key} %当引用时, 需要括号 例如 6 (\\ref{key}) 1.4 特殊的公式\u0026mdash;-规划 1 2 3 4 5 6 7 8 9 10 11 \\begin{align} % 规划的形式 % 最后一行没有 \\\\ \\min \\quad \u0026amp; 目标函数 \\\\ \\text{s.t.} \\quad \u0026amp; 约束1 \\label {cons1}\\\\ \u0026amp; 约束2 \\label {cons2}\\\\ \u0026amp; 约束3 \\label {cons3}\\\\ \u0026amp; 约束4\t\\label {cons4} \\end{align} 1 2 3 4 5 6 7 8 %分段函数 \\begin{equation} f(x)= \\begin{cases} 0 \u0026amp; \\text{x=0}\\\\ 1 \u0026amp; \\text{x!=0} \\end{cases} \\end{equation} 1.5 多行公式 公式编号在中间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 % 如果要折行的话，习惯上优先在等号之前折行，其次在加号、减号之前，再次在乘号、除号之前。其它位置应当避免折行。 目前最常用的是 align 环境，它将公式用 \u0026amp; 隔为两部分并对齐。分隔符通常放在等号左边 % 用 \\notag 去掉某行的编号 \\begin{equation} \\begin{aligned} a \u0026amp;= b + c \\\\ d \u0026amp;= e + f + g \\\\ h + i \u0026amp;= j + k \\\\ l + m \u0026amp;= n \\end{aligned} \\end{equation} %如果因为加的元素太多, 一行放不开 建议, \\begin{equation} \\begin{aligned} a =\u0026amp; b + c \\\\ + \u0026amp; e + f + g \\\\ + \u0026amp; j + k \\\\ + \u0026amp; n \\end{aligned} \\end{equation} %如果因为加的元素太多, 一行放不开 建议 \\begin{equation} \\begin{aligned} \\text{min} \\quad \u0026amp; b + c \\\\ \\text{s.t.} \\quad \u0026amp; e + f + g \\\\ \u0026amp; j + k \\\\ \u0026amp; n \\end{aligned} \\end{equation} ###2. 图片\n2.1 单个标题 \\includegraphics[⟨options⟩]{⟨fi lename ⟩}， 文件名可能需要用相对路径或绝对路径表示, 图片文件的扩展名一般可不写\n1 2 3 \\include{chapters/file} % 相对路径 \\include{/home/Bob/file} % *nix（包含 Linux、macOS）绝对路径 \\include{D:/file} % Windows 绝对路径，用正斜线 ``` %导包 usepackage{graphics} %导入图片, 当模板为两列, 但是想让图片占据着两列时, 使用\\begin{figure*}[t] %图片 \\begin{figure}[htbp] %居中 \\centering %\\includegraphics[width=2.5in]{Autoencoder1} %占据0.8宽度 \\includegraphics[width=0.40\\textwidth]{time.png} %图片名称 \\caption{Experimental running time} \\label{time} \\end{figure} \\[htbp\\] 为调整图片排版位置选项，说明如下：\n\\[h\\]当前位置。将图形放置在正文文本中给出该图形环境的地方。如果本页所剩的页面不够，这一参数将不起作用。\n\\[t\\]顶部。将图形放置在页面的顶部。\n\\[b\\]底部。将图形放置在页面的底部。\n\\[p\\]浮动页。将图形放置在一只允许有浮动对象的页面上。\n2. 并排插入多张图片并公用一个caption 有时候我们希望同时插入一组图片，共用一个大标题且为每张子图设小标题，效果如下：\n方法：同时引入 \\usepackage{graphicx} 和 \\usepackage{subfigure} 宏包，如下代码实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \\begin{figure}[htbp] \\centering \\subfigure[Fig1]{ \\includegraphics[scale=0.25]{Fig1.png} \\label{1} } \\quad \\subfigure[Fig2]{ \\includegraphics[scale=0.25]{Fig2.png} \\label{2} } \\quad \\subfigure[Fig3]{ \\includegraphics[scale=0.25]{Fig3.png}\\label{3} } \\quad \\subfigure[Fig4]{ \\includegraphics[scale=0.25]{Fig4.png}\\label{4} } \\caption{Experimental results of the authors} \\end{figure} 代码说明：\n\\subfigure\n\\[Fig1\\] 为子图的标题；\n\\caption{Experimental results of the authors} 为总标题。\n3.引用 (参考文献) Bib 参考文献一键复制 设置方法\n谷歌学术-\u0026gt; 设置 -\u0026gt; 选中显示导入 bibtex的链接 3.1 IEEE模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 % IEEE官网的latex模板，无法调用cite包。与下面第一节调用的biblatex包冲突（模板里自带的，开始没注意到，相当于我调用了两个参考文献的包），然后我改成网上一样的biblatex调用声明还是不行，因为新版必须用bibtex编译，且要在[ ]中声明，很多博客用的是biber，并且默认也是biber！即调用biblatex包必须要声明是用bibtex编译！ %导包, 在文章开始之前也就是 \\begin{document} \\usepackage[backend=bibtex,sorting=none]{biblatex} \\addbibresource{ref.bib} %sorting=none表示按照参考文献在论文中出现的先后顺序排序。 hyperref=true和backref=true表示为各个参考文献的引用处、及定理、定义、例子等的引用处都添加上超链接； % 显示参考文献, 在\\end{document}之前 \\printbibliography %引用格式: \\cite{key} 3.2 其他模板 1 2 3 4 5 6 7 8 9 %引用, FCN是我们在bibtex文件中自定义的名字 以一篇古老的分子动力学文章作为参考\\cite{yu2013toward} %如果不想用方括号, 可以使用 \\usepackage[superscript]{cite} %参考文献, 在 \\end{document}之前写 \\bibliographystyle{IEEEtran} \\bibliography{ref.bib} ####3.2引用网址\n1 2 3 4 5 6 7 8 9 10 11 12 %正文前引用 usepackagefurl} %bib文件中加入: @Misc{cite变量名, howpublished = {\\url{网页地址}}, note = {Accessed进入网页的具体日期}, title = {网页名称}, author = {作者} } 1911正文中具体使用为 1\\cite{cite变量名） 4.表格 网址 : tablegenerator.com\n1 2 3 4 5 6 \\begin{tabular}{cc}%一个c表示有一列，格式为居中显示(center) %\\begin{tabular}{|c|c|}通过添加 | 来表示是否需要绘制竖线 (1,1)\u0026amp;(1,2)\\\\%第一行第一列和第二列 中间用\u0026amp;连接 (2,1)\u0026amp;(2,2)\\\\%第二行第一列和第二列 中间用\u0026amp;连接 \\end{tabular} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 %经典三线表格 table的目的就是把表格给图片化 \\begin{table}[] \\centering \\caption{Notations in This Paper} \\begin{tabular}{|c|c|} \\hline 标题1 \u0026amp; 标题2 \\\\ \\hline $P$\t\u0026amp; the provider \\\\ $M_{it}$ \u0026amp; the \\\\ \\hline \\end{tabular} \\end{table} 5 算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 %算法宏包 \\usepackage[linesnumbered,ruled,vlined]{algorithm2e} \\usepackage{setspace} \\begin{algorithm}[t] %设置算法编号 %\\renewcommand{\\thealgocf}{3-1} \\SetAlgoLined %显示end \\caption{Genetic Algorithm}%算法名字 \\label{} \\KwIn{input parameters $T, $}%输入参数 \\KwOut{$ $}%输出 % \u0026#39;\\;\u0026#39; 用于换行 some description\\; \\For{condition}{ \\If{condition}{ 1\\; } } return \\end{algorithm} 6 字体大小 1 2 3 4 5 6 %学院名称太长, 导致作者变成了两行, 可以把学院名称的字体调小 \\tiny Hello Latex. \\scriptsize Hello Latex. \\footnotesize Hello Latex. \\small Hello Latex. \\normalsize Hello Latex. ","date":"2023-07-29T14:26:19Z","permalink":"https://li54426.github.io/p/latex%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"latex使用指南"},{"content":" content {:toc} 1 allocator( 配置器 ) 1.1 代码分布 \u0026lt;stl_construct.h\u0026gt; 定义了全局函数construct()和destroy()，负责对象的构造和析构。 \u0026lt;stl_alloc.h\u0026gt; 定义了一二级配置器，配置器统称为alloc而非allocator！ \u0026lt;stl_uninitialized.h\u0026gt; 定义了一些全局函数，用来填充(fill)或者复制(copy)大块内存数据，也隶属于STL标准规范。 G 2.9 使用的是 alloc, 在G4.9中，分配器变成了new_allocator，旧的分配器alloc改名为_pool_alloc。STL标准告诉我们, 分配器在****中,\n考虑到小型区块所可能造成的内存破碎问题,SGI设计了双层级配置器,\n第一级配置器直接使用malloc()和free(), SGI第一级配置器的 allocate()和realloc都是在调用malloc和realloc()；不成功后，改调用oom_malloc()和oom_realloc();后两者都有内循环不断调用客户端注册的\u0026quot;__malloc_alloc_oom_handler “，以期望在某次调用之后获得足够的内存而圆满完成任务，但是如果没有注册”__malloc_alloc_oom_handler \u0026ldquo;，那么oom_malloc()和oom_realloc()便直接丢出bad_alloc异常信息或者exit(1)硬生生终止程序。\n第二级配置器则视情况采用不同的策略:当配置区块超过128 bytes时, 视之为\u0026quot;足够大\u0026rdquo;,便调用第一级配置器;当配置区块小于128 bytes时,视之为\u0026quot;过小\u0026quot;,为了降低额外负担, 便采用复杂的memory pool整理方式,而不再求助于第一级配置器 .\n所谓C++ new handler 机制是，你可以要求系统在内存配置需求无法被满足时，调用一个你所指定的函数。换句话说，-旦：：operator new无法完成任务，在丢出std:：bad_alloc异常状态之前，会先调用由客端指定的处理例程，该处理例\n整个 STL 的操作对象 都放在容器之内, 容器一定需要空间以配置资料 STL规则告诉我们配置器定义与\u0026lt;memory\u0026gt;中, 1 2 3 //----------memory.h---------- #include \u0026lt;stl_alloc.h\u0026gt; #include \u0026lt;stl_construct.h\u0026gt; 1.2 defalloc.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 文件目录 defalloc.h //仅仅是对 malloc 的包装 template \u0026lt;class T\u0026gt; class allocator { public: pointer allocate(size_type n) { return ::allocate((difference_type)n, (pointer)0);//函数2 } void deallocate(pointer p) { ::deallocate(p); } pointer address(reference x) { return (pointer)\u0026amp;x; } const_pointer const_address(const_reference x) { return (const_pointer)\u0026amp;x; } size_type init_page_size() { return max(size_type(1), size_type(4096/sizeof(T))); } size_type max_size() const { return max(size_type(1), size_type(UINT_MAX/sizeof(T))); } }; //函数2 template \u0026lt;class T\u0026gt; inline T* allocate(ptrdiff_t size, T*) { set_new_handler(0); T* tmp = (T*)(::operator new((size_t)(size * sizeof(T)))); if (tmp == 0) { cerr \u0026lt;\u0026lt; \u0026#34;out of memory\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } return tmp; } 1.3 stl_alloc.h __malloc_alloc_template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 // stl_alloc.h __malloc_alloc_template // 第一级配置器 // 该泛型类没有类型参数； //“__inst”是一个写死的int类型，但无实际意义 template \u0026lt;int __inst\u0026gt; class __malloc_alloc_template { private: //以下两个函数是，malloc 申请失败后（内存不足时）的处理方法 //用来申请空间，参数是申请的大小 static void* _S_oom_malloc(size_t); //用来扩增一个旧的内存空间 //参数1，是旧的空间地址；参数2，是重新申请的大小 static void* _S_oom_realloc(void*, size_t); #ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG //这是一个函数指针（指向函数的指针） static void (* __malloc_alloc_oom_handler)(); #endif public: static void* allocate(size_t __n) { // 调用 malloc() void* __result = malloc(__n); // 如果申请失败，改用 _S_oom_malloc() if (0 == __result) __result = _S_oom_malloc(__n); return __result; } //释放空间，参数1，地址指针；参数2，大小 //（很显然这里的第二参数没有意义） // 调用 free()释放空间 static void deallocate(void* __p, size_t /* __n */) { free(__p); //(为何__n 没有意义，c语言得知，free释放空间，是全部释放，不存在只释放一部分的情况) } //对一段旧空间扩容 static void* reallocate(void* __p, size_t /* old_sz */, size_t __new_sz) { void* __result = realloc(__p, __new_sz); // 如果申请失败，改用 _S_oom_malloc() if (0 == __result) __result = _S_oom_realloc(__p, __new_sz); return __result; } //动态指定，针对内存不足时的处理方法（注意书写格式） static void (* __set_malloc_handler(void (*__f)()))() { void (* __old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = __f; return(__old); } }; // malloc_alloc 针对内存不足时的处理方法 #ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG // 默认为0 template \u0026lt;int __inst\u0026gt; void (* __malloc_alloc_template\u0026lt;__inst\u0026gt;::__malloc_alloc_oom_handler)() = 0; #endif template \u0026lt;int __inst\u0026gt; void* __malloc_alloc_template\u0026lt;__inst\u0026gt;::_S_oom_malloc(size_t __n) { void (* __my_malloc_handler)(); //声明一个处理内存不足的函数指针； void* __result; // 一直申请直到失败或成功 for (;;) { __my_malloc_handler = __malloc_alloc_oom_handler; //当 \u0026#34;内存不足处理方法\u0026#34; 并未被设置，便调用 __THROW_BAD_ALLOC，抛出异常信息 if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; } // 调用内存不足时的处理函数 (*__my_malloc_handler)(); __result = malloc(__n); // 再次尝试申请内存 if (__result) return(__result); } } // 给一个已经分配了地址的指针重新分配空间 template \u0026lt;int __inst\u0026gt; void* __malloc_alloc_template\u0026lt;__inst\u0026gt;::_S_oom_realloc(void* __p, size_t __n) { void (* __my_malloc_handler)(); void* __result; for (;;) { __my_malloc_handler = __malloc_alloc_oom_handler; if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; } (*__my_malloc_handler)(); __result = realloc(__p, __n); if (__result) return(__result); } } 1.4 stl_alloc.h __default_alloc_template 两级结构, 第一级是 链表( free list ) 第二级是内存池 内存池不够的话, 继续 malloc\n其实 free list 可以和内存池相互转换,\n当 free list 某个大小的结点不足时, 可以调用内存池中的内存\n当内存池空的时候, 可以从free list中 调用 内存\n1 2 3 4 5 6 7 if(链表够): 从链表中取 else: if(内存池够): 从内存池中取(static refill(size_t __n)函数) refill调用 static _chunk_alloc(ize_t __size, int \u0026amp;__nobjs)函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // stl_alloc.h __default_alloc_template template \u0026lt;bool threads, int inst\u0026gt; class __default_alloc_template { private: static const int _ALIGN = 8; // 调整到 8字节 static const int _MAX_BYTES = 128; // 最大字节数 static const int _NFREELISTS = 16; // free lists 数目 _MAX_BYTES/_ALIGN static size_t _S_round_up(size_t __bytes){// 调整到 8字节 return (((__bytes) + (size_t) _ALIGN-1) \u0026amp; ~((size_t) _ALIGN - 1)); } union _Obj{ union _Obj* _M_free_list_link; char _M_client_data[1]; };//感觉定义一个结构体, 元素只有一个 指向 自己的 地址也可以 // 静态变量 static _Obj* volatile _S_free_list[]; // 确定应在哪个 list static size_t _S_freelist_index(size_t __bytes){ return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1); } static void* _S_refill(size_t __n); static char* _S_chunk_alloc(size_t __size, int \u0026amp;__nobjs); // Chunk allocation state, chunk_alloc 里使用 static char* _S_start_free; // 内存池起始地址 static char* _S_end_free; // 内存池结束地址 static size_t _S_heap_size; // 内存池大小 public: //-------接口---------- static void *allocate(size_t __n){ void *__ret = 0; if (__n \u0026gt; (size_t) _MAX_BYTES){ __ret = malloc_alloc::allocate(__n); } else{ //volatile 告诉编译器 不进行优化 _Obj* volatile* __my_free_list = _S_free_list + _S_freelist_index(__n); _Obj* __result = *__my_free_list; if (__result == 0) __ret = _S_refill(_S_round_up(__n)); //重填链表 else{ //和链表一样, 指向下一个结点 *__my_free_list = __result -\u0026gt; _M_free_list_link; __ret = __result; } } return __ret; }; static void deallocate(void* __p, size_t __n){ // 小于128的存储块, 要将他返回到那个链表中 if (__n \u0026gt; (size_t) _MAX_BYTES) malloc_alloc::deallocate(__p, __n); else { _Obj* volatile* __my_free_list = _S_free_list + _S_freelist_index(__n); _Obj* __q = (_Obj*)__p; __q -\u0026gt; _M_free_list_link = *__my_free_list; *__my_free_list = __q; } } static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz){ void *__result; size_t __copy_sz; if (__old_sz \u0026gt; (size_t) _MAX_BYTES \u0026amp;\u0026amp; __new_sz \u0026gt; (size_t) _MAX_BYTES){ //原来的大小比128大 return(realloc(__p, __new_sz)); } if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p); __result = allocate(__new_sz); __copy_sz = __new_sz \u0026gt; __old_sz? __old_sz : __new_sz; memcpy(__result, __p, __copy_sz); deallocate(__p, __old_sz); return(__result); } }; template \u0026lt;bool __threads, int __inst\u0026gt; char* __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_S_start_free = 0; template \u0026lt;bool __threads, int __inst\u0026gt; char* __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_S_end_free = 0; template \u0026lt;bool __threads, int __inst\u0026gt; size_t __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_S_heap_size = 0; template \u0026lt;bool __threads, int __inst\u0026gt; typename __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_Obj* volatile __default_alloc_template\u0026lt;__threads, __inst\u0026gt; ::_S_free_list[ __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_NFREELISTS ] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 // 返回一个大小为 n 的对象(假定 n 已经适当上调至 8 的倍数), // 因为free list中没有了节点, 所以尝试为对应的 free list 增加节点数目 // 默认取得20个新节点, 但如果内存池空间不足,获得的节点数可能小于20, 其中一个节点返回给调用者, 剩下的节点添入对应 free list template \u0026lt;bool __threads, int __inst\u0026gt; void *__default_alloc_template\u0026lt;__threads, __inst\u0026gt;:: _S_refill(size_t __n){ //重填链表, 默认重新要20个节点 int __nobjs = 20; // 注意参数 nobjs 是引用类型 char* __chunk = _S_chunk_alloc(__n, __nobjs); _Obj* volatile* __my_free_list; _Obj* __result; _Obj* __current_obj; _Obj* __next_obj; // 仅获得一个区块, 分配给调用者用, free list 无新节点 if (1 == __nobjs) return(__chunk); // 将多余区块纳入 free list __my_free_list = _S_free_list + _S_freelist_index(__n); __result = (_Obj*)__chunk; *__my_free_list = __next_obj = (_Obj*)(__chunk + __n); // 因为原始的内存里面的内容都是空的, 或者没有意义的, 需要将各节点串联起来, 第0个区块将返回给调用者 for (int __i = 1; __i \u0026lt; __nobjs - 1; __i++){ __current_obj = __next_obj; __next_obj = (_Obj*)((char*)__next_obj + __n); __current_obj -\u0026gt; _M_free_list_link = __next_obj; } __next_obj -\u0026gt; _M_free_list_link = 0; return(__result); } // 被 refill() 调用, 从内存池中取空间给 free list 使用 // 个人感觉没有必要, 毕竟这一个函数也只有 refill 调用(错误) // 为了递归调用自己(从freelist中找到了能用的 块 ) // 分配 nobjs 个大小为 size 的区块, template \u0026lt;bool __threads, int __inst\u0026gt; char *__default_alloc_template\u0026lt;__threads, __inst\u0026gt;:: _S_chunk_alloc(size_t __size, int \u0026amp;__nobjs){ char *__result; size_t __total_bytes = __size * __nobjs; size_t __bytes_left = _S_end_free - _S_start_free; // 内存池剩余空间 if (__bytes_left \u0026gt;= __total_bytes){ // 内存池剩余空间完全满足需求量 __result = _S_start_free; _S_start_free += __total_bytes; return(__result); } else if (__bytes_left \u0026gt;= __size){ // 内存池剩余空间不能完全满足需求量, 但能够供应至少一个区块 __nobjs = (int)(__bytes_left/__size); __total_bytes = __size * __nobjs; __result = _S_start_free; _S_start_free += __total_bytes; return(__result); } else{ // 内存池剩余空间连一个区块的大小能不能提供 // 利用 malloc() 从 heap 中配置内存, 大小为需求量的两倍, 再加上一个随着配置次数增加而越来越大的附加量 size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size \u0026gt;\u0026gt; 4); // 因为要创建新的内存池了, 所以 将 旧的 内存池中剩余的残余空间分配到适当的 free list 中 if (__bytes_left \u0026gt; 0){ _Obj* volatile* __my_free_list = _S_free_list + _S_freelist_index(__bytes_left); ((_Obj*)_S_start_free) -\u0026gt; _M_free_list_link = *__my_free_list; *__my_free_list = (_Obj*)_S_start_free; } // 尝试从 heap 中配置内存 _S_start_free = (char*)malloc(__bytes_to_get); if (0 == _S_start_free){ // heap 空间不足, malloc() 失败, 无法获得内存 size_t __i; _Obj* volatile* __my_free_list; _Obj* __p; // 从free list 找, 因为可能有些块比你需要的块 大 可以把他切割掉 for (__i = __size; __i \u0026lt;= (size_t)_MAX_BYTES; __i += (size_t)_ALIGN){ __my_free_list = _S_free_list + _S_freelist_index(__i); __p = *__my_free_list; if (0 != __p){ *__my_free_list = __p -\u0026gt; _M_free_list_link; _S_start_free = (char*)__p; _S_end_free = _S_start_free + __i; // 现在至少能提供一个区块了, 递归调用自己以修正 nobjs return(_S_chunk_alloc(__size, __nobjs)); } } // 连 free list 里也没有可用内存了 _S_end_free = 0; // 调用一级配置器看能不能有点用 // 一级配置器有 out-of-memory 处理机制, 或许有机会改善现在的情况, 如果无法改善, 抛出bad_alloc异常 _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get); } _S_heap_size += __bytes_to_get; _S_end_free = _S_start_free + __bytes_to_get; return(_S_chunk_alloc(__size, __nobjs)); } } ","date":"2023-07-25T21:19:24Z","permalink":"https://li54426.github.io/p/cpp_stl_1_alloctor/","title":"cpp_STL_1_alloctor"},{"content":" content {:toc} 类内成员 1.1 类内的静态变量 static 优点:\nstatic的名字在类的作用域内, 是类的一部分, 而不是对象的一部分 static成员可以是私有成员 所有对象共享同一份数据 类内声明，类外初始化 在编译阶段分配内存 1.2 静态成员函数 在类中声明函数的前面加static就成了静态成员函数, 可以通过对象来访问, 也可以通过类名来访问 所有对象共享同一个函数 静态成员函数只能访问静态成员变量, 静态成员函数没有this指针，既然它没有指向某一对象，就无法对一个对象中的非静态成员进行默认访问 泛整型可以类内直接初始化，包括bool short int long等，其余类型包括float，double及string等都不可以。\n1 2 3 4 5 class A{ public: static int staint; }; int A::staint = 0; 1.3 操作符 重载 作用 : 对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n一般的重载运算符\n加号运算符重载 左移运算符重载 :: 可以输出自定义数据类型 递增运算符重载 赋值运算符重载 关系运算符重载 函数调用运算符重载 Note: :: .* . ?= 不能重载\n3 模板 3.1 模板简介 ​\t泛型编程就是以独立于任何特定类型的方式编写代码, 使用泛型程序时， 需要提供具体程序实例所操作的类型或值. ​\t泛型程序设计背后有一种隐含的共性：模板机制 ​\twhy: 除了类型之外， 其余代码看起来是相同的。\n包括:\n函数模板 类模板 3.2 函数模板 函数模板提供了一种函数行为，该函数行为可以用多重不同类型进行调用。也就是说，函数模板代表一个函数家族。\n1 2 3 4 5 6 7 8 9 10 11 12 //尖括号内的是 一个或者多个模板形参 //模板形参定义了特定类型的局部变量但是不初始化， 只有当运行时才初始化. template\u0026lt;typename T\u0026gt; int compare(const T \u0026amp;a, const T \u0026amp;b){ if(a \u0026lt;b) return -1; else if(a \u0026gt;b) return 1; else return 0; } //使用函数模板时, 编译器会自己推断哪个或者哪些模板实参绑定到形参 //一旦编译器确定了实际的模板实参， 就是, 实例化了函数模板的一个实例 cout\u0026lt;\u0026lt; compare(1, 0); 3.3 类模板 类模板与函数模板区别主要有两点：\n类模板没有自动类型推导的使用方式\n类模板在模板参数列表中可以有默认参数\n类模板中成员函数和普通类中成员函数创建时机是有区别的：\n普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建 3.4 类模板的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;class NameType, class AgeType = int\u0026gt; class Person{}; void test01(){ // 错误 类模板使用时候，不可以用自动类型推导 // Person p(\u0026#34;孙悟空\u0026#34;, 1000); //必须使用显示指定类型的方式，使用类模板 Person \u0026lt;string ,int\u0026gt;p(\u0026#34;孙悟空\u0026#34;, 1000); } void test02(){ //类模板中的模板参数列表 可以指定默认参数 Person \u0026lt;string\u0026gt; p(\u0026#34;猪八戒\u0026#34;, 999); } 3.5 类模板 做 函数参数 一共有三种传入方式：\n指定传入的类型 \u0026mdash; 直接显示对象的数据类型**( 最常用 )** 参数模板化 \u0026mdash; 将对象中的参数变为模板进行传递 整个类模板化 \u0026mdash; 将这个对象类型 模板化进行传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 template\u0026lt;class NameType, class AgeType = int\u0026gt; class Person{}; //1、指定传入的类型 void printPerson1(Person\u0026lt;string, int\u0026gt; \u0026amp;p){ p.showPerson(); } void test01(){ Person \u0026lt;string, int \u0026gt;p(\u0026#34;孙悟空\u0026#34;, 100); printPerson1(p); } //2、参数模板化 template \u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt;\u0026amp;p){ p.showPerson(); cout \u0026lt;\u0026lt; \u0026#34;T1的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T2的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; } void test02(){ Person \u0026lt;string, int \u0026gt;p(\u0026#34;猪八戒\u0026#34;, 90); printPerson2(p); } //3、整个类模板化 template\u0026lt;class T\u0026gt; void printPerson3(T \u0026amp; p){ cout \u0026lt;\u0026lt; \u0026#34;T的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl; p.showPerson(); } void test03(){ Person \u0026lt;string, int \u0026gt;p(\u0026#34;唐僧\u0026#34;, 30); printPerson3(p); } int main() { test01(); test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 3.6 类内的 模板对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;class T\u0026gt; class stack{ private: vector \u0026lt;T\u0026gt; elem(n); public: void pop(); void push(T); }; //可以有非模板类型参数, 非模板类型参数是有限制的, 可以是长整数, 或者指向外部链接对象的指针 template\u0026lt;class T, int max\u0026gt; stack{}; //在定义函数时, 模板定义了几个形参就要带着几个形参 template\u0026lt;class T, int max\u0026gt; stack :: pop(){ } 3.7 特化 有时候我们可能需要为某些特定类型或特定情况提供特殊的实现方式。这就是模板的特化的作用。 偏特化与完全特化类似，但存在一定的区别。完全特化是对模板的所有类型参数都进行具体化，而偏特化则只对其中的部分类型参数进行特化。所以偏特化以后, 依旧是 模板 偏特化的定义: 提供另一份 template 的定义式, 本是一就是templatized\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 泛化, 特化 template \u0026lt;class T, class Allocalloc\u0026gt; class vector { }; // 个数的偏特化 - 原来是两个模板参数, 现在是一个 // 针对某个类型做特别的优化 template\u0026lt;class Alloc\u0026gt; class vector\u0026lt;bool, Alloc\u0026gt; { }; //范围的偏特化 -指针类型 template\u0026lt;class T\u0026gt; class demo{}; template\u0026lt;class T\u0026gt; class demo\u0026lt;T*\u0026gt;{ }; ","date":"2023-07-25T21:19:24Z","permalink":"https://li54426.github.io/p/cpp_stl_o_basic/","title":"cpp_STL_O_basic"},{"content":" content {:toc} 天若 OCR调用 simpletex API\n记录一次使用别人的接口\n1 什么是天若 OCR 图片转文字准确率超高的办公利器 可以截图 可以翻译 可以识别公式 2 作者暴露出的部分接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //image：要识别的图片 public static string OCR_Custom(Image image) { //string url = \u0026#34;\u0026#34;; //string poststr =\u0026#34;\u0026#34;; //string result =CustomHelp.HttpPost(url,poststr); //获取请求获取解析结果后按照下面格式进行解析 TxtFormat.Root jsonRoot=new TxtFormat.Root(); jsonRoot.result=new List\u0026lt;TxtFormat.TextBlock\u0026gt;(); jsonRoot.isHasLocation=true;//判断是否含有坐标返回 for(int i=0; i\u0026lt;5; i++)//遍历返回的json字符串 { TxtFormat.TextBlock textBlock = new TxtFormat.TextBlock(); textBlock.Text = \u0026#34;公式测试文本\u0026#34;+i.ToString();//json内的文本 textBlock.TopLeft = new Point(0,0);//左上角坐标 textBlock.TopRight = new Point(0,0);//右上角坐标 textBlock.BottomRight =new Point(0,0);//右下角坐标 textBlock.BottomLeft =new Point(0,0);//左下角坐标 jsonRoot.result.Add(textBlock); } string json = JsonConvert.SerializeObject(jsonRoot); return json; } 一开始认为 CustomHelp.HttpPost()是一个具体的类, 但是也没有一个demo来说明各个参数的意义, 因此认为是伪码, 所以认为下面的也全是伪代码, 让我付出了惨重的代价 实际上就应该是一个具体的类, 因为后文的TxtFormat等也是具体的类, 但是没有使用说明, 就只能使用 HttpWebResponse库交换 http报文 3 天若开源版本的代码 猜测typeset_txt 就是显示的内容, 也是 接口中返回的原始字符串对应起来 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var img = image_screen; var inArray = OcrHelper.ImgToBytes(img); var s = \u0026#34;{\\t\\\u0026#34;formats\\\u0026#34;: [\\\u0026#34;latex_styled\\\u0026#34;, \\\u0026#34;text\\\u0026#34;],\\t\\\u0026#34;metadata\\\u0026#34;: {\\t\\t\\\u0026#34;count\\\u0026#34;: 0,\\t\\t\\\u0026#34;platform\\\u0026#34;: \\\u0026#34;windows 10\\\u0026#34;,\\t\\t\\\u0026#34;skip_recrop\\\u0026#34;: true,\\t\\t\\\u0026#34;user_id\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\t\\t\\\u0026#34;version\\\u0026#34;: \\\u0026#34;snip.windows@01.02.0027\\\u0026#34;\\t},\\t\\\u0026#34;ocr\\\u0026#34;: [\\\u0026#34;text\\\u0026#34;, \\\u0026#34;math\\\u0026#34;],\\t\\\u0026#34;src\\\u0026#34;: \\\u0026#34;data:image/jpeg;base64,\u0026#34; + Convert.ToBase64String(inArray) + \u0026#34;\\\u0026#34;}\u0026#34;; var bytes = Encoding.UTF8.GetBytes(s); var httpWebRequest = (HttpWebRequest)WebRequest.Create(\u0026#34;https://api.mathpix.com/v3/latex\u0026#34;); httpWebRequest.Method = \u0026#34;POST\u0026#34;; httpWebRequest.ContentType = \u0026#34;application/json\u0026#34;; httpWebRequest.Timeout = 8000; httpWebRequest.ReadWriteTimeout = 5000; httpWebRequest.Headers.Add(\u0026#34;app_id: mathpix_chrome\u0026#34;); httpWebRequest.Headers.Add(\u0026#34;app_key: 85948264c5d443573286752fbe8df361\u0026#34;); using (var requestStream = httpWebRequest.GetRequestStream()) { requestStream.Write(bytes, 0, bytes.Length); } var responseStream = ((HttpWebResponse)httpWebRequest.GetResponse()).GetResponseStream(); var value = new StreamReader(responseStream, Encoding.GetEncoding(\u0026#34;utf-8\u0026#34;)).ReadToEnd(); responseStream.Close(); var text = \u0026#34;$\u0026#34; + ((JObject)JsonConvert.DeserializeObject(value))[\u0026#34;latex_styled\u0026#34;] + \u0026#34;$\u0026#34;; split_txt = text; typeset_txt = text; 4 simpletex API 的python调用 使用 post 方法 1 2 3 4 5 6 7 8 import requests api_url=\u0026#34;https://server.simpletex.cn/api/latex_ocr/v2\u0026#34; # 接口地址 data = { } # 请求数据 header={ \u0026#34;token\u0026#34;: \u0026#34;\u0026#34; } # 鉴权信息，此处使用UAT方式 file=[(\u0026#34;file\u0026#34;,(\u0026#34;test.png\u0026#34;,open(\u0026#34;test.png\u0026#34;, \u0026#39;rb\u0026#39;)))] # 请求文件,字段名一般为file res = requests.post(api_url, files=file, data=data, headers=header) # 使用requests库上传文件 print(res.status_code) print(res.text) 1 2 3 4 5 6 7 { \u0026#34;status\u0026#34;: true/false, // 是否成功调用接口 \u0026#34;res\u0026#34;: { // 调用结果 ... }, \u0026#34;request_id\u0026#34;: \u0026#34;tr_xxxxxxxxxx\u0026#34; // 请求ID } 5 如何输出错误 发现 MessageBox.Show()能输出信息, 就用它来调试 1 MessageBox.Show(responseContent.ToString() ); 6 协议 post 的数据格式 边界符: boundary=AaB03x Post 中定义的换行符是 \\r\\n, 每一个边界符前面都需要加 2 个连字符 “\u0026ndash;”，然后跟上换行符。 使用Content-Type 指定发送或接收实体正文的媒体类型 Content-Type 由两部分组成，用斜杠分隔：媒体类型（media type）和子类型（subtype）。常见的媒体类型包括： text/plain：纯文本类型。 text/html：HTML 文档类型。 application/json：JSON 数据类型。 application/xml：XML 数据类型。 application/octet-stream : 二进制数据. image/jpeg：JPEG 图片类型。 audio/mpeg：MPEG 音频类型。 video/mp4：MP4 视频类型。 Content-Disposition：该头部字段用于指示如何处理包含在消息体中的数据。它可以指定将数据显示在浏览器窗口中、作为附件下载、保存到磁盘等行为。常见的值包括： inline：默认值，将数据在浏览器中显示。 attachment：将数据作为附件下载。 filename=\u0026lt;文件名\u0026gt;：指定下载时的文件名。 Content-Disposition: form-data; name=\u0026ldquo;file\u0026rdquo;; filename=\u0026ldquo;file1.dat\u0026rdquo;, 通常是用在客户端向服务端传送大文件数据，如：图片或者文件 使用 boundary来分隔文件 数据结束后的分界符，注意因为这个后面没有数据了所以需要在后面追加一个 “\u0026ndash;” 表示结束。 1 2 3 4 5 6 7 8 9 10 11 12 13 // 来自 https://blog.csdn.net/flymorn/article/details/6769722 Content-Type: multipart/form-data; boundary=AaB03x --AaB03x Content-Disposition: form-data; name=\u0026#34;submit-name\u0026#34; Larry --AaB03x Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;file1.dat\u0026#34; Content-Type: application/octet-stream ... contents of file1.dat ... --AaB03x-- 7 完整代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public static string OCR_Custom(Image image) {// Image 是一个类，它是用于处理图像和图形的基本类之一。 byte[] result; using (var memoryStream = new MemoryStream()) { image.Save(memoryStream, ImageFormat.Png); result = memoryStream.ToArray(); } // request string url = \u0026#34;https://server.simpletex.cn/api/latex_ocr/v2\u0026#34;; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url); request.ContentType = \u0026#34;multipart/form-data;boundary=---------------------------boundary\u0026#34;; request.Method = \u0026#34;POST\u0026#34;; request.Headers[\u0026#34;token\u0026#34;] = \u0026#34;\u0026#34;; string boundary = \u0026#34;---------------------------boundary\u0026#34;; byte[] boundaryBytes = Encoding.UTF8.GetBytes(\u0026#34;\\r\\n--\u0026#34; + boundary + \u0026#34;\\r\\n\u0026#34;); string formDataTemplate = \u0026#34;--{0}\\r\\nContent-Type:application/octet-stream\\r\\nContent-Disposition: form-data; name=\\\u0026#34;file\\\u0026#34;; filename=\\\u0026#34;image.png\\\u0026#34;\\r\\nContent-Type: image/png\\r\\n\\r\\n\u0026#34;; string formData = string.Format(formDataTemplate, boundary); byte[] formDataBytes = Encoding.UTF8.GetBytes(formData); // 设置请求体长度 request.ContentLength = formDataBytes.Length + result.Length + boundaryBytes.Length; // 将请求体数据写入请求流中 using (Stream requestStream = request.GetRequestStream()) { requestStream.Write(formDataBytes, 0, formDataBytes.Length); requestStream.Write(result, 0, result.Length); requestStream.Write(boundaryBytes, 0, boundaryBytes.Length); } // 发送请求并获取响应 HttpWebResponse response = (HttpWebResponse)request.GetResponse(); // 处理响应 string responseContent; using (StreamReader reader = new StreamReader(response.GetResponseStream())) { responseContent = reader.ReadToEnd(); // Console.WriteLine(responseContent); } response.Close(); var resultData = ((JObject)JsonConvert.DeserializeObject(responseContent)); var data = resultData[\u0026#34;res\u0026#34;]; var region = data[\u0026#34;latex\u0026#34;]; var text = \u0026#34;$\u0026#34; +region.ToString() + \u0026#34;$\u0026#34;; TxtFormat.Root jsonRoot=new TxtFormat.Root (); jsonRoot.result=new List\u0026lt;TxtFormat.TextBlock\u0026gt;(); jsonRoot.isHasLocation=true;// 判断是否含有坐标返回 TxtFormat.TextBlock textBlock = new TxtFormat.TextBlock (); textBlock.Text = text;//json 内的文本 textBlock.TopLeft = new Point (0,0);// 左上角坐标 textBlock.TopRight = new Point (0,0);// 右上角坐标 textBlock.BottomRight =new Point (0,0);// 右下角坐标 textBlock.BottomLeft =new Point (0,0);// 左下角坐标 jsonRoot.result.Add (textBlock); // `SerializeObject(object value)`：将对象序列化为 **JSON 字符串**。 return JsonConvert.SerializeObject (jsonRoot); } 记录一下用的接口 服务 免费额度 超出免费额度 并发请求数 百度通用文字识别 每月1000次（实名认证后） 0.0050元/次（开通付费后） 通用文字识别（高精度版） 每月1000次（实名认证后） 0.028元/次（开通付费后） 彩云小译API(在用) 每月100万字符 20元/100万字符 无相关说明 百度通用翻译API（标准版） 完全免费 1次/秒 百度通用翻译API（高级版） 每月200万字符 49元/100万字符 10次/秒 百度教育场景文字识别 每月500次（有效期365天, 后续资源付费） 1500元/万次（开通付费后） 腾讯数学试题识别()已经废弃 每月1000次 120元/1000次 ","date":"2023-07-25T21:19:24Z","permalink":"https://li54426.github.io/p/%E5%A4%A9%E8%8B%A5ocr%E8%B0%83%E7%94%A8simpletex/","title":"天若ocr调用simpletex"},{"content":" content {:toc} 一 简介 1 什么是markdown ​\tMarkdown是一种轻量级标记语言，创始人为约翰-格鲁伯（John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 ​\t由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub，Reddit，Diaspora，Stack Exchange，OpenStreetMap，SourceForge、简书等，甚至还能被使用来撰写电子书。\n\u0026mdash;\u0026mdash;-来自百度百科\n2 为什么我们需要markdown 在我们需要进行记笔记时, 我们对于格式( 例如, 字号, 段间距)并没有太大的要求, 反而对结构有要求, 例如标题是什么, 这个标题下有几个小标题, 对于我们的要求来讲, word 显得过于臃肿, markdown 是 latex 和 word 的一个 trade-off 因为他的轻量化, 导致他的格式固定, 使用不同的平台不会出现 word 那样不兼容的问题 因为是近几年才出现的( 04年 ), 能够更贴近这个时代, 例如md文件本身不保存图片, 这就可以使用网络上的图床, 让专业的人干专业的事 3 markdown 工具( 软件 ) Typora( 强推 )Typora 官方中文站、MacDown\n4 markdown 插件 1 2 markdown here [Markdown Here](https://markdown-here.com/) markdownload [markdownload](https://microsoftedge.microsoft.com/addons/detail/hajanaajapkhaabfcofdjgjnlgkdkknm) 二 markdown 语法 1 标题 \u0026lsquo;#\u0026rsquo; 号\u0026mdash;-生成文章的结构 后面需要一个空格 一个是一级标题, 两个是二级标题, 依次类推, 越少代表优先级越高, 被用来生成文章的结构, 我经常用###代表目录, ####代表子目录 1 2 3 ### 第一章 #### 第一章第一节 #### 第一章第二节 2 无序列表 1 使用- (注意后面有空格) 3 网址 1 2 3 [显示内容](网址) 例如上文的 [Typora 官方中文站](https://typoraio.cn/) 4 图片 1 2 3 4 5 6 7 ![图片名称]() ![image-20220906145334336](https://i0.hdslb.com/bfs/album/2f4f352c599fdd8c59177cd0aabd91db8c7dad15.png) # 图片 base 64 ![csdn图片Base64][csdn] [csdn]:data:image/png;base64,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 5 代码 使用```(数字1前面的那个)\n6 引用 1 \u0026gt; (小于号) 三 markdown 与浏览器交互 3.1 markdown here\u0026mdash;\u0026mdash;将markdown上传为 html 格式 下载地址：Markdown Here微软商店下载地址\n使用方法 : 点击插件图标或者是, alt + ctrl + M (动画在下面)\nGIF 2022-9-11 20-27-10 设置格式 : 右键浏览器插件图标 -\u0026gt; 扩展选项-\u0026gt; 基本渲染CSS\n还可以使用 latex公式使用$$包裹起来\n3.2 将网页下载为markdown 下载地址：markdownload_微软商店下载 使用方法: 点击图标 -\u0026gt; Download\n四 图床 有了图床的 markdown 才是完整的markdown\n1 介绍 图床（Image Hosting Service）是一种用于存储和分享图片的在线服务。它允许用户上传图片文件，并生成一个可访问的 URL 地址，用户可以通过该地址在网页上或其他平台上分享图片。图床通常提供免费和付费两种服务，用户可以根据需要选择合适的方案使用。\n图床的主要功能包括：\n图片存储：用户可以将图片文件上传到图床服务器上进行存储，这些图片文件可以是网页中的配图、产品图片、个人照片等。 图片分享：图床为用户生成的图片 URL 地址可以方便地在网页、论坛、社交媒体等平台上分享图片内容，用户只需复制图片链接即可。 图片管理：图床通常提供图片管理功能，允许用户对上传的图片进行管理，包括查看、编辑、删除等操作。 图片处理：一些高级图床服务还提供图片处理功能，如裁剪、旋转、压缩等，使用户可以在图床上直接对图片进行编辑处理。 使用图床的好处包括：\n节省空间：通过将图片上传到图床服务器，可以减轻自己网站或应用的服务器负担，节省存储空间。 加快加载速度：使用图床存储图片可以加速网站或应用的加载速度，因为图床通常会使用 CDN（内容分发网络）技术，将图片文件分发到全球各地的服务器节点，使用户可以从距离更近的服务器获取图片，从而加快加载速度。 方便分享：图床生成的图片 URL 地址可以方便地在各种平台上分享图片内容，无需担心图片被删除或地址失效的问题。 总的来说，图床是一个方便的在线服务，可以帮助用户轻松存储、管理和分享图片。\n2 picgo PicGo 是一个开源的图片上传工具，可以帮助用户快速上传图片到图床并生成图片链接。它提供了简洁友好的图形界面，支持多种图床服务，并且具有丰富的配置选项和插件扩展功能。可以帮助用户快速、便捷地上传和管理图片，并生成图片链接用于分享或嵌入网页。\nPicGo 的主要特点和功能有：\n支持多种图床服务：PicGo 支持丰富的图床服务，包括但不限于 GitHub、七牛云、阿里云、腾讯云、Imgur 等。用户可以根据自己的需求选择合适的图床服务进行配置和使用。 多种上传方式：PicGo 提供了多种上传方式，包括拖拽上传、剪贴板上传、截图上传等。用户可以根据自己的习惯和需求选择合适的上传方式。 支持快捷键操作：PicGo 支持自定义快捷键，用户可以通过快捷键实现快速上传图片、截图等操作，提高工作效率。 自定义命名规则：PicGo 支持用户自定义图片文件名的命名规则，包括时间格式、文件名格式等，使用户可以根据自己的需求对上传的图片进行命名。 图片处理功能：PicGo 提供了一些简单的图片处理功能，如图片压缩、图片裁剪等，用户可以在上传图片之前对图片进行简单的处理。 丰富的插件扩展：PicGo 支持插件扩展，用户可以根据自己的需求安装各种插件，扩展 PicGo 的功能和特性，例如支持更多图床服务、添加更多上传方式等。 跨平台支持：PicGo 支持 Windows、macOS 和 Linux 等多个平台，用户可以在不同的操作系统上使用相同的工具和配置。 开源免费：PicGo 是开源项目，用户可以自由获取、使用和修改源代码，完全免费。 配置手册 | PicGo\n3 B站图床picgo 插件 插件在线安装\n打开 PicGo 详细窗口，选择 插件设置，搜索 bili 安装，然后重启应用即可。 使用方法\n找cookie中的 SESSDATA 还有 bli_jct 复制即可 实现原理\n将图片存在一个 B 站的公共静态资源空间。 举例：所有人上传的图片都会放在这个空间里面，但是你不发布动态的话，那么这个资源与你就没有绑定关系，那么你自然是找不到的。你发布了的话，你的这条动态就会跟这个图片资源绑定关系，那么查看的时候，就知道这个动态绑定了哪些图片链接，就可以看到对应的图片了。 4 其他哔哩哔哩图床软件推荐 浏览器插件 - Bilibili 图床 Typora 插件 - Bilibili 图床 五 typora 1 主题 主题获取网站 Themes Gallery — Typora\n然后打开我们的 Typora 和 -\u0026gt; 文件 -\u0026gt; 偏好设置 -\u0026gt; 外观 -\u0026gt; 打开主题文件夹，将解压好的文件拖到这个 Typora 的主题文件夹\n注意：不能解压到单独的文件夹，直接将解压的文件拖到主题文件夹中，否则会不识别\n","date":"2023-07-23T14:21:18Z","permalink":"https://li54426.github.io/p/%E6%B0%B8%E8%BF%9C%E7%83%AD%E7%88%B1markdown/","title":"永远热爱markdown"},{"content":" content {:toc} cpp感想(1)\u0026mdash;指针 版本号: V1.2\n1 第一版本感想 一开始认为只是一个存储地址的变量, 但是发现有些片面了\n2 第二版感想 想了很久发现, 没有一个词能够很好的形容指针, 感觉协议还靠边一点\n协议, 协议就是一些特殊的规则集合\n指针 是我们自己定义的操纵内存的接口\n我现在的理解就是 指针 = 地址 + 协议\n地址是指在内存中的位置, 协议是指如何管理指向的内存,\n2.1 void指针 ​\tvoid指针不是空指针, 而是可以没有约束( 协议 )的指针, 任何指针指都可以赋值给他, 但是不能用void指针进行操作, 要转换后才能进行操作 ​\t因为void*可以接受任何类型指针，就是所谓的上转型（upcasting），将一个更具体的指针转换成一个类型更泛化的指针。编译器知道这种类型转换并不会带来风险。如果进行下转型（downcasting），就告诉编译器，我现在有一个类型更加泛化的指针，我知道此指针具体类型是什么，但是如果涉及引用就想要进行强制转换。\n1 2 char a[10]; void *b = a; 2.2 malloc 函数 malloc 函数 返回的指针就是void * 类型, 也就是没有协议的类型\n2.3 链表\u0026mdash;来自数据结构 1 2 3 4 typedef struct Listnode{ datatype data; struct Listnode *next; }listnode; 为什么可以做到嵌套定义 :\nListnode 类型的变量可以有两个元素, 一个是数据域, 另一个是指针.这两个的大小和组织形式都是固定的, 例如, datatype为int时, 占据8个字节, 指针一般占据8个字节. 这就占据16个字节. Listnode 指针的协议就可以这么来描述: 大小为16个字节, 类内元素排列是 int ( 8 )+ 指针 ( 8 ) 2.4 obj\u0026mdash;来自SGIGCC2.9 1 2 3 4 5 union obj { union obj * free_list_link; char client_data[1]; /* The client sees this. */ }; //其实就是告诉指针, 这块内存中存储的是个地址, 并且占用8个字节的内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct listnode{ listnode *next; }; typedef struct listnode listnode; int main() { // your code goes here listnode a,b; a.next = \u0026amp;b; cout\u0026lt;\u0026lt; \u0026#34;sizeof listnode = \u0026#34;\u0026lt;\u0026lt; sizeof(listnode)\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;the address of a =\u0026#34;\u0026lt;\u0026lt; \u0026amp;a\u0026lt;\u0026lt; \u0026#34;the address of b =\u0026#34;\u0026lt;\u0026lt; \u0026amp;b\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;the a.next = \u0026#34;\u0026lt;\u0026lt; a.next \u0026lt;\u0026lt;endl; return 0; } /* sizeof listnode = 8 the address of a =0x7ffc8f28fcf8 the address of b =0x7ffc8f28fd00 the a.next = 0x7ffc8f28fd00 */ 2.5 short和int\u0026mdash;来自编程范式(视频) 1 2 3 4 5 6 int arr[5]; arr[3]= 128; ((short*)arr)[6]= 2; //arr被重新解释成2bytes的short型，此时，之前赋值128的地方变为arr[7] //因为short占用的字节小, 因此你可以通过short指针的方式来进行操控一部分内存 ","date":"2023-07-03T23:13:54Z","permalink":"https://li54426.github.io/p/c-%E6%84%9F%E6%83%B3%E4%B9%8B%E6%8C%87%E9%92%881/","title":"c++感想之指针1"},{"content":" Github Action 官方文档：https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#name\n是 Github 推出的持续集成工具\n持续集成是什么？ 简单说就是自动化的打包程序 —— 如果是前端程序员，这样解释比较顺畅：\n每次提交代码到 Github 的仓库后，Github 都会自动创建一个虚拟机（Mac / Windows / Linux 任我们选），来执行一段或多段指令（由我们定），例如：\nnpm install npm run build Yaml 是什么？ 我们集成 Github Action 的做法，就是在我们仓库的根目录下，创建一个 .github 文件夹，里面放一个 *.yaml 文件 —— 这个 Yaml 文件就是我们配置 Github Action 所用的文件。\n它是一个非常容易地脚本语言，如果我们不会的话，也没啥大事继续往下看就成了。\n参考文档：五分钟学习 YAML\nGithub Action 的使用限制 每个 Workflow 中的 job 最多可以执行 6 个小时 每个 Workflow 最多可以执行 72 小时 每个 Workflow 中的 job 最多可以排队 24 小时 在一个存储库的所有 Action 中，一个小时最多可以执行 1000 个 API 请求 并发工作数：Linux：20，Mac：5（专业版可以最多提高到 180 / 50） 什么是 Workflow？ Workflow 是由一个或多个 job 组成的可配置的自动化过程。我们通过创建 YAML 文件来创建 Workflow 配置。\n一、如何定义 Workflow 的名字？ name\nWorkflow 的名称，Github 在存储库的 Action 页面上显示 Workflow 的名称。\n如果我们省略 name，则 Github 会将其设置为相对于存储库根目录的工作流文件路径。\n1 name: Greeting from Mona on: push 二、如何定义 Workflow 的触发器？ on\n触发 Workflow 执行的 event 名称，比如：每当我提交代码到 Github 上的时候，或者是每当我打 TAG 的时候。\n1 // 单个事件 on: push // 多个事件 on: [push,pull_request] 事件大全：https://docs.github.com/en/actions/reference/events-that-trigger-workflows#about-workflow-events\n三、Workflow 的 job 是什么？ 答：一个 Workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。\n1、如何定义一个 job？ 1 jobs: my_first_job: name: My first job my_second_job: name: My second job 答：通过 job 的 id 定义。\n每个 job 必须具有一个 id 与之关联。\n上面的 my_first_job 和 my_second_job 就是 job_id。\n2、如何定义 job 的名称？ jobs.\u0026lt;job_id\u0026gt;.name\nname 会显示在 Github 上\n3、如何定义 job 的依赖？job 是否可以依赖于别的 job 的输出结果？ jobs.\u0026lt;job_id\u0026gt;.needs\n答：needs 可以标识 job 是否依赖于别的 job—— 如果 job 失败，则会跳过所有需要该 job 的 job。\n1 jobs: job1: job2: needs: job1 job3: needs: [job1, job2] jobs.\u0026lt;jobs_id\u0026gt;.outputs：用于和 need 打配合，outputs 输出 =》need 输入\njobs 的输出，用于和 needs 打配合：可以看到 ouput\n1 jobs: job1: runs-on: ubuntu-latest # Map a step output to a job output outputs: output1: ${{ steps.step1.outputs.test }} output2: ${{ steps.step2.outputs.test }} steps: - id: step1 run: echo \u0026#34;::set-output name=test::hello\u0026#34; - id: step2 run: echo \u0026#34;::set-output name=test::world\u0026#34; job2: runs-on: ubuntu-latest needs: job1 steps: - run: echo ${{needs.job1.outputs.output1}} ${{needs.job1.outputs.output2}} 4、如何定义 job 的运行环境？ jobs.\u0026lt;job_id\u0026gt;.runs-on\n指定运行 job 的运行环境，Github 上可用的运行器为：\nwindows-2019 ubuntu-20.04 ubuntu-18.04 ubuntu-16.04 macos-10.15 1 jobs: job1: runs-on: macos-10.15 job2: runs-on: windows-2019 5、如何给 job 定义环境变量？ jobs.\u0026lt;jobs_id\u0026gt;.env\n1 jobs: job1: env: FIRST_NAME: Mona 6、如何使用 job 的条件控制语句？ jobs.\u0026lt;job_id\u0026gt;.if\n我们可以使用 if 条件语句来组织 job 运行\n四、Step 属性是什么？ 答：每个 job 由多个 step 构成，它会从上至下依次执行。\nstep 运行的是什么？ step 可以运行：\ncommands：命令行命令 setup tasks：环境配置命令（比如安装个 Node 环境、安装个 Python 环境） action（in your repository, in public repository, in Docker registry）：一段 action（Action 是什么我们后面再说） 每个 step 都在自己的运行器环境中运行，并且可以访问工作空间和文件系统。\n因为每个 step 都在运行器环境中独立运行，所以 step 之间不会保留对环境变量的更改。\n1 # 定义 Workflow 的名字 name: Greeting from Mona # 定义 Workflow 的触发器 on: push # 定义 Workflow 的 job jobs: # 定义 job 的 id my-job: # 定义 job 的 name name: My Job # 定义 job 的运行环境 runs-on: ubuntu-latest # 定义 job 的运行步骤 steps: # 定义 step 的名称 - name: Print a greeting # 定义 step 的环境变量 env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat # 运行指令：输出环境变量 run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 五、Action 是什么？ 我们可以直接打开下面的 Action 市场来看看：\nAction 其实就是命令，比如 Github 官方给了我们一些默认的命令：\n比如最常用的，check-out 代码到 Workflow 工作区：\n1、我们应该如何使用 Action？ jobs.\u0026lt;job_id\u0026gt;.steps.uses\n比如我们可以 check-out 仓库中最新的代码到 Workflow 的工作区：\n1 steps: - uses: actions/checkout@v2 当然，我们还可以给它添加个名字：\n1 steps: - name: Check out Git repository uses: actions/checkout@v2 再比如说，我们如果是 node 项目，我们可以安装 Node.js 与 NPM：\n1 steps: - uses: actions/checkout@v2 - uses: actions/setup-node@v2-beta with: node-version: \u0026#39;12\u0026#39; 2、上面我们为什么要用：@v2 和 @v2-beta 呢？ 答：首先，正如大家所想，这个 @v2 和 @v2-beta 的意思都是 Action 的版本。\n我们如果不带版本号的话，其实就是默认使用最新版本的了。\n但是 Github 官方强烈要求我们带上版本号 —— 这样子的话，我们就不会出现：写好一个 Workflow，但是由于某个 Action 的作者一更新，我们的 Workflow 就崩了的问题。\n3、上面的 with 参数是什么意思？ 答：有的 Action 可能会需要我们传入一些特定的值：比如上面的 node 版本啊之类的，这些需要我们传入的参数由 with 关键字来引入。\n具体的 Action 需要传入哪些参数，还请去 Github Action Market 中 Action 的页面中查看。\n具体库的使用和参数，我们可以去官方的 Action 市场查看：\n六、我们如何运行命令行命令？ 上文说到，steps 可以运行：action 和 command-line programs。\n我们现在已经知道可以使用 uses 来运行 action 了，那么我们该如何运行 command-line programs 呢？\n答案是：run\nrun 命令在默认状态下会启动一个没有登录的 shell 来作为命令输入器。\n1、如何运行多行命令？ 每个 run 命令都会启动一个新的 shell，所以我们执行多行连续命令的时候需要写在同一个 run 下：\n单行命令 1 - name: Install Dependencies run: npm install 多行命令 1 - name: Clean install dependencies and build run： | npm ci npm run build 2、如何指定 command 运行的位置？ 使用 working-directory 关键字，我们可以指定 command 的运行位置：\n1 - name: Clean temp directory run: rm -rf * working-directory: ./temp 3、如何指定 shell 的类型？（使用 cmd or powershell or python？？） 使用 shell 关键字，来指定特定的 shell：\n1 steps: - name: Display the path run: echo $PATH shell: bash 下面是各个系统支持的 shell 类型：\n七、什么是矩阵？ 答：就是有时候，我们的代码可能编译环境有多个。比如 electron 的程序，我们需要在 macos 上编译 dmg 压缩包，在 windows 上编译 exe 可执行文件。\n这种时候，我们使用矩阵就可以啦～\n比如下面的代码，我们使用了矩阵指定了：2 个操作系统，3 个 node 版本。\n这时候下面这段代码就会执行 6 次 —— 2 x 3 = 6！！！\n1 runs-on: ${{ matrix.os }} strategy: matrix: os: [ubuntu-16.04, ubuntu-18.04] node: [6, 8, 10] steps: - uses: actions/setup-node@v1 with: node-version: ${{ matrix.node }} 下一篇文章：《实战：electron 通过 Github Action 自动打包，并上传到 Github 的 release 中》 敬请期待！！！！！\n","date":"0001-01-01T00:00:00Z","permalink":"https://li54426.github.io/p/","title":""},{"content":"那该怎么获得最最一手的版本呢？嘿嘿，GitHub 上有源码，咱们完全可以自己编译打包。\n当然，当然，如果是从头开始打包，那不得搞个 Android Studio 自己慢慢折腾？\n感觉光安装编译工具就能劝退 90% 的小伙伴了，所以这里肯定不是这种传统的编译教程，而是取个巧，通过白嫖 GitHub 来一键打包。\nGitHub Actions，这是 GitHub 为开发者准备的跑脚本的服务，你可以简单理解成 GitHub 准备了一个开箱即用的远程虚拟机。\n虽然免费账号有限制，但对于打包一个 apk 绰绰有余了。\n具体操作是 ——\n1、登录自己的 GitHub 账号，然后 Fork 一下项目源码，在跳转页点「Create fork」就好了。\n地址：github.com/bggRGjQaUbCoE/c001apk\n2、Fork 成功后，在咱们自己的仓库里，点击「Actions」，并启用。\n3、然后运行脚本。\n等脚本跑完，也就是那个对号出现，咱们点进去。\n这里有个「build」的选项，再点进去。\n在「Upload release」里，就能找到打包好的 apk 文件了。\n把压缩包下载下来，解压后就能在手机上安装了。\n就是这么简单，唯一的难点，大概就是搞定 GitHub 的网络问题了。\n结语\n好了，这就是今天的全部内容了，既分享了 c001apk 这个开源的第三方客户端，又分享了 GitHub 一键打包的方案。\n我顺便把最新版的 c001apk 分流到了蓝奏云，老规矩，有需要的小伙伴自取就好。\n地址：wwx.lanzouj.com/iMu6a1tmliob\n授人以鱼也授人以渔，希望能帮到大家。\n","date":"0001-01-01T00:00:00Z","permalink":"https://li54426.github.io/p/","title":""}]
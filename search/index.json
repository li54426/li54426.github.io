[{"content":" content {:toc} 5 浏览器插件 插件名称 说明 onetab 将不看的页面保存到一个标签页中 itab Holmes 使用Alt+Shif+H即可搜索书签；当然你也可以在搜索框中输入*+Tab来搜索； Markdown Here 写博文时可以使用markdown, 输入markdown -\u0026gt; 点击图标 markdown here基本渲染css 微信公众号毫秒级排版，让你的排版充满审美愉悦感。复制代码到“markdown here基本渲染css”即可 markdownload 将文章保存为md格式 mpmath Markdown Nice 微信公众号排版 tampermonkey 俗称油猴插件, 使用它你将发现新的世界 Adblock Plus 广告拦截 Cookie-Editor - Microsoft Edge Addons 设置cookie Dark Reader 将网页变成黑暗模式 globle speed 设置视频播放速度 Refined Leetcode - Microsoft Edge Addons 增强 LeetCode-cn 刷题体验 A+ 文本大小更改器 - Microsoft Edge Addons alt + 上下箭头 来更改字体大小 学习 强国 插件 自动学习强国 火狐安装组件提示 “此附加组件无法安装，因为他有可能已经损坏” 解决方法\n解决方案：\n火狐地址栏输入 “about:config”, 回车会提示可能失去质保，点击 “ 我保证会小心”； 搜索 “xpinstall.signatures.required”，双击 “true” 自动改为”false“; 将组件拖入浏览器安装，并检查是否安装成功。 6 油猴脚本 脚本名称 说明 显示力扣周赛难度分 显示题目对应 周赛难度分 的浏览器插件 微信公众号 阅读 微信公众号文章阅读模式 (greasyfork.org) 网页宽屏 (greasyfork.org) 微信 Bilibili 小程序链接转直链 (greasyfork.org) 万能验证码自动输入（升级版） (greasyfork.org) b773cd0b68a64bc88d9722310ab30a7e webAi组件\n用小组件自定义你的新标签页,支持暗黑模式，已整合 WetabAI 组件\nWetab是一款可以亲手打造属于自己的高颜值主页的小组件新标签页插件，跟Infinity New Tab新标签页一样美观大气，跟iTab iTab新标签页一样主打小组件功能。iOS苹果小组件卡片设计，内置倒计时、纪念日、天气、热搜、计算器、等超酷小组件，让信息一目了然，标签页整洁美观。 Wetab好看、好用，还好玩，让你的标签页充满无限可能： 1.自定义新标签页中的小组件和图标，支持随意拖拽布置，任意搭配。 2.自定义生日倒计时组件，发工资倒计时小组件，节假日小组件等。 3.快速添加常用网站或小组件到主页。 4.自定义搜索引擎，快捷切换百度/谷歌/必应等搜索引擎，还可以自定义添加其他搜索引擎。 5.自定义壁纸，海量高清壁纸任你选择，包括自然、海洋、建筑、动物等类别。 6.笔记和待办小组件让你的灵感不会溜掉，任务更加清晰。 7.自定义深色或浅色模式，也可以跟随系统设置。 8.自定义左侧栏，支持图标分类。办公娱乐更加得心应手，可设置左侧栏隐藏或显示。 9.自定义底部栏，收纳常用网站，一键进入更方便，可设置底部栏隐藏或显示。 10.登录/注册Wetab账号，可在不同设备备份、同步你的数据。 11.你可以接收到我们向你发送的消息通知。 12.阅读榜单小组件 13.支持图标大小调节 14.热搜榜单小组件，支持微博热搜、百度热搜、微信24小时热文榜、哔哩哔哩热门、抖音热门视频、今日头条、少数派、CSDN。 15.支持图标宽度调整 16.支持图标尺寸调整，可调大、中、小 三种模式。 17.换算器小组件。支持计算器、住房贷款计算、个人所得税计算、长度单位、重量单位、面积单位、体积单位、温度单位、速度单位、进制转换、热能、压强、功率、力转换等。 18.支持日历小组件 19.每日一言小组件 20.新闻小组件 21.习惯养成小组件 22.系统状态小组件，实时显示CPU、电池、内存的使用情况。 23.货币汇率换算小组件。 24.股票小组件 25.历史上的今天小组件 26.游戏资讯小组件 27.电影日历小组件 28.豆瓣阅读榜单小组件 29.WeTabAi组件，自由访问AI大模型 30.动态壁纸、渐变背景 31.新增AIPPT组件，AI写论文 在线版地址：https://web.wetab.link/ 问题反馈：https://support.qq.com/product/422565 官方网站：https://www.wetab.link/zh/\n","date":"2024-07-01T16:36:14Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} 1 C++ 11 之前的初始化方式 C++ 11 之前初始化的方式可以分为：直接初始化、拷贝初始化和大括号列表初始化\n直接初始化 这个最好理解，直接用显式的构造调用初始化，基本数据类型同样适用\n1 2 int j(0); MyClass myclass(123); //Foo is a class 拷贝初始化 1 2 int i = 0; MyClass myclass; //Foo is a class 大括号列表初始化 这种列表初始化方式仅限于有限的几种类型：数组和 POD 类型（plain old data 类型，指的是这样一些数据类型：基本数据类型、指针、union、数组、构造函数是 trivial 的 struct 或者 class 等与 C 相兼容的数据类型，可以按照 C 的方式来处理（运算、拷贝等））\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 列表初始化 C11 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; map = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; // 如果有些元素没有指定, 那么就会默认初始化 int arr[4] = { 1, 2, 3 }; // 默认值的初始化, 全部是 0 int a[26] ={}; int a[26]{}; struct A{ int i; struct B{ int j; int k; } b; } a = { 1, { 2, 3 } }; //POD类型 C++ 11 提供了统一的列表初始化方式 以下内容来自chatgpt\nC++列表初始化（List Initialization）是一种用于初始化对象、数组和容器的新语法。它在C++11标准中引入，并在后续的C++14、C++17和C++20中得到进一步扩展和改进。列表初始化通过使用花括号 {} 来简化初始化语法，同时提高代码的安全性和可读性。\n列表初始化的类型 列表初始化主要有以下几种类型：\n直接列表初始化：\n直接在对象创建时使用花括号进行初始化。\n1 2 int x{5}; // 直接列表初始化 double y{3.14}; 拷贝列表初始化： 使用等号和花括号进行初始化。\n1 2 int x = {5}; // 拷贝列表初始化 double y = {3.14}; 聚合初始化： 用于聚合类型（如结构体、数组等）的初始化。\n1 2 3 4 5 6 7 struct Point { int x; int y; }; Point p = {1, 2}; // 聚合初始化 int arr[] = {1, 2, 3, 4}; // 数组的聚合初始化 范围for循环： 使用范围for循环遍历列表初始化的容器。\n1 2 3 4 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; for (int n : vec) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } 标准库容器的列表初始化： 初始化标准库容器，如 std::vector、std::array 等。\n1 2 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; std::array\u0026lt;int, 4\u0026gt; arr = {1, 2, 3, 4}; 列表初始化的优势 避免窄化转换： 列表初始化不会允许从浮点到整数、较大范围整数到较小范围整数等潜在的危险转换。\n1 int x{3.14}; // 错误，不能从double到int的窄化转换 统一的初始化语法： 提供了一种统一的对象初始化语法，提高了代码的一致性和可读性。\n1 2 3 int x{5}; double d{3.14}; std::vector\u0026lt;int\u0026gt; vec{1, 2, 3, 4}; 更简洁的代码： 列表初始化语法通常比传统的构造函数调用更简洁和直观。\n1 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4}; // 比 vec.push_back(1); vec.push_back(2); 等更简洁 列表初始化的示例代码 以下是一些具体的列表初始化示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; struct Point { int x; int y; }; int main() { // 直接列表初始化 int a{10}; double b{3.14}; // 拷贝列表初始化 int c = {15}; double d = {2.71}; // 聚合初始化 Point p = {1, 2}; int arr[3] = {4, 5, 6}; // 标准库容器的列表初始化 std::vector\u0026lt;int\u0026gt; vec = {7, 8, 9, 10}; std::array\u0026lt;int, 4\u0026gt; arr2 = {11, 12, 13, 14}; // 输出测试 std::cout \u0026lt;\u0026lt; \u0026#34;a: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;c: \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;, d: \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Point p: (\u0026#34; \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;arr: \u0026#34;; for (int i : arr) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;vec: \u0026#34;; for (int i : vec) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;arr2: \u0026#34;; for (int i : arr2) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 以上代码展示了不同情况下的列表初始化使用方法及其输出结果。列表初始化不仅能使代码更清晰，还能防止许多潜在的错误，是C++11及以后标准推荐的初始化方式。\n","date":"2024-06-15T22:22:02Z","permalink":"https://li54426.github.io/p/cpp%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/","title":"CPP的初始化方式"},{"content":" content {:toc} 首个数据特殊 100311. 无需开会的工作日\n给你一个正整数 days，表示员工可工作的总天数（从第 1 天开始）。另给你一个二维数组 meetings，长度为 n，其中 meetings[i] = [start_i, end_i] 表示第 i 次会议的开始和结束天数（包含首尾）。\n返回员工可工作且没有安排会议的天数。\n注意：会议时间可能会有重叠。\n示例 1：\n输入：days = 10, meetings = [[5,7],[1,3],[9,10]]\n输出：2\n解释：\n第 4 天和第 8 天没有安排会议。\n示例 2：\n输入：days = 5, meetings = [[2,4],[1,3]]\n输出：1\n解释：\n第 5 天没有安排会议。\n示例 3：\n输入：days = 6, meetings = [[1,6]]\n输出：0\n解释：\n所有工作日都安排了会议。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int countDays(int days, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; meetings) { // 会议时间可能会有重叠。 sort(meetings.begin(), meetings.end()); int len = meetings.size(); if(len \u0026lt; 1){ return days; } // 开始状态 int start = meetings[0][0], end = meetings[0][1]; int res = meetings[0][0]- 1; for(auto p : meetings){ if(p[0] \u0026gt; end){ res+= (p[0]- end -1); } // start = p[0]; end = max(p[1], end); } res += (days - end); return res; } }; 56. 合并区间 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; nums) { if(nums.size()==1){ return nums; } sort(nums.begin(), nums.end(), [](auto \u0026amp;a, auto \u0026amp;b){ if(a[0] == b[0]){ return a[1]\u0026lt;b[1]; } return a[0]\u0026lt; b[0]; }); int l= nums[0][0], r =nums[0][1]; auto res = nums; res.clear(); for(int i =1; i\u0026lt;nums.size(); ++i){ if(nums[i][0] \u0026gt; r){ // 不相交 res.push_back({l, r}); l = nums[i][0]; r = nums[i][1]; } else{ l = min(l, nums[i][0]); r = max(r, nums[i][1]); } if(i == nums.size()-1){ res.push_back({l, r}); } } return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { ranges::sort(intervals); // 按照左端点从小到大排序 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; for (auto\u0026amp; p : intervals) { if (!ans.empty() \u0026amp;\u0026amp; p[0] \u0026lt;= ans.back()[1]) { // 可以合并 ans.back()[1] = max(ans.back()[1], p[1]); // 更新右端点最大值 } else { // 不相交，无法合并 ans.emplace_back(p); // 新的合并区间 } } return ans; } }; ","date":"2024-06-02T10:54:45Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} \\section{问题}\n3.21 问题 1.摘要需要精炼：第一段：介绍问题（第一句：云边协同的标准定义定义，第二句：自己做的方向，第三句：原有研究的问题）。第二段：介绍方法。第三段：介绍效果。 2.文中不要使用“本研究”或“此次研究”，英文使用thesis，不使用paper等。 3.目录字体颜色设置为黑色。 4.根据学院要求查看题目是居中还是左对齐。 5.图片尽量横着排列，不要让审稿员认为是在凑篇幅。 6.最后一章节（总结和展望）字数过少。总结：此次研究的优点、好处。展望：此次研究的不足和存在的问题，并针对这些不足和问题提出今后的研究方向。 2.28 问题 修改文档中尚存的部分缺隔.（见标注 仿真试验环境的描述不够的致 评价指挥中的种群离程度在实验中没有体现. 第四章实验国不规范.修改 2.24 问题 26日我们要提交论文初稿进行评阅，以下几个工作还请各位自查：\n1、摘要要采取“总分”的机构，第一段总体描述你要做什么、核心科学问题是什么，本文主要研究内容是什么。之后“分”开来说每一个小点：(1) 针对什么问题（前面说过），提出什么模型或方法、机制等，实验结果如何等等。 2、完成最后部分的攻读硕士期间完成的科研成果和致谢。 3、每一章的标题和第一节中间那里要有一个本章内容提要，第二章开始到最后一章之前，每章要有“本章小结”，两段承上启下。 4、引言部分的逻辑是“引言”（要做什么）-\u0026gt;“国内外研究现状”（以往大家怎么做的）-\u0026gt;“现有研究存在的问题”（大家做的有什么不好的）-\u0026gt;“本文的研究内容”（本论文主要做了什么）-\u0026gt;“论文的组织架构”（如何安排上述研究内容）。 5、篇幅少只有一个问题，实验太少。 6、认真过两遍内容，修改错别字和病句。 6、今晚前再给我发一版，明天按学院要求准备好提交的版本，并印制好论文。 2.21 问题 第一个摘要当中你的每两个小点，你要针对什么问题，采取什么方法，怎么样解决的，最后解决的效果是什么样，这样去写。 第二点就是你最后要少一个在读期间的研究成果。 第三个就是图和表放到页面的上方去。 第四个问题，现在目前论文当中的实验结果还比较少，所以你的篇幅才到，才到，我看把那些空页刨掉大概才五十来页，目前这个篇幅量是不够的。 2.15 问题 几个问题： (fin)1、摘要还没写。\n(fin)2、国内外研究现状要给出具体的科学问题（针对你后面的主要内容，科学问题是说过往研究的短板和缺陷，针对于这些问题，本文的主要工作是如何解决这些问题的）\n(fin)3、每一章开始的位置，要写一段“本章的主要内容是什么，针对什么问题，本章提出了什么，具体怎么实现的，实验结果是什么杨，说明什么”等等。\n（fin）4、第二章还要有个本章小结。\n（fin）5、公式后面的“其中”要顶格写，是用于解释上一个公式的，不是新的段落。\n（fin）6、内文的写作上不要使用“我们”，论文是你一个人写的，没有“你们”，尽量使用“本论文”作为主语。\n(fin)7、参考文献目前不够，至少要弄到60篇以上，一定要在文中实际引用过。估计这是第二章没写完的问题，尽快完善。而且里面为什么会有天体物理概论？\n20240418 1.论文在将任务不可分时进行建模解决的时候，需要对相应的过程进行解释，包括建模的内容，其原因以及备选的解决方法。\n2.论文采用的是进化算法对此类问题进行解决，而在论文开头提到了车载任务的分解可能是动态的，可以对此进行讨论。\n3.对于仿真结果可进行更深入的分析，如图4-8的结果进行更深入的分析和解释\n4.论文还有一些文字语法错误，可以进一步修改。\n(fin)1.摘要的第三段，对第四章的工作描述不准确，如“通过重新新定义运算符号以及增高架了调增策略的方式”；\n2.论文第6-7页的分析中，指出了“车联网中任务调度面临的问题对求解精确解的传统优化算法提出了挑战以及传统优化算法的缺点”，但并未解释清楚本文使用启发式算法来生成任务调度方案的原因；\n(fin)3.论文第19页，建议将“我使用…”改为“本文使用…”\n4.论文第20页，“公式3.2中的CPU的容量在能被下面的公式计算出来”，表达不流畅：\n(fin)5.论文第23页，“一种是任务可分情况（3.3.1节），另一种是任务不可分情况（33.2节）。”，应分别是3.2.1节和3.2.2节；\n(fin)6.文中并没有对图3-2进行描述：\n(fin)7.论文第26页，“本章实验环境为：处理器为：Intel（R）Core（TM）i7-7700HQ：显卡的型号为：NVIDIAGeForceRTX1050”，建议将后两个冒号去掉：“频率集为700,800,900，，，1900”，建议正确使用省略号： 8.论文第27页，“基于【58】中提供的分析，CPU容量参数……·”，此处有参数书写错误； 9.图3-4（b）中，为什么当车辆数目为30和40时，能耗的平衡系数反而增加？当车辆数目为35时，能耗的平衡系数比车辆数目为25的低？请详细分析平衡因子FC值的变化原因：\n(fin)10.论文第29页，对图3-5的描述有误，请认真修改：建议与图3-4保持一致，将图3-5的英文改为中文：\n(fin)11.论文第30页，对第三章的工作表述有误，如“提出了一种基于粒子群算法的调度与分配策略”；\n(fin)12.论文第31页，“依次将任务分配给选择当前剩余处理时间最短的机器”，表达不流畅：\n(fin)13.论文第39页，对公式4.2的参数描述中，建议去掉括号；\n14.图4-6中，并未说明使用了什么数据集；\n(fin)15.图4-7的（a）和（b）里，请保持中英文一致：\n(fin)16.文中给出了衡量种群多样性的度量方法但给出的图4-7（b）却是种群差异\n\\section{修改记录} 20240514提交终稿 添加基于启发式算法的任务调度图，基于强化学习的任务调度图，添加基因算法流程图 添加基因算法部分的描述内容，基因算法分3小节描述。 添加第三章实验使用参数值的原因。 将DDMO算法伪代码的 latex 源代码重新修改。 结构上将2.1.1和2.1.2合并(规划的基础知识与规划的描述形式) 将建模过程和使用公式描述物理模型分开。建模过程单独一节。 总结展望从 44-》 46 （内容新增了一页） 20240501 按照所提出的要求重新画图 修改语法错误，让某些语句变得规范 。 20240322提交系统 英文摘要 article-\u0026gt;thesis 按照张老师要求重写摘要 提交到系统 20240321 在【YNUlogo.sty】文件中搜索【prl】，在搜索结果下增添条目 { prl2, 000000, 000000, 000000 }，然后在【main.tex】中修改【hyperlink-color = prl2】 重新制作了封面，使得题目左对齐；将目录设置为黑色。 重新画图，使得图片大小一致以便于合并，将图片内容两两合并，合并了四组图片，（只要是一页有两张及以上图片就合并，图片从原来的21将为17）。 重新写了第五章未来工作，将第五章内容扩充为一页半。 按照要求重新写了一遍摘要。 通读全文，对于文章中的不通顺内容进行修改。 重新上传到知网进行查重，重复率6以下。 20240320 修改图名为XX图,图片如果有值,那就命名为XX值图,如果有结果,那就命名为 XX结果图 修改表名为 XX表, 仿真实验 xx 表 运算符号增加解释性内容 重新定义了 p 值 图片两两合并，页数减少了两页纸。 20240311 王老师帮忙修改英文摘要 同步修改中文摘要 20240307查重 知网个人查重服务 5.7% 万方硕博版 重复率 5.19% 20240303 增加未来工作（模拟退火）部分。 根据 aigc 修改 第一章 绪论 部分 20240302 修改语法错误，对实验结果进行润色。 第三章实验结果图太乱，分成了两个子图。 20240301 将没有坐标轴的两个图片修改完毕。 添加指标，能耗，平衡因子。 添加图片：能耗、平衡因子。 20240220 增加相关工作的参考文献至61个 重新调整第四章的章节顺序 20240219 添加新的图片，侏儒猫鼬图片 侏儒猫鼬算法移动到第二章 侏儒猫鼬算法添加相关工作 （45个参考文献） 基因算法添加相关工作 20240218 基因算法添加相关工作 重新调整第二章的章节 文献增加值 34 个 20240217 修正第三章建模（一个小节）的错误 20240216 添加本章说（章节开始部分内容） 添加第二章 本章小结 的内容 20240215 添加函数示意图片 将摘要部分单独列为一个文件 20240201 将参考文献复制到 latex， 一个条目一个条目谷歌搜索。 重构 latex 文件，从单文件形式修改为多文件 修改 \\newpage为\\clearpage 的问题，使得图片正常显示 20240130开始使用latex 将word内容复制到latex，为latex 初始版本 ","date":"2024-05-14T14:14:19Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} ","date":"2024-04-09T10:21:32Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} TVBox 1简介 1.1 介绍 TVBOX开源版是一款基于GitHub社区官方代码仓生成的安卓应用。其前身就是之前很火的猫影视 TV，延续了猫影视采用的「套壳」与「视频源」分离的结构形式；这样有个好处，哪怕视频源倒闭了，壳子软件可以一直用。\n「猫影视」就采用的是这种模式，之前我也早就在储物间有提供，用过的粉丝应该都觉得好用，但影视猫还良心的给我们留了点〝遗产〞，原团队在 Github 开源了一个名为 TVBox 的项目，此 APP 功能界面与影视猫几乎保持一致： https://github.com/CatVodTVOfficial/TVBoxOSC，不过原项目这里并没有给大家提供编译好的 APP\n但这世上似乎永远不缺少英雄，o0HalfLife0o 大佬好心的提供已签名可安装的最新测试版 APK：https://github.com/o0HalfLife0o/TVBoxOSC/releases/\n安装完成后，用户导入电视源配置便可以正常使用该软件，这款应用配置源非常丰富，支持sp源、APP源、采集站源和聚合源等多种来源，几乎可以满足用户对不同类型影视资源的观影需求，无论是影视作品还是电视直播都可以在线观看。\n以 TVbox 为参照的各种 TVbox 改版，开始陆续发布上线。.例如 TVbox_pro、pluto-player、TVbox 影视仓、TVbox_taka、tvboxq 版、宝盒 (tvbox 改版)、tvbox 蜂蜜版、TVBOX 魔改版等等。这其中有的是与原版采用同样的壳源分离模式，有的则是内置了部分资源接口。\n1.2 源 下面是几个我在使用的源:\nhttp://pandown.pro/tvbox/tvbox.json\nhttps://agit.ai/Yoursmile7/TVBox/raw/branch/master/XC.json\n饭太硬 | 导航 (xn\u0026ndash;sss604efuw.top)\n1.3 收集的资源 链接:https://caiyun.139.com/m/i?105CqOWrry45X 提取码:n7Pu 复制内容打开移动云盘PC客户端，操作更方便哦\n在 Github 上其实有很多程序员在维护自用的 TVBOX 接口，而 Github 上的代码多数都是公开的，所以你懂的\n搜索方法也很简单，在 github.com 上搜索关键词：TVBOX，然后再右上角 Sort 筛选这里，选择 Recently upload 最近更新\n1.4 使用教程 本地源\n在配置界面，选择 [上传文件] 在弹出的系统文件管理界面中，按之前的保存路径找到本地包， 确认上传，点确定；本地包就会自动解压到本地根目录。 下面这里就会显示出刚刚解压出来的本地包文件夹，点开 找到接口文件，点击 [使用] 2 不同版本 2.1 黑盒版本 TVBox_takagen99_20230816 版本\n简单, 俗称黑版 没有其他内容 2.2 蜂蜜2.3.0 安装后名称为影视\n蜂蜜版也就是 FongMi 版 TVBox 电视盒子是一款最新的 TVBox 新的优化版本 FongMi 版，做了很多优化，最好用的就是自动跳过失效的线路，其他的版本会一直卡在那里，最新的 FongMi 版 tvbox 会自动选择最好最流畅的线路进行播放，非常好用。\n程序足足比原生 tvbox 大 2 倍，也就 40M 左右\n内置版本比较方便的就是无需扫码配置接口了，另外遇到什么问题打不开软件了只需要重置一下软件数据就能继续用了，这个是内置比较方便的，尤其老人使用哈。\n颖式壳子在很早之前就更新了接口补齐的功能了，也就是在接口的地方输入字母a就会自动补齐接口格式变为本地接口前缀assets://，这个时候只需要再输入一下字母a，就可以调用软件自带的多仓接口了，操作起来是非常方便的！\n​\nmlabalabala/box: TVBox 的一个可以处理多源的版本，支持安卓 4.4 (github.com)\n2.3 521魔改壳子 一款基于蜂蜜版本制作来的支持多仓，支持浏览器的壳子，界面做的很好，只是大佬更新上比较佛系，都是看到蜂蜜版本有了什么好的功能然后再去搬运一把，之前还搞了很多创意的功能，现在只是定期搬搬砖了\n2.4 yuan_影视仓 5.0.6 版本： 影视仓支持阿里网盘，只需要添加阿里 token，即可查看阿里网盘里面的 4k 影视资源。影视仓支持多仓，只需要内置多仓地址，即可切换地址源，解锁众多影视资源。也可以添加单仓地址源。影视仓更新的比较勤快。版本更新快。 支持dlnc投屏, 推荐使用 目前影视仓总共有 3 个发行版本，蓝色和红色图标为手机版本，适配手机最好，竖屏形式。\n蓝色是街机游戏版，提供了街机模拟器，小霸王，世嘉等模拟器，用来回味童年经典。 红色版本是短视频版本，内置了快手短视频。 我目前自己主要用手机端了～，这两个功能都是看剧无聊时用来打发时间的，大家按需下载即可。其他功能一致\n而橙色版本是横屏版本，主要用于 TV 端，或者平板，手机版也可用于平板，看自己需求，但是手机版不可安装到电视端，没有适配，如果你需要在电视端安装，安装橙色版本\nOK猫颖2.3.0 比较有意思的是OK大佬完全不跟着蜂蜜大佬原来的路线走哈，大佬新的版本居然又支持了clan的格式了，这个功能蜂蜜大佬可是在退网前才刚关掉的，另外首页显示分类的功能，蜂蜜大佬也是故意不放的，OK大佬则是特意搞了，还放了开关设置，真的很不错哈！\n在资源筛选这块，除了豆瓣就是360还有2345这些站的资源比较强了，筛选的内容比较细致，随手写了规则，然后从其他接口里面偷来的接口直接用到了大全的接口上，感觉还可以，热门的资源基本都可以做到秒b，唯一的缺点就是咚慢还有宗义的资源解析看运气，貌似大部分的解析在这两块内容都比较差劲哈！\n资源站 源仓库 (yckceo.com)\n饭太硬 | 导航 (xn\u0026ndash;sss604efuw.top)\n2 TV 和手机通用会员 腾讯视频 之小爱音箱提取版魔改版 哔哩哔哩 之小爱音箱提取版 / 哔哩哔哩TV版 百度网盘TV版 ( 需要会员 ) 尝试修复经典的 bilibili tv 1.6.6 版本 2021年,安卓电视上最好用的网络浏览器是什么? 目前(2022年)用到遥控器体验最好的电视浏览器:TV Bro(开源) jiopages(阿三出品)主力使用\nTV Bro跟jiopages浏览器有一拼,只有5M,速度快,开源,可过滤广告,设置收藏 火狐TV版(可用,兼容性广,官方停止更新,不再推荐) TCL雷鸟BrowseHere浏览器(内存占用稍大,遥控操作稍有卡顿 ","date":"2024-04-08T21:59:02Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} 1 概述 原作者地址\n文档地址：https://as.js.cool\n1.1 已经实现功能 云盘每日签到 公共号每日签到 公众号抽奖 每日任务 - 上传 每日任务 - 云笔记（官方下线） APP 抽奖（摇一摇） 浇水种树 - 云盘 APP 浇水种树 - 邮箱 APP 每月任务 - 邮箱 APP - 可直接完成的 热门任务 - 分享文件每月 7 次 邮箱 APP 开盲盒 每月任务 - PC 端登录 合成大芝麻每月 1 次 每月分享 20 次 每月上传 1 G AI 猜字谜 自动领取每月备份奖励（APP / 邮箱） 更多每月任务适配中，敬请不要期待 需要的 信息 代码 ： npmmirror 镜像站\ngitee asuna: 介绍剧吐ʚ♡⃛ɞ(ू・ᴗ・ू❁) (gitee.com)\n列表不需要额外的设计，直接简单粗暴，A 列是当前账号的手机号，B 列是之前复制的 authorization，C 列是之前复制的 auth_token（支持多账号，放多行）\n参数1 参数2 参数3 手机号 authorization auth_token 金山文档（WPS 云文档）使用详细教程 1 准备工作 1.1 创建账号 官网 https://www.kdocs.cn/\n如果你未曾拥有金山文档账号，请先注册一个账号，然后登录。详细步骤略。\n1.2 创建文档\n点击首页的 +新建\n然后选择 智能表格 或者 表格（这里以表格为例）\n然后创建一个空白表格\n表格介绍 字母 ABCD。。。 表示表格的列\n数字 1234。。。 表示表格的行\nA1 表示第一行第一列（左上角那个格子），那么 B2 呢？\n最底部有个 Sheet1 （中文叫做 单元格），新建的表格只有一个单元格，你可以点击后面的 + 添加（选择工具表）\n鼠标左键双击 Sheet1 这个单元格名称，然后就能输入你想要的名称了，比如 夸克网盘。\n鼠标左键单击 Sheet1 这个单元格，就是选中这个单元格（有多个单元格时有效，例如图中 Sheet2 绿色加粗的，所以我当前选择的是 Sheet2）。\n试试让自己拥有 alipan，quark 以及 推送 三个单元格吧。成功后进入下一章节。\n2 表格设计 表格设计是为了写入 网络传输所需要的cookie信息等\n1 点击刚才创建的 推送 单元格 推送配置设计如下：\n表格如图所示，每两列为一个配置单元（每个单元之间允许空列，可有可没有，例如 C 列就是空的，但是 EF 之间没有空）\n单元的第首行首列放置推送名，如 email，pushplus。base 比较特殊。（如果没有放推送名，下面写的东西就会被忽略掉）\n除第一行外，每个单元第一列为配置名称，第二列为值，中间允许空行（如 email 的第 4 行所示）\n注意：图中表格的颜色是为了方便演示添加的，无实际意义，你不必和我的一样。\n运行简单的脚本 以阿里云盘签到为例\n选择 alipan 单元格，在 A1 填上你的 token（如何获取不在本教程范围内，请自行完成）。每一行表示一个用户，故 A2 可以是你的第二个账号，A3 呢？以此类推。。。\n3 创建脚本 点击头部菜单栏的 效率 选择高级开发 选择 AirScript 脚本编辑器 点击文档共享脚本后面的 + 加号 粘贴脚本代码（示例代码：https://npmmirror.com/package/@asunajs/dist/files?version 点击后选择 alipan.wps.js） 点击输入框上面的操作栏的第六个，一个六边形图标那个（鼠标放上去显示服务授权） 点击添加服务 添加 网络API，邮箱API 点击输入框上面的操作栏的第四个，一个三角形图标那个（鼠标放上去显示运行 F5） 允许服务授权 当看到成功提示时，恭喜你，你已经成功运行了脚本。\n4 定时运行 这里就不放图了\n点击头部菜单栏的 效率 选择 高级开发 选择 定时任务 右边出来的抽屉中点击蓝色的 创建任务 选择每天，再选个具体时间（不推荐晚上接近 12 点，也不推荐凌晨） 选择你创建的脚本 然后点击确定 恭喜你，你已经成功设置了定时任务。\n5 附件 移动云盘签到模板\n哔哩哔哩签到\n","date":"2024-04-08T21:44:44Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} ","date":"2024-04-06T13:53:18Z","permalink":"https://li54426.github.io/p/","title":""},{"content":"1 邮件设置转发 进入邮箱（例如126，QQ邮箱等），点击设置选择转发选项， 然后填写转发的目的邮箱就行 2 邮件设置短信提醒 进入139邮箱APP（因为移动作为运营商，其业务范围一定包括短信，且该项业务免费） 右下角我的，打开设置 选择邮件到达通知 ","date":"2024-04-05T23:09:34Z","permalink":"https://li54426.github.io/p/%E9%82%AE%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%BD%AC%E5%8F%91/","title":"邮件设置转发"},{"content":" content {:toc} 1 自动查找答案 在我们的生活中有这样的场景，需要做一些题目，而这些题目是知道答案的（例如，校规校纪，防火检查等）\n代码的功能为: 读取问题、查询题库并生成查询结果的 Python 脚本。这个脚本可以处理文本预处理、从文本中提取题目、读取题库、进行查询并将结果保存到 Excel 文件等多个功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 import re import pandas as pd ##########-读取查询列-######### # 文本预处理 filepath = \u0026#34;./auto/question.txt\u0026#34; with open(filepath, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: text = f.read() text_new = text.replace(\u0026#39;（\u0026#39;, \u0026#39;(\u0026#39;) text_new = text_new.replace(\u0026#39;）\u0026#39;, \u0026#39;)\u0026#39;) with open(filepath, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(text_new) # 打开txt文件并读取内容 with open(\u0026#34;./auto/question.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: content = file.read() # print(\u0026#34;contect=\u0026#34;, content) # 把题目导出来 pattern = r\u0026#39;(\\d+\\.+)(.+?)(?=(\\(|\\。|\\n|$))\u0026#39; matches = re.findall(pattern, content, flags=re.DOTALL) # [(\u0026#39;1. \u0026#39;, \u0026#39;质量流量计不能够直接测出的参数是（ ）\u0026#39;),.....] # print(\u0026#34;maches=\u0026#34;, matches) matches = [(ma[0], ma[1] ) for ma in matches] print(\u0026#34;maches=\u0026#34;, matches) # 将数据转换成 DataFrame 格式 # 将数据转换成 DataFrame 格式, 并修改列名为 \u0026#34;序号\u0026#34; 和 \u0026#34;答案\u0026#34; df = pd.DataFrame(matches, columns=[\u0026#39;序号\u0026#39;, \u0026#39;问题\u0026#39;]) # 使用 slice() 方法将 content 列的字符串长度截断为 20 df[\u0026#39;问题\u0026#39;] = df[\u0026#39;问题\u0026#39;]#.str.slice(20) # print(\u0026#34;df=\u0026#34;, df) # 将数据保存到 Excel 文件中 df.to_excel(\u0026#39;./auto/问题列表.xlsx\u0026#39;, index=False) ######### 读取题库 ############## dic = [] # 读取单选题 df= pd.read_excel(\u0026#34;./auto/diction.xlsx\u0026#34;, sheet_name=\u0026#34;one\u0026#34;, usecols=[0,1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values #print(df) dic1= [(question, ans) for question, ans in value_array] dic.extend(dic1) # 读取多选题 df= pd.read_excel(\u0026#34;./auto/diction.xlsx\u0026#34;, sheet_name=\u0026#34;two\u0026#34;, usecols=[0,1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values dic1= [(question, ans) for question, ans in value_array] dic.extend(dic1) # 读取判断题 df= pd.read_excel(\u0026#34;./auto/diction.xlsx\u0026#34;, sheet_name=\u0026#34;bool\u0026#34;, usecols=[0,1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values dic1= [(question, ans) for question, ans in value_array] dic.extend(dic1) # dic = [(\u0026#39;修改后的《安全生产法》由习近平主席于2014年签署第十三号令予以公布，自2014年（）起施行。\u0026#39;, \u0026#39;C\u0026#39;),(),,,,] # print(\u0026#34;\\n\\n\\ndic=\u0026#34;, dic) ########### 进行查询 ############### res= [] num = 0 for match in matches: # 查询id, 查询题目 id = match[0] qu = match[1] # 题目过短, 自己进行处理 if(len(qu)\u0026lt;=5): res.append((id, \u0026#34;没有答案\u0026#34;)) continue flag = 0 # 开始从题库中查询 for allqu, ans in dic: if qu in allqu: res.append((id, ans)) flag =1 num+=1 break if(flag ==0): res.append((id, \u0026#34;没有答案\u0026#34;)) # print(\u0026#34;res=\u0026#34;, res) print(\u0026#34;共查询到\u0026#34;, num , \u0026#34;/\u0026#34;, len(res),\u0026#34;个结果\u0026#34;) # 输出为 execl, 一共两列 data = { \u0026#39;题号\u0026#39;: [item[0] for item in res], \u0026#39;答案\u0026#39;: [item[1] for item in res] } df=pd.DataFrame(data) df.to_excel(\u0026#34;./auto/查询结果.xlsx\u0026#34;,sheet_name=\u0026#34;Sheet1\u0026#34;, header=None, index=False) ############ 如果没有搜索到答案 ########### print(\u0026#34;下面请输入没有搜索到答案的问题\u0026#34;) for i in range(100): s = input(\u0026#34;请输入问题：(右键即黏贴)\\n\u0026#34;) for ques, ans in dic: if s in ques: print(ans,\u0026#34;\\n\\n\\n\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 import re import pandas as pd # 文本预处理 filepath = \u0026#34;./auto/question.txt\u0026#34; with open(filepath, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: text = f.read() text_new = text.replace(\u0026#39;（\u0026#39;, \u0026#39;(\u0026#39;) text_new = text_new.replace(\u0026#39;）\u0026#39;, \u0026#39;)\u0026#39;) with open(filepath, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(text_new) # 打开txt文件并读取内容 with open(\u0026#34;./auto/question.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: content = file.read() # 把题目导出来 pattern = r\u0026#39;(\\d+\\.+)(.+?)(?=(\\(|\\。|\\n|$))\u0026#39; matches = re.findall(pattern, content, flags=re.DOTALL) matches = [(ma[0], ma[1]) for ma in matches] print(\u0026#34;matches=\u0026#34;, matches) # 将数据转换成 DataFrame 格式 df = pd.DataFrame(matches, columns=[\u0026#39;序号\u0026#39;, \u0026#39;问题\u0026#39;]) # 使用 slice() 方法将 content 列的字符串长度截断为 20 df[\u0026#39;问题\u0026#39;] = df[\u0026#39;问题\u0026#39;] # .str.slice(20) # 将数据保存到 Excel 文件中 df.to_excel(\u0026#39;./auto/问题列表.xlsx\u0026#39;, index=False) # 读取题库 dic = [] excel_file = pd.ExcelFile(\u0026#34;./auto/diction.xlsx\u0026#34;) # 读取所有表格的数据 for sheet_name in excel_file.sheet_names: df = pd.read_excel(excel_file, sheet_name=sheet_name, usecols=[0, 1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values dic1 = [(question, ans) for question, ans in value_array] dic.extend(dic1) # 进行查询 res = [] num = 0 for match in matches: # 查询id, 查询题目 id = match[0] qu = match[1] # 题目过短, 自己进行处理 if len(qu) \u0026lt;= 5: res.append((id, \u0026#34;没有答案\u0026#34;)) continue flag = 0 # 开始从题库中查询 for allqu, ans in dic: if qu in allqu: res.append((id, ans)) flag = 1 num += 1 break if flag == 0: res.append((id, \u0026#34;没有答案\u0026#34;)) print(\u0026#34;共查询到\u0026#34;, num, \u0026#34;/\u0026#34;, len(res), \u0026#34;个结果\u0026#34;) # 输出为 execl, 一共两列 data = { \u0026#39;题号\u0026#39;: [item[0] for item in res], \u0026#39;答案\u0026#39;: [item[1] for item in res] } df = pd.DataFrame(data) df.to_excel(\u0026#34;./auto/查询结果.xlsx\u0026#34;, sheet_name=\u0026#34;Sheet1\u0026#34;, header=None, index=False) # 如果没有搜索到答案 print(\u0026#34;下面请输入没有搜索到答案的问题\u0026#34;) for i in range(100): s = input(\u0026#34;请输入问题：(右键即黏贴)\\n\u0026#34;) for ques, ans in dic: if s in ques: print(ans, \u0026#34;\\n\\n\\n\u0026#34;) 2 子文件夹内容移出并重命名为子文件夹名称 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @echo off setlocal enabledelayedexpansion rem 遍历当前文件夹下的每个子文件夹 for /d %%F in (*) do ( set \u0026#34;folder_name=%%~nxF\u0026#34; rem 将子文件夹下的文件重命名为文件夹名字 for %%G in (\u0026#34;%%~F\\*\u0026#34;) do ( move \u0026#34;%%~G\u0026#34; \u0026#34;%%~dpF\\!folder_name!_%%~nxG\u0026#34; ) rem 将子文件夹下的所有文件移动到当前文件夹下 move \u0026#34;%%~F\\*\u0026#34; . rem 删除空的子文件夹 rd \u0026#34;%%~F\u0026#34; ) 3 生成目录树 tree 命令用于在命令行界面显示目录结构树，它会递归地列出指定目录及其子目录中的所有文件和文件夹，并以树状结构进行展示。这个命令通常在命令行界面中使用，对于需要快速了解目录结构的情况非常有用。\n使用 tree 命令，你可以快速了解指定目录中的文件和文件夹的组织结构，包括子目录、文件名、文件大小等信息，从而更方便地进行文件管理和导航。\n常见用法示例：\ntree: 显示当前目录下的目录结构树。 tree /F: 显示目录结构树时，包括文件名。 tree /A: 显示所有文件和文件夹，包括隐藏文件和系统文件。 tree /L n: 限制目录层级，只显示前 n 层的目录结构。 tree /A /F \u0026gt; tree.txt: 将目录结构树输出到文本文件 tree.txt 中。 总的来说，tree 命令是一个方便的工具，用于在命令行界面快速查看和分析目录结构。\n1 tree \u0026gt;tree.txt D:. │ shilei_mymuduo.zip │ tree.txt │ __.DS_Store │ 推荐课程学习路径.pdf │ 目录树.bat │ 重写muduo库.pdf │\n└─视频 01项目介绍_ev.mp4 02.1_IO的阻塞和非阻塞_ev.mp4 02.2_IO的阻塞和非阻塞_勘误_ev.mp4 03 IO的同步和异步_IO的同步和异步_ev.mp4 04 阻塞\u0026amp;非阻塞\u0026amp;同步\u0026amp;异步总结_阻塞\u0026amp;非阻塞\u0026amp;同步\u0026amp;异步总结_ev.mp4 05 Linux的五种IO模型简介_Linux的五种IO模型简介_ev.mp4 06 Linux的五种IO模型详解_Linux的五种IO模型详解_ev.mp4 07 良好的网络服务器该怎么设计_良好的网络服务器该怎么设计_ev.mp4 08 Reactor模型详解_Reactor模型详解_ev.mp4\n1 DIR /S \u0026gt; dirs.txt D:\\正在看的视频\\cpp_手写C++ Muduo网络库项目-掌握高性能网络库实现原理 的目录\n2023/07/17 16:44 . 2023/07/17 16:44 .. 2023/07/17 16:44 0 dirs.txt 2023/07/15 15:10 4,224 shilei_mymuduo.zip 2023/07/17 16:39 3,464 tree.txt 2023/07/15 15:10 4,096 __.DS_Store 2023/07/15 15:10 97,797 推荐课程学习路径.pdf 2023/07/17 16:44 17 目录树.bat\n2023/07/15 16:20 466 子文件夹内容移出并重命名为子文件夹名称.bat 55 个文件 3,519,689,412 字节\n所列文件总数: 62 个文件 3,520,852,047 字节 5 个目录 53,564,571,648 可用字节\n自动提交脚本 只是一个博客, 提交的信息就不重要了, 只提交一个 时间信息就好 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @echo off setlocal enabledelayedexpansion REM 获取当前日期和时间 for /f \u0026#34;tokens=1-4 delims=/ \u0026#34; %%i in (\u0026#34;%date%\u0026#34;) do ( set year=%%l set month=%%j set day=%%k ) for /f \u0026#34;tokens=1-3 delims=:.\u0026#34; %%i in (\u0026#34;%time%\u0026#34;) do ( set hour=%%i set minute=%%j set second=%%k ) REM 构建提交信息 set commit_message=%year%-%month%-%day% %hour%:%minute%:%second% REM 添加文件到暂存区 git add . REM 提交代码，并包含日期和时间作为提交信息 git commit -m \u0026#34;%commit_message%\u0026#34; REM 推送到远程仓库 git push endlocal 自动生成 markdown 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash filename=$(date +\u0026#34;%Y-%m-%d-.md\u0026#34;) cat \u0026gt; \u0026#34;$filename\u0026#34; \u0026lt;\u0026lt; EOF --- layout: blog banana: true category: default title: date: $(date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) background: green tags: - default - memcache --- * content {:toc} EOF echo \u0026#34;文件已生成：$filename\u0026#34; 请帮我生成批处理代码，实现以下功能，将当前目录下的子文件夹中的 png 文件 复制到，当前目录的上一级的 assets 文件夹下子文件夹blog 文件夹下\n请帮我生成批处理代码，实现以下功能，将当前目录下的子文件夹中的 md 文件中的 “assets/” 修改为 “/assets/blog/”\n","date":"2024-04-05T17:05:44Z","permalink":"https://li54426.github.io/p/%E7%AD%94%E6%A1%88%E6%9F%A5%E6%89%BE/","title":"答案查找"},{"content":" content {:toc} 什么是node . js Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时，用于构建快速、可扩展的网络应用。它允许开发者使用 JavaScript 来编写服务器端的代码，而不仅仅局限于浏览器端的脚本。Node.js 的特点包括：\n事件驱动: Node.js 使用基于事件驱动的非阻塞 I/O 模型，这意味着它可以处理大量并发连接而不需要为每个连接创建新的线程，从而提高了性能和扩展性。 跨平台: Node.js 可以在多种操作系统上运行，包括 Windows、macOS 和各种 Linux 发行版。 轻量和高效: Node.js 采用了 Chrome V8 引擎，具有快速的代码执行速度，同时也是相对较轻量的运行时环境。 丰富的模块库: Node.js 提供了大量的内置模块和第三方模块，使得开发者可以方便地构建各种类型的应用程序，包括 Web 服务器、RESTful API、实时通讯应用等。 总之，Node.js 提供了一种高效、灵活的方式来构建服务器端的应用程序，使得开发者可以利用 JavaScript 的优势来开发各种类型的后端应用。\n","date":"2024-03-05T14:48:37Z","permalink":"https://li54426.github.io/p/%E5%9B%BE%E5%BA%8A/","title":"图床"},{"content":" content {:toc} 图片测试 这是上传到gitee云的 png 文件\n这是上传到gitee云的 webp 文件\n如何批量下载小红书的图片 首先下载油猴插件 其次安装该脚本Picviewer CE+ (greasyfork.org) 使用脚本下载图片 脚本使用 打开连接 按住g 右上角命令-下载当前所有 快捷键\n打开图库（加功能键为全局）9 打开大图a 打开当前图片C 打开放大镜观察m 下载d ","date":"2023-11-30T14:58:22Z","permalink":"https://li54426.github.io/p/%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%9A%84%E5%9B%BE%E7%89%87/","title":"如何批量下载小红书的图片"},{"content":" content {:toc} ","date":"2023-10-20T15:52:13Z","permalink":"https://li54426.github.io/p/%E7%AC%AC%E5%9C%BA%E5%91%A8%E8%B5%9B/","title":"第场周赛"},{"content":" content {:toc} 1 基础 1.1 不知道具体行数,直到文件末尾( EOF ) 输入样例:\n1 2 3 1 2 3 4 5 6 输入代码\n1 2 3 4 5 6 7 8 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; } } 1.2 有具体行数 输入样例:\n输入 n+1 行 第一行为n 接下来 n 行代表\u0026hellip;. 1 2 5 1 2 3 4 5 代码\n1 2 3 4 5 6 7 8 9 10 11 12 // 输入 n+1 行 // 第一行为xxx // 第二行为 xxx #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt; n; for(int i = 0; i\u0026lt; n; ++i){ // ... } } 2 string 2.1 多组数据, 空格分隔每个字符串 输入样例\n1 2 aaa bbb ccc aaa bbb ccc 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1, s2; while (cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2) { //... } return 0; } 2.2 输入一行为一个字符串 operator \u0026gt;\u0026gt; 有个问题, 遇到空格就停止 1 my name is li54426 1 2 3 4 5 6 7 8 9 #include\u0026lt;sstream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;iostream\u0026gt; int main{ string line; // 获取一整行数组 getline(cin, line); } 2.3 多组数据, 一行为一个字符串 数据格式为\n1 2 asd ddd ddd adsfa ddsf dfasd 1 2 3 4 5 6 7 int main(){ string line; while(getline(cin, line)) { //依靠geline读入一行 cout\u0026lt;\u0026lt; s\u0026lt;\u0026lt; endl; } } 2.4 输入一行字符串, 从中查找数字 输入格式\n1 \u0026#34;type:directReductionCoupon,price:50,isStackable:false\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 // \u0026#34;type:directReductionCoupon,price:50,isStackable:false\u0026#34; // 需要分离出来数字等 int main(){ string s; cin\u0026gt;\u0026gt; s; int base = ss.find(\u0026#34;price\u0026#34;); int end = ss.find(\u0026#34;,\u0026#34;, base); string numstr = ss.substr(base+6 , end- base-6); double price = stod(numstr ); } 3 进阶\u0026mdash;stringstream 的使用 3.1 输入方式为每行一个数组 输入样例\n1 2 3 1 2 3 4 5 0 0 0 0 0 代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;sstream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;iostream\u0026gt; int main{ vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; tree; string line; while(getline(cin, line)) { //依靠geline读入一行 stringstream ss(line); //每行先读入字符串，然后再区分每个数字 int num; int sum=0; vector\u0026lt;int\u0026gt; nums; nums.clear(); while(ss \u0026gt;\u0026gt; num){ nums.push_back(nums); } tree.push_back(nums); } } 3.2 输入方式为每行一个数组, 数字之间用逗号分隔 输入样例\n1 2 1,2,3 4,5,6 代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 1,2,3 // sum = 6 #include\u0026lt;sstream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;iostream\u0026gt; int main(){ string line; while(getline(cin, line) ) { //依靠geline读入一行 stringstream ss(line); //每行先读入字符串，然后再区分每个数字 int num; int sum=0; while(ss\u0026gt;\u0026gt; num){ // 将逗号输出出去 ss.get(); sum += num; } //计算总和 cout\u0026lt;\u0026lt; \u0026#34;sum = \u0026#34;\u0026lt;\u0026lt; sum\u0026lt;\u0026lt; endl; } } string流类基础 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 输入流 stringstream ss; ss \u0026lt;\u0026lt; \u0026#34;GodFishhh\u0026#34;; // 输出为字符串形式 cout \u0026lt;\u0026lt; ss.str() \u0026lt;\u0026lt; endl; // 偷看下一个字符, 流内还有字符 // \u0026#34;asdfasdf\u0026#34;, 哪怕运行一万次, 也是输出 a int peek(); // 获取字符 int get(); ostringstream oss; oss \u0026lt;\u0026lt; \u0026#34;GodFishhh and AFish\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 20030331 \u0026lt;\u0026lt; endl; // 成员函数str()的无参数形式 cout \u0026lt;\u0026lt; oss.str() \u0026lt;\u0026lt; endl; // 成员函数str()的有参数形式 // oss.str(\u0026#34;with parameter\u0026#34;); oss.str(\u0026#34;after \u0026#34;); cout \u0026lt;\u0026lt; oss.str() \u0026lt;\u0026lt; endl; ss \u0026lt;\u0026lt; \u0026#34;AFish\u0026#34;\u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ss.str(); // 清空 ss.clear(); ","date":"2023-10-05T16:29:20Z","permalink":"https://li54426.github.io/p/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/","title":"ACM输入输出总结"},{"content":" content {:toc} 论文降重 你是一个期刊收录系统,你熟练使用文本相似度算法如余弦相似度,Jaccard,曼哈顿距离等,来判断原文与相似内容之间的相似度接下来,我将给你原文与相似内容.你需要给我两者的相似度结果,然后,你需要对原文进行改写,使相似度降低到-1,然后重新计算原文与相似内容的相似度最终,你会把修改后的原文给我以及他与相似内容的想似度\n原文内容: 智能车辆的任务并不是都可以卸载的，车辆任务按照其关键程度分为三类：关键任务（Crucial Tasks，CTs）、高优先级应用程序（High-Priority Tasks，HPTs）和低优先级应用程序（Low-Priority Tasks，LPTs）。\nCTs是和车辆安全相关的应用，是保证车辆和乘客安全的关键应用程序，如车辆控制、系统监控和事故预防等。由于CTs和安全紧密相关，因此享有最高的优先级，必须保留充足的计算资源给它，不能因为HPTs和LPTs的存在而影响CTs的正常运行，因此这类任务也不允许卸载，只允许在本地执行，不属于计算任务卸载的范畴。该类任务的实例是：车辆控制、碰撞预警、红绿灯警告、网上车辆诊断、道路湿滑检测等。\nHPTs包括与驾驶相关的应用和可选的安全增强应用，这类应用程序对车辆而言是重要但不是必须的，拥有较高的执行优先级，例如实时路径规划和路况提醒等。这类应用允许出现延迟或卸载失败的情况，但不能影响CTs。该类任务的实例是：地图导航、平视显示器、视野增强、车辆传感等。\nLPTs是一类为用户提供影音娱乐服务的应用程序，它的优先级较低，例如语音识别，它允许驾驶员发出各种声音命令，通过语音识别命令计算机做一些响应，而不会使驾驶员分心。该类任务的实例是：虚拟现实、语音识别、视频处理、在线游戏等。\nHPTs和IPTs已经被部署到越来越多的车辆上，由于HPTs和LPTs不会涉及到安全，因此可以将其进行卸载，来提高资源的利用率。\nprompt_论文润色 充当论文润色者（拿摘要部分举例）\n请你充当一名论文编辑专家，在论文评审的角度去修改以下论文，使其更加流畅，优美。下面是具体要求：\n能让读者快速获得文章的要点或精髓，让文章引人入胜；能让读者了解全文中的重要信息、分析和论点；帮助读者记住论文的要点 字数限制在 300 字以下 请你在摘要中明确指出您的模型和方法的创新点，强调您的贡献。 用简洁、明了的语言描述您的方法和结果，以便评审更容易理解论文 下文是论文的摘要部分，请你修改它：\n充当论文润色者（拿摘要部分举例）\n请你充当一名论文编辑专家，在论文评审的角度去修改以下论文，使其更加流畅，优美。下面是具体要求：\n能让读者快速获得文章的要点或精髓，让文章引人入胜；能让读者了解全文中的重要信息、分析和论点；帮助读者记住论文的要点 字数限制在 300 字以下 请你在摘要中明确指出您的模型和方法的创新点，强调您的贡献。 用简洁、明了的语言描述您的方法和结果，以便评审更容易理解论文 写研究进展 参考北大核心期刊,总结《车联网中的任务卸载算法》,写一篇5000字左右的专业学术论文,要求引用文献有中文和英文,不少于20篇.\n论文润色 润色指标：\n1 删除不必要的内容 2 加强段落之间的过渡 3 修正拼写和语法错误 4 优化段落结构 5 替换过时的词汇或短语 6 增加更多的细节和具体内容 7 澄清表达意思 8 调整字母大小写规范 9 提高段落可读性 10 替换文章中的垃圾词语\n通过模仿下面的的内容进行修改：\n","date":"2023-09-30T14:10:07Z","permalink":"https://li54426.github.io/p/gpt-%E6%8F%90%E7%A4%BA%E8%AF%8D/","title":"GPT 提示词"},{"content":" content {:toc} websocket 协议 WebSocket 是一种用于在 Web 浏览器和服务器之间进行双向通信的协议。它提供了实时性、高效性和可靠性，使得服务器可以主动推送数据给客户端，客户端也可以向服务器发送数据，实现了全双工通信。 当我们使用 HTTP协议时, 因为 http使用了 cs架构, 因此, 我们没有办法让服务器主动向客户推送消息, 如果我们想要主动推送消息, 只能通过更低层次 tcp 来进行双向的通信 特点\n双向通信 建立在 TCP 协议之上，服务器端的实现比较容易。 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 ","date":"2023-09-27T09:53:31Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} 10. 正则表达式匹配\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\n'.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n1 2 3 输入：s = \u0026#34;aa\u0026#34;, p = \u0026#34;a\u0026#34; 输出：false 解释：\u0026#34;a\u0026#34; 无法匹配 \u0026#34;aa\u0026#34; 整个字符串。 首先, 我们要明白这两个字符的作用是什么 .匹配任意一个字符 *有两个作用, 一个是擦除前面的字符(匹配零个前面的那一个元素), 或者是 多个前面的字符 能匹配 s[i] == p[j] || p[j] == '.' 看后面的字符是否为*,, 后面的字符是否为* 那么就会有两种情况,一种是擦除前面的字符, 另一种是多个字符 后面的字符不为* 那么, 就直接 dp(s, i+1, p, j+1); 不能匹配的话, 后面的字符为为*, *发挥擦除的作用 否则返回 0 当匹配完毕后, 如果 p 有多余的字符, 看看是否能够擦除字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: bool isMatch(string s, string p) { // s is long , p is short return dp(s, 0, p, 0); } bool dp(string \u0026amp;s, int i, string \u0026amp;p, int j){ // * 的作用可以复制, 也可以擦除 int len1 = s.size(), len2= p.size(); if(i\u0026lt; len1 \u0026amp;\u0026amp; j\u0026lt; len2){ if(s[i] == p[j] || p[j] == \u0026#39;.\u0026#39;){ // 特殊情况 if(j\u0026lt; len2-1 \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39;){ // cout\u0026lt;\u0026lt; \u0026#34;s[i] == p[j] || p[j] == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39; \u0026#34;\u0026lt;\u0026lt; \u0026#34;i=\u0026#34;\u0026lt;\u0026lt; i\u0026lt;\u0026lt; \u0026#34;\\tj=\u0026#34;\u0026lt;\u0026lt;j \u0026lt;\u0026lt; endl; return dp(s, i+1, p, j) || dp(s, i, p, j+2); }else{ return dp(s, i+1, p, j+1); } }else{ if(j\u0026lt; len2 -1 \u0026amp;\u0026amp; p[j+1] ==\u0026#39;*\u0026#39;){ return dp(s, i, p, j+2); }else{ return 0; } } }else if(i == len1){ while(j\u0026lt; len2-1 \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39;){ j+=2; } return j == len2; } return 0; } }; ","date":"2023-09-23T15:01:50Z","permalink":"https://li54426.github.io/p/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","title":"字符串匹配"},{"content":" content {:toc} 数值类型的问题 整型与浮点型 在 C++ 中，当一个浮点数和一个整数进行乘法运算时，整数会被隐式地转换成与浮点数相同的类型，然后进行乘法运算。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void test1(){ float f=3.5; int m =6; long k=21; cout\u0026lt;\u0026lt; \u0026#34;k/2=\u0026#34;\u0026lt;\u0026lt; k/2\u0026lt;\u0026lt; endl; double ss=f * m + k/2; cout\u0026lt;\u0026lt;\u0026#34;ss=\u0026#34;\u0026lt;\u0026lt; ss\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt; \u0026#34;m * f =\u0026#34; \u0026lt;\u0026lt; m* f\u0026lt;\u0026lt; endl; } // 输出结果如下 // k/2=10 // ss=31 // m * f =21 // sizeof a = 12 整型与大整形 在 C++ 中，当一个表达式中同时包含 int 和 long long 类型时，会发生类型转换的情况如下：\n若参与运算量的类型不同，则先转换成同一类型，然后进行运算。 转换按数据长度增加的方向进行，以保证精度不降低。如 int 型和 long 型运算时，先把 int 量转成 long 型后再进行运算 1 2 3 4 5 6 7 8 9 10 11 12 13 void test1(){ int m =6; long k=21; cout\u0026lt;\u0026lt; \u0026#34;sizeof(int) = \u0026#34;\u0026lt;\u0026lt; sizeof(int)\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;sizeof= int + long= \u0026#34;\u0026lt;\u0026lt; sizeof(m + k)\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;sizeof = long + int= \u0026#34;\u0026lt;\u0026lt; sizeof(k + m)\u0026lt;\u0026lt; endl; } sizeof(int) = 4 sizeof= int + long= 8 sizeof = long + int= 8 整型与参数模板 如果在使用模板函数时, 可以设置初值为 long long类型 例如 0LL 1 accumulate(nums.begin(), nums.end(), 0LL); 数位补足 1 2 3 4 5 6 7 8 9 10 11 void test2(){ union{ char name[10]; int n; }a; cout\u0026lt;\u0026lt; \u0026#34;sizeof a = \u0026#34;\u0026lt;\u0026lt; sizeof a \u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; sizeof (int) \u0026lt;\u0026lt;endl; } // sizeof a = 12 // sizeof int = 4 string 与 char * char *赋值 当你尝试将一个字符串字面值（例如：\u0026ldquo;test\u0026rdquo;）赋值给一个字符数组时，会发生错误。这是因为字符串字面值在 C++ 中被视为一个常量字符数组，并且具有固定的大小，无法直接赋值给一个已经定义的字符数组。 a = 'c' 也是错误的, 必须是 a[0] = 'c'; 1 2 3 4 5 6 7 8 9 10 11 void test_string_char(){ char a[5]; // 错误示例 a =\u0026#34;test\u0026#34;; // 正确示例 strcpy(a, \u0026#34;test\u0026#34;); cout\u0026lt;\u0026lt; a\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;success\u0026#34;\u0026lt;\u0026lt; endl; } 作用域 变量的作用域 不同作用域内可以重复定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; using namespace std; int n = 0; int main(){ int n = 1; cout\u0026lt;\u0026lt; \u0026#34;全局n=\u0026#34;\u0026lt;\u0026lt; ::n\u0026lt;\u0026lt; endl; int n = 1; cout\u0026lt;\u0026lt; \u0026#34;函数内n=\u0026#34;\u0026lt;\u0026lt; n\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; { int n = 2; cout\u0026lt;\u0026lt; \u0026#34;括号内n=\u0026#34;\u0026lt;\u0026lt; n\u0026lt;\u0026lt; endl;; } } // 全局n=0 // 函数内 n=1 // 括号内 n=2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: bool isMatch(string s, string p) { // s is long , p is short return dp(s, 0, p, 0); } bool dp(string \u0026amp;s, int i, string \u0026amp;p, int j){ // * 的作用可以复制, 也可以擦除 int len1 = s.size(), len2= p.size(); if(i\u0026lt; len1 \u0026amp;\u0026amp; j\u0026lt; len2){ if(s[i] == p[j] || p[j] == \u0026#39;.\u0026#39;){ // 特赦情况 if(j\u0026lt; len2-1 \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39;){ // cout\u0026lt;\u0026lt; \u0026#34;s[i] == p[j] || p[j] == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39; \u0026#34;\u0026lt;\u0026lt; \u0026#34;i=\u0026#34;\u0026lt;\u0026lt; i\u0026lt;\u0026lt; \u0026#34;\\tj=\u0026#34;\u0026lt;\u0026lt;j \u0026lt;\u0026lt; endl; return dp(s, i+1, p, j) || dp(s, i, p, j+2); }else{ return dp(s, i+1, p, j+1); } }else{ if(j\u0026lt; len2 -1 \u0026amp;\u0026amp; p[j+1] ==\u0026#39;*\u0026#39;){ return dp(s, i, p, j+2); }else{ return 0; } } }else if(i == len1){ while(j\u0026lt; len2-1 \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39;){ j+=2; } return j == len2; } return 0; } }; ","date":"2023-09-22T21:08:05Z","permalink":"https://li54426.github.io/p/c-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/","title":"C++的一些基础问题"},{"content":" content {:toc} 模板推荐\nChinese English resume template 中英双语简历模板 - Overleaf, Online LaTeX Editor 中文简历模板（Chinese Resume Template） - Overleaf, Online LaTeX Editor 推荐使用以上两个简历, 知乎推荐的简历字体太大了, 不推荐使用\n1 简历原则： 简历模板要清晰、简洁！别用花里胡哨的格式, 双栏简历达咩 简历不超过一页纸 错别字和语病不要有、字体统一 不同岗位，不同要求，不同简历 2 基本信息 证件照: 最好用白底、灰底、蓝底的职业照/证件照，这样一来既不会让你的照片在简历上显得很突兀，同时会让HR更加有印象。 个人基本情况, 姓名, 性别, 年龄, 联系方式 学历, 学位, 专业 教育背景要有, 格式可以像 大学, 专业, 时间, 主修课程: 核心课程就可 信息要全, 电话, 邮箱, 籍贯等等 3 项目/ 实习经历 【建议】 项目经历是简历中非常重要的一部分，它能够展示你在实际工作中的能力和经验。如果你还没有项目经历，建议你尽快参与一些项目，可以是学校的实践课程、实习或者自己的个人项目。通过参与项目，你可以锻炼自己的团队合作能力、问题解决能力和项目管理能力，同时也能够丰富你的简历内容，提高竞争力。\n【示例】 以下是我简历中的项目经历：\n项目名称：在线商城网站开发\n项目描述：负责开发一个在线商城网站，包括用户注册登录、商品浏览购买、订单管理等功能。 - 职责：担任前端开发工程师，负责网站的页面设计和前端代码编写。 工作成果：成功完成网站的前端开发工作，实现了用户友好的界面和良好的用户体验。网站上线后，用户访问量增加了xx%，销售额提升了xx%。 项目名称：智能家居系统设计 - 项目描述：参与设计一个智能家居系统，包括家庭安防、智能控制等功能。 - 职责：担任软件工程师，负责系统的需求分析、系统设计和代码编写。 - 工作成果：成功完成系统的设计和开发工作，实现了远程监控、智能控制等功能。系统上线后，用户满意度提高了xx%，故障率降低了xx%。 3. 项目名称：数据分析与挖掘 - 项目描述：参与一个数据分析与挖掘项目，对大量的数据进行分析和挖掘，提取有价值的信息。 - 职责：担任数据分析师，负责数据清洗、特征提取和模型建立。 - 工作成果：成功完成数据分析和挖掘工作，提取出了关键指标和规律，并提供了有针对性的决策建议。项目完成后，公司的利润增长了xx%。 以上是我在简历中的项目经历，通过这些项目，我不仅提升了自己的技能和经验，也取得了一定的成绩和成就。 4 职业技能 (专业技能) 【建议】 职业技能是简历中非常重要的一部分，它能够展示你的专业能力和技术水平。对于已有的职业技能，建议你在描述时要更加具体和有针对性，可以提供一些相关项目经验或成果，以突出你的实际应用能力。另外，可以考虑添加一些与职位要求相关的技能，以提高简历的匹配度。\n计算机二级\u0026hellip;. 5 其他模块 语言能力 六级等 获奖经历 自我评价 兴趣爱好 所有的模板你都可以放心用，按你的经验，简历要尽量保证在一页以内。目前的简历内容比较少，有大量的留白，非常容易被pass，要补充内容尽可能将简历达到一页。如果当前的模块无法达到1页，想下有没有其他经历适合放到简历上。\n","date":"2023-09-10T19:19:59Z","permalink":"https://li54426.github.io/p/%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C%E6%95%99%E8%AE%AD/","title":"简历制作教训"},{"content":" content {:toc} 深入浅出零拷贝及应用 当我们读取文件时\n磁盘读取数据====\u0026gt;内核=====\u0026gt;应用程序\n这还伴随着 用户态 和 内核态 的转换, (数字越小, 权限越高)\n当从磁盘读取到, socket时\n磁盘读取数据====\u0026gt;内核=====\u0026gt;应用程序 应用程序====\u0026gt;内核=====\u0026gt;网卡 零拷贝的实现方式 DMA 传输\n直接内存访问（DMA）允许设备直接访问内存，绕过 CPU。 避免了 CPU 的介入，提高了数据传输速度。 文件描述符传递\n文件描述符传递是 UNIX 系统中实现零拷贝的方式之一。 sendfile 和 splice 系统调用是典型的例子。 ","date":"2023-08-24T16:12:16Z","permalink":"https://li54426.github.io/p/go_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%8F%8A%E5%BA%94%E7%94%A8/","title":"Go_深入浅出零拷贝及应用"},{"content":" content {:toc} 1 变量 函数外的每个语句都必须以关键字开始（var、const、func等） :=不能使用在函数外。 _多用于占位，表示忽略值。 Go 语言是一种静态类型的编程语言，它提供了以下基本类型：Go 语言要求标识符以一个字母或下划线开头，后面可以跟任意数量的字母、数字、下划线。不能使用关键字作为标识符\n布尔类型：bool 数字类型：int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64, complex64, complex128 字符串类型：string 字符类型：rune (用于表示 Unicode 字符) 错误类型：error 指针类型：*T (T 为任意类型) 数组类型：[n] T (n 为数组长度，T 为元素类型) 切片类型：[] T (T 为元素类型) 字典类型：map [K] V (K 为键类型，V 为值类型) 结构体类型：struct 接口类型：interface 函数类型：func 通道类型：chan T (T 为元素类型) 1.1 基础类型 类型不需要导入 可以使用 const修饰 短变量声明是一种简洁的变量声明方式，用于同时声明和初始化变量。但是这种方式只能在函数内部使用，不能在函数外部使用。当在函数外部声明变量时，只能使用 var 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var b, c int = 1, 2 var e float64 // 短变量声明 f := a // 同时声明多个变量 var i, j, k = 2, false, \u0026#34;asd\u0026#34; // 数组 var a [5]int b := [5]int{1, 2, 3, 4, 5} // 多维数组 var twoD [2][3]int 1.2 常量 常量的声明方式和变量差不多，区别在于常量需要用 const 关键字修饰，不能使用:= 进行声明。 1 const num int = 555 1.3 string string 类型用于表示文本字符串。它是一种不可变的序列，由多个 Unicode 字符组成，并使用双引号 \u0026quot; 或反引号 ` 包围。 由于字符串是不可变的，如果需要对大量的字符串进行拼接操作，最好使用 bytes.Buffer 或 strings.Builder 类型，以提高性能和效率。 Go 语言中要定义一个多行字符串时，就必须使用反引号字符 1 2 3 4 s1:= `第一行 第二行 第三行` fmt.Println(s1) 方法 len(str) 求长度 +或ft.Sprintf 拼接字符串 strings.Split 分割 strings.contains 判断是否包含 strings.HasPrefix, strings.HasSuffix 前缀/后缀判断 strings.Inde(), strings.LastIndex0 子串出现的位置 strings.Join(a[]string,sepstring) join妈 string包和 strings包有什么区别和联系\nstrings 包是 Go 语言的标准库，它提供了一些与字符串相关的函数和方法，例如字符串拼接、替换、切片等。\nstring 包是 Go 语言的基础数据类型，它表示一个固定长度的字符序列。与其他语言中的字符串不同，Go 语言中的字符串是不可变的，一旦被创建，就不能修改。\n1.4 字符 组成每个字符串的元素叫做 “字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号 (’) 包裹起来\nGo 语言的字符有以下两种：\nuint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。 rune 类型，代表一个 UTF-8 字符。 1 2 a :=\u0026#39;中\u0026#39; b :=\u0026#39;x\u0026#39; 要修改字符串，需要先将其转换成 [] rune 或 [] byte，完成后再转换为 string。无论哪种转换，都会重新分配内存，并复制字节数组。\n1 2 3 4 5 6 7 8 9 10 func changestring(){ s1 := \u0026#34;big\u0026#34; // 强制类型转换 bytes1 := []byte(s1) bytes1[0]=\u0026#39;p fmt.Println(string(bytes1)) s2:=\u0026#34;白萝卜\u0026#34; runes2:=[]rune(s2) runes2[0]=\u0026#39;红fmt. Println(string(runes2)) } 1.5 数值类型 整数类型分为：\n有符号数：int、int8、int16、int32 (rune)、int64 无符号数：uint、uint8 (byte)、uint16、uint32、uint64、 其中，uint8 就是我们熟知的 byte 型，int16 对应 C 语言中的 short 型，int64 对应 C 语言中的 long 型。 类型 描述 uint8 无符号8位整型(o到255) uint16 无符号16位整型(o到65535) uint32 无符号32位整型(o到4294967295) uint64 无符号64位整型(o到18446744073709551615) int8 有符号8位整型(-128到127) inti6 有符号16位整型(-32768到32767) int32 有符号32位整型(-2147483648到2147483647) int64 有符号64位整型(-9223372036854775808到92233部@6谱 1.6 类型转换 使用表达式 T(v) 将变量 v 的值的类型转换为 T。注意是转换的是 变量的值，变量本身的类型不变。\n1 c := int(52.6) 1. 生命周期 Go 语言中没有像其他一些编程语言（如 C++、Java 等）中那样的块级作用域。也就是说，Go 语言中没有在大括号内定义的生命周期。\n在 Go 语言中，变量的生命周期是由它们的作用域决定的。Go 语言中的作用域分为两种：文件作用域和函数作用域。在文件作用域中，变量的生命周期从文件开始到文件结束。在函数作用域中，变量的生命周期从函数开始到函数结束。\n因此，如果您想在一个大括号内定义一个变量的生命周期，您需要使用嵌套的函数或者其他的代码结构来实现。例如，您可以使用一个内部函数来定义一个变量的生命周期，并在外部函数中调用它。\n总的来说，虽然 Go 语言中没有块级作用域，但它提供了其他的方法来控制变量的生命周期，并且这些方法通常更加简单和直观。\n2 高级变量 引用类型 Go 语言中的引用类型是指一种特殊的变量类型，它存储的不是值本身，而是对值的一个引用。当您使用引用类型变量时，实际上是在操作它所引用的值。\nGo 语言中有三种引用类型：\n指针：指针是一种特殊的变量类型，它存储的是一个值的地址。通过指针，您可以操作它所指向的值。 切片：切片是一种引用类型，它存储的是一组值的引用。通过切片，您可以操作它所引用的一组值。 字典：字典是一种引用类型，它存储的是一组键值对的引用。通过字典，您可以操作它所引用的一组键值对。 与值类型不同，引用类型变量存储的是对值的引用，而不是值本身。这意味着，如果您修改了引用类型变量所引用的值，那么其他引用该值的变量也会看到修改的效果。\n数组 array 类型是值类型，那么在使用相同的类型的变量初始化另一个变量时，两个变量互不影响\n数组 数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。 访问越界，如果下标在数组合法范围之外，则触发访问越界，会panic 传递数组到函数中时，实际上是传递了数组的副本。因此，在函数中修改数组的值不会影响原数组的值。 1 2 3 4 5 6 7 8 9 10 a := [3]int{1, 2} // 未初始化元素值为 0。 b := [...]int{1, 2, 3, 4} // 通过初始化值确定数组长度。 func printArr(arr *[5]int) { arr[0] = 10 for i, v := range arr { fmt.Println(i, v) } } 切片\u0026mdash;可变的数组 声明切片和声明数组类似，但是不指定长度： append, len, cap是全局函数, 不是方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // 声明一个 int 类型, 名为 a的切片 // a == nil var a []int // b != nil, 以下两个形式等价 b := []int {} var s1 []int = []int{} // 可以在声明的时候直接初始化 var a = []int {1, 2, 3, 4} // 短变量声明 a := []int {1, 2, 3, 4} // 使用 make 函数可以在创建切片时指定长度和容量。 // 创建一个 //[0 0 0 0 0] len = 5 cap = 5 a := make([]int, 5) // 从数组或者切片中 获取切片 // 前闭后开 [), 因此相减就是数组长度 a := [5]string {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} //数组 b := []int {1, 2, 3, 4} //切片 sliA := a[2:4] // [c d] sliB := b[1:3] // [2 3] // 获取长度 len (a) // 获取容量 cap(s) // 多维切片 ss := [][]int { []int {1, 2, 3}, //切片元素的类型可以省去 []int {4, 5, 6}, []int {7, 8, 9}, } // 复制切片 // dst 是目标切片，src 是源切片，该函数会将 src 中的元素复制到 dst 中，并返回复制的元素个数（该返回值是两个切片长度中的小值） func copy(dst []Type, src []Type) int 切片的容量 前面提到：切片为我们提供了 “动态数组”。但该 “动态数组” 并不是真正意义上的能扩展长度的动态数组。\n切片并不存储任何数据，它只是一个引用类型，切片总是指向一个底层的数组，描述这个底层数组的一段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func main() { array := [5]string {\u0026#34;aa\u0026#34;, \u0026#34;bb\u0026#34;, \u0026#34;cc\u0026#34;, \u0026#34;dd\u0026#34;, \u0026#34;ee\u0026#34;} //数组 fmt.Println(array) //[aa bb cc dd ee] slice1 := array[0:2] //切片1 slice2 := array[1:3] //切片2 slice3 := array[2:5] //切片3 fmt.Println(slice1) //[aa bb] fmt.Println(slice2) //[bb cc] fmt.Println(slice3) //[cc dd ee] slice1[0] = \u0026#34;xx\u0026#34; //修改切片1中的值 slice2[1] = \u0026#34;yy\u0026#34; //修改切片2中的值 slice3[2] = \u0026#34;zz\u0026#34; ////修改切片3中的值 fmt.Println(array) //[xx bb yy dd zz] fmt.Println(slice1) //[xx bb] fmt.Println(slice2) //[bb yy] fmt.Println(slice3) //[yy dd zz] } 切片扩容过程 在 Go 语言中，当切片添加的元素数量超过了底层数组的容量时，切片会发生扩容，即系统会创建一个新的底层数组，并将原来的元素复制到新数组中。这是由于切片的底层数组具有自动扩容的特性。\n具体来说，当切片的容量不足以容纳新添加的元素时，Go 语言会按照一定的策略（通常是成倍增加容量）重新分配底层数组，并将原来的元素复制到新的底层数组中。这意味着在添加元素过程中，可能会涉及内存的重新分配和数据的复制操作，因此可能会导致性能上的开销。\n需要注意的是，扩容过程不会改变原来切片的引用，而是返回一个新的切片，因此我们在使用切片时需要使用扩容后的新切片来接收扩容后的结果。\n初始切片 切片的零值是 nil，当声明一个切片，但不出初始化它，该切片便为 nil 切片。nil 切片的长度和容量为 0 且没有底层数组。 1 2 3 4 5 6 7 func main() { var s []int fmt.Println(s, len(s), cap(s)) if s == nil { fmt.Println(\u0026#34;s切片是nil切片\u0026#34;) } } map 无序的 Go 语言中使用 for range 遍历 map。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 var mp = map[string]int {\u0026#34;数学\u0026#34;:100, \u0026#34;语文\u0026#34;:90, \u0026#34;Go\u0026#34;:100} // 可以先声明再使用，注意这样需要使用 make 函数初始化后才能使用： var scores map[string]int scores = make(map[string]int) // 建议这样直接写 m := make(map[string]int) // 增加键值对 // 当 key 不存在时为增加，当 key 存在时为修改 scores[\u0026#34;数学\u0026#34;] = 100 // 删除键值对 delete(scores, \u0026#34;语文\u0026#34;) // 查找 // 如果查找的 key 不存在，则会返回 value 类型的 “零值”： score, exist := scores[\u0026#34;数学\u0026#34;] //使用两个返回值 fmt.Println(score, exist) //100 true score1 := scores[\u0026#34;语文\u0026#34;] //使用一个返回值 fmt.Println(score1) //90 score2, exist2 := scores[\u0026#34;Java\u0026#34;] //查找不存在的key fmt.Println(score2, exist2) //0 false // 获取数量 keyNum := len(scores) //获取scores这个map中key的数量 // Go 语言中使用 for range 遍历 map。 for key, value := range scores { fmt.Println(key, value) } // 只想遍历 key for k := range scoreMap { fmt.Println(k) } map 也是引用 map 也是引用类型，则意味着，如果有几个 map 同时指向一个底层 map，其中一个 map 改变某个键值对，那么其他的也会做出同样的改变（因为底层 map 变了）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { map0 := make(map[string]string) //底层map0 map0[\u0026#34;name\u0026#34;] = \u0026#34;XingXiaoguan\u0026#34; //增加一个键值对 //map1 map2 引用map0 map1 := map0 map2 := map0 fmt.Println(map0[\u0026#34;name\u0026#34;], map1[\u0026#34;name\u0026#34;], map2[\u0026#34;name\u0026#34;]) //都是XingXiaoguan map1[\u0026#34;name\u0026#34;] = \u0026#34;XingRenGuanXue\u0026#34; //改变map1的name对应的值 fmt.Println(map0[\u0026#34;name\u0026#34;], map1[\u0026#34;name\u0026#34;], map2[\u0026#34;name\u0026#34;]) //全部变为XingRenGuanXue } 指针 和 new 和 C中的很像 区别于 C/C++ 中的指针，Go 语言中的指针不能进行偏移和运算，是安全指针。 当一个指针被定义后没有分配到任何变量时，它的值为 nil 1 2 3 4 5 6 7 8 9 // p == nil var p *int var a int = 66 //a是值为66的int变量 p = \u0026amp;a //将a的地址赋给指针p var b = *p //根据p中的值找到a，将其值赋给b fmt.Println(b) //66 *p = 99 //根据p中的值找到a，改变a的值 fmt.Println(a) //99 new 是一个内置的函数 并且创建后内存对应的值为类型零值 1 2 3 4 5 6 func new(Type) *Type p := new(dog) fmt.Printf(\u0026#34;%T\\n\u0026#34;, p) //*main.dog fmt.Println(p) //\u0026amp;{ 0} fmt.Println(*p) //{ 0} make make 也是用于内存分配的，区别于 new，它只用于 slice、map 以及 chan 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型 是内置函数 1 2 3 4 func make(t Type, size ...IntegerType) Type var b map[string]int b = make(map[string]int, 10) 结构体 struct 在方法中传参时是值类型而非引用类型，所以当需要在方法内改变这个对象的字段值时，应该使用的是 struct 变量的指针，而非 struct 变量。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type 结构体名字 struct { 字段名1 类型1 字段名2 类型2 ... } type man struct { name string age int } var a human a.name = \u0026#34;zhang san\u0026#34; a.age = 14 // 直接赋值 // 按顺序赋值 a :={\u0026#34;zhagnsan\u0026#34;, 14} a := {age:3, name:\u0026#34;zhang san\u0026#34;} 结构体指针 1 2 3 4 5 6 7 d := dog{\u0026#34;哮地犬\u0026#34;, 2} p := \u0026amp;d //获取到d的地址 n := (*p).name fmt.Println(n) //哮天犬 // 上面的方式比较麻烦, Go 语言提供了隐式间接引用： n := p.name //这样也行 fmt.Println(n) 结构体嵌套 一个结构体也可以作为另一个结构体的字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import \u0026#34;fmt\u0026#34; type score struct { English int Chinese int } type people struct { name string age int grades score } func main () { a := people {\u0026#34;zhangsan\u0026#34;, 18, score {English: 90, Chinese: 95}} fmt.Println (a) //{zhangsan 18 {90 95}} fmt.Println (a.grades.English) //90 fmt.Println (a.grades.Chinese) //95 } 使用匿名字段, 它是指只提供类型，不写字段名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type score struct { English int Chinese int } type people struct { name string age int score } func main () { a := people {\u0026#34;zhangsan\u0026#34;, 18, score {English: 90, Chinese: 95}} fmt.Println (a) //{zhangsan 18 {90 95}} fmt.Println (a.English) //90 fmt.Println (a.Chinese) //95 } interface 为了保护你的 Go 语言职业生涯，请牢记接口（interface）是一种类型。 Go 语言中的接口（interface type）是一种抽象的数据类型，它定义了一组方法签名，但不具体实现这些方法。接口只定义了方法的外部行为，而不关心方法的内部实现。\n在 Go 语言中，接口是通过关键字 interface 来定义的。一个接口定义了一组方法签名，这些方法签名必须在任何实现该接口的类型中实现。\n1 2 3 4 5 type 接口类型名 interface{ 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … } 例如，下面是一个简单的接口定义：\n1 2 3 4 type MyInterface interface { Method1() Method2() } 这个接口定义了两个方法签名 Method1 和 Method2。任何实现这个接口的类型都必须实现这两个方法。\n在 Go 语言中，接口是一种类型，可以像其他类型一样被使用。您可以定义变量、常量和数组等，它们的类型都是接口。\n例如，下面是一个使用接口的示例：\n1 2 3 4 5 6 7 8 9 10 11 type MyImplementation struct {} func (m MyImplementation) Method1() { // implementation of Method1 } func (m MyImplementation) Method2() { // implementation of Method2 } var myVar MyInterface = MyImplementation{} 在这个示例中，我们定义了一个类型 MyImplementation，它实现了接口 MyInterface。我们还定义了一个变量 myVar，它的类型是接口 MyInterface，并将其赋值为一个 MyImplementation 类型的值。\n通过使用接口，我们可以将不同的类型统一起来，使它们能够以相同的方式进行交互。这有助于实现代码的模块化和可复用性。\n总之，接口是 Go 语言中一种非常重要的类型，它们可以帮助您实现抽象和多态性，提高代码的灵活性和可复用性。\nGo 语言中的接口类似于 C++ 中的接口类的概念。在 C++ 中，接口类是一个抽象基类，它定义了一组纯虚函数，这些函数需要在任何继承该接口类的类中实现。与 C++ 中的接口类类似，Go 语言中的接口也是一种抽象的数据类型，它定义了一组方法签名，但不具体实现这些方法。任何类型都可以实现一个或多个接口，从而使其具有接口定义的方法。\n与 C++ 中的接口类不同的是，Go 语言中的接口不能继承，也不能包含数据成员。Go 语言中的接口更加简单和轻量级，它们只定义了方法签名，而没有任何其他的实现细节。这使得 Go 语言中的接口更加灵活和易于使用，同时也使得代码更加简洁和易于维护。\n流程控制\u0026mdash; 没有括号 与 下划线 if 1 2 3 4 5 6 if { // 必须和 if 在同一行 }else{// else 必须在 { 后面 } } if 还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，代码如下：\n1 2 3 4 if err := Connect(); err != nil { fmt.Println(err) return } 登录后复制\nfor 1 2 3 for 初始化语句; 条件表达式; 后置语句 { //循环体代码 } for 循环的另一种形式，在某种数据类型的区间（range）上遍历，如字符串或切片。\n1 2 3 4 5 6 7 8 func main() { s, sep := \u0026#34;\u0026#34;, \u0026#34;\u0026#34; for _, arg := range os.Args[1:] { s += sep + arg sep = \u0026#34; \u0026#34; } fmt.Println(s) } switch 1 2 3 4 5 6 7 8 9 10 11 12 switch 变量 { case 选项1 : //操作1代码 case 选项2 : //操作2代码 case 选项3 : //操作3代码 case 选项n: //操作n代码 default : //默认操作 } 下划线 import 下划线（如：import _ hello/imp）的作用：当导入一个包时，该包下的文件里所有 init () 函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行 init () 函数而已。这个时候就可以使用 import引用该包。即使用【import _ 包路径】只是引用该包，仅仅是为了调用 init () 函数，所以无法通过包名来调用包中的其他函数。 代码中: 忽略这个变量. 函数和方法 函数 类型在变量名后 如果你有多个参数的类型相同，你可以进行简写，只需要在这几个相同的参数最后写一遍类型即可。 函数可以有 0 个或多个返回值。和参数不同，有几个返回值就写几个返回值类型，不能简写。 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func add(x int, y int) int { return x + y } func main() { fmt.Println(add(1, 2)) } 通过给返回值进行命名，使用空 return 语句，这样会直接返回已命名的返回值。\n1 2 3 4 5 func sumAndDiff(x, y int) (sum int, diff int) {//提前命名返回值 sum = x + y diff = x - y //返回值在函数中被初始化 return //返回值已经初始化了，不需要再在return语句中写变量了 } 导出 在 Go 语言中，如果一个名字以大写字母开头，那么它就是已导出的，这意味着别的包可以使用它。（相当于 Java 中的 public 的作用） 比如我们常用的打印函数 fmt.Println(...)，可以看到 Println() 的首字母是大写的，所以我们能够导入 fmt 包后使用该方法。 函数重载 Go 语言支持函数重载，但是它的方式与其他语言有所不同。\n在 Go 语言中，函数重载是通过不同的函数签名来实现的。函数签名是指函数的名称、参数类型和顺序。如果两个函数具有不同的函数签名，那么它们就可以被认为是重载的函数。\n例如：\n1 2 3 4 5 6 7 func myFunction(a int) { // implementation here } func myFunction(a int, b string) { // implementation here } 在这个例子中，myFunction 函数被重载了两次，一次只有一个整数参数，另一次有一个整数参数和一个字符串参数。\n需要注意的是，Go 语言中函数的返回类型并不是函数签名的一部分，因此不能通过返回类型来实现函数重载。\n总的来说，Go 语言的函数重载是通过函数签名来实现的，这与其他语言有所不同，但是它仍然是一种非常强大的功能，可以帮助我们更好地组织代码。\n方法 Go 中也有类似于面向对象中方法的概念，也叫方法（method），这种方法其实是一种特殊的函数（function）—— 带有接收者（receiver）的函数。 通过. 可以调用方法 通过交换函数名以及 函数参数来区分函数以及方法 有点类似于传入指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; type dog struct { name string } func (d dog) say() {//方法 fmt.Println(d.name + \u0026#34; 汪汪汪。。。方法\u0026#34;) } func main() { d := dog{\u0026#34;哮天犬\u0026#34;} d.watchDoor() } 可以实现一种多态性\n相同的方法名, 但是不同的对象(结构体)调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import \u0026#34;fmt\u0026#34; type dog struct { name string } type cat struct { name string } type rabbit struct { name string } // 使用 函数来实现, 需要不同的函数名 func dogSay(d dog) { fmt.Println(d.name + \u0026#34; 汪汪汪。。。函数\u0026#34;) } func catSay(c cat) { fmt.Println(c.name + \u0026#34; 喵喵喵。。。函数\u0026#34;) } func (d dog) say() { fmt.Println(d.name + \u0026#34; 汪汪汪。。。方法\u0026#34;) } // 使用方法来实现, 相同的函数名就可以 func (c cat) say() { fmt.Println(c.name + \u0026#34; 喵喵喵。。。方法\u0026#34;) } func (r rabbit) say() { fmt.Println(r.name + \u0026#34; 吱吱吱。。。方法\u0026#34;) } func main() { d := dog{\u0026#34;哮天犬\u0026#34;} c := cat{\u0026#34;加菲猫\u0026#34;} r := rabbit{\u0026#34;玉兔\u0026#34;} d.say() //调用 c.say() r.say() } 指针和方法 接收者使用指针传的是引用，不使用指针传的是值拷贝。\n如果函数的参数是一个指针参数，那么该函数就必须接收一个指针才行，如果是值则报错：如果函数的参数是值，而不是指针，那么该函数必须接受值，否则会报错：\n而如果方法的接收者是一个指针，那么该方法被调用时，接收者既可以是指针，又可以是值：如果方法的接收者是一个值，那么该方法被调用时，接收者既可以是值，又可以是指针：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \u0026#34;fmt\u0026#34; type dog struct { name string } // 修改成功 func (d *dog) rename(name string) { d.name = name fmt.Println(\u0026#34;方法内:\u0026#34; + d.name) } // 修改不成功 func (d dog) rename1(name string) { d.name = name fmt.Println(\u0026#34;方法内:\u0026#34; + d.name) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 必须是 double(\u0026amp;i) func double(x *int) { *x = *x * 2 } // d.rename(\u0026#34;小黑黑\u0026#34;) func (d *dog) rename(name string) { d.name = name fmt.Println(\u0026#34;方法内:\u0026#34; + d.name) } d := dog{\u0026#34;哮天犬\u0026#34;} p := \u0026amp;d p.rename1(\u0026#34;小红红\u0026#34;) func (d dog) rename1(name string) { d.name = name fmt.Println(\u0026#34;方法内:\u0026#34; + d.name) } 类型选择 x.(type) 的语法只能在 switch 语句内部使用，用于判断 x 的类型。它会返回一个特殊的类型 type，表示 x 的实际类型。 1 2 3 4 5 6 7 8 9 10 11 12 switch value := x.(type) { case string: fmt.Printf(\u0026#34;%s是个字符串。开心\u0026#34;, value) case int: value *= 2 fmt.Printf(\u0026#34;翻倍了，%d是个整数。哈哈\u0026#34;, value) case human: fmt.Println(\u0026#34;这是个结构体。\u0026#34;, value) default: fmt.Printf(\u0026#34;前面的case都没猜对，x是%T类型\u0026#34;, value) fmt.Println(\u0026#34;x的值为\u0026#34;, value) } 错误处理 panic panic 语句用于引发一个运行时错误，并使程序崩溃。在 Golang 中，panic 语句的语法如下：\n1 2 go 复制代码panic(\u0026#34;error message\u0026#34;) 其中，\u0026ldquo;error message\u0026rdquo; 是一个字符串，用于描述错误信息。当程序执行到 panic 语句时，会引发一个 panic 错误，并将程序崩溃。\nrecover recover 语句用于恢复程序的执行，如果程序发生了 panic 错误，可以使用 recover 语句来捕获该错误，并进行相应的处理。在 Golang 中，recover 语句的语法如下：\nrecover 语句用于恢复程序的执行，如果程序发生了 panic 错误，可以使用 recover 语句来捕获该错误，并进行相应的处理。在 Golang 中，recover 语句的语法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 go复制代码package main import \u0026#34;fmt\u0026#34; func main() { defer func() { if err := recover(); err != nil { fmt.Println(\u0026#34;recover error:\u0026#34;, err) } }() panic(\u0026#34;panic error\u0026#34;) } 输出结果为：\n1 2 go 复制代码recover error: panic error 在上面的示例中，使用 defer 语句来定义一个匿名函数，用来捕获 panic 错误，并输出错误信息。\nerror 接口 接口签名, 只有一个 Error() 方法，返回一个 string，用来备注错误信息。任何实现了这个方法的结构体都实现了 error 接口。\n1 2 3 type error interface { Error() string } 实例分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Go1.12/src/net/net.go 的 AddrError type AddrError struct { Err string Addr string } //使用 **指针** 接收器实现该Error()接口 func (e *AddrError) Error() string { if e == nil { return \u0026#34;\u0026lt;nil\u0026gt;\u0026#34; } s := e.Err if e.Addr != \u0026#34;\u0026#34; { s = \u0026#34;address \u0026#34; + e.Addr + \u0026#34;: \u0026#34; + s } return s } 在 Go 里面，使用指针实现接口有两个主要用途：\n为了在实现该函数处可以修改指针调用者 大结构使用指针可以减小拷贝，另外可以保证共享，维持全局一个类型，类似于单例。 多线程 defer 用于注册延迟调用 直到return前才会被执行, 可以用来做资源管理 多个 defer语句, 先进后出的方式( 栈 )执行 defer 后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。 1 2 3 4 5 6 7 8 func main() { var whatever [5]struct{} for i := range whatever { defer fmt.Println(i) // 4 3 2 1 0 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Test struct { name string } func (t *Test) Close() { fmt.Println(t.name, \u0026#34; closed\u0026#34;) } func main() { ts := []Test{{\u0026#34;a\u0026#34;}, {\u0026#34;b\u0026#34;}, {\u0026#34;c\u0026#34;}} for _, t := range ts { defer t.Close() } } // c closed // c closed // c closed 携程 Go 语言中的 goroutine 就是这样一种机制，goroutine 的概念类似于线程，但 goroutine 是由 Go 的运行时（runtime）调度和管理的。Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。Go 语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。\n在 Go 语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个 goroutine 去执行这个函数就可以了，就是这么简单粗暴。\n协程:用户态,轻量级线程, 栈KB级别\n线程:内核态,线程跑多个协程, 栈MB级别\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go hello() // 启动一个新的协程执行 hello() 函数 // 主线程继续执行其他任务 for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;Main Thread:\u0026#34;, i) time.Sleep(time.Second) } } func hello() { for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;Hello Goroutine:\u0026#34;, i) time.Sleep(time.Second) } } 使用匿名函数启动协程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 定义匿名函数，作为协程的运行函数 go func() { fmt.Println(\u0026#34;协程开始执行\u0026#34;) time.Sleep(2 * time.Second) // 模拟一些耗时操作 fmt.Println(\u0026#34;协程执行完成\u0026#34;) }() // 主线程继续执行其他任务 fmt.Println(\u0026#34;主线程执行其他任务\u0026#34;) // 防止主线程退出，等待一些时间以便协程执行完毕 time.Sleep(3 * time.Second) } CSP (Communicating Sequential Processes) 通信顺序进程，是 Go 语言中重要的并发模型。\n主要特征有\n顺序进程：每个进程内部按顺序执行。 通信进程：进程间通过通信 (Message Passing) 来协作。 数据流：程序通过在进程间传递数据来工作。 Go 语言的 CSP 实现主要通过 goroutine 和 channel\ngoroutine 作为顺序执行的进程 channel 用于 goroutine 间的通信 通信 / channel 提倡通过通信共享内存而不是通过共享内存而实现通信\n通过通信共享内存\u0026mdash;通道 通过共享内存实现通信\u0026mdash;临界区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var ch1 chan int // 声明一个传递整型的通道 var ch2 chan bool // 声明一个传递布尔型的通道 var ch3 chan []int // 声明一个传递int切片的通道 // 通道是引用类型，通道类型的空值是 nil。 // 声明的通道后需要使用 make 函数初始化之后才能使用。 ch4 := make(chan int) ch5 := make(chan bool) ch6 := make(chan []int) // 发送 将一个值发送到通道中。 ch \u0026lt;- 10 // 把10发送到ch中 // 接收----从一个通道中接收值。 x := \u0026lt;- ch // 从ch中接收值并赋值给变量x \u0026lt;-ch // 从ch中接收值，忽略结果 // close 函数来关闭通道。关闭通道不是必须 close(ch) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func main() { ch1 := make(chan int) ch2 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 go func() { for i := 0; i \u0026lt; 100; i++ { ch1 \u0026lt;- i } close(ch1) }() // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中 go func() { for { i, ok := \u0026lt;-ch1 // 通道关闭后再取值ok=false if !ok { break } ch2 \u0026lt;- i * i } close(ch2) }() // 在主goroutine中从ch2中接收值打印 for i := range ch2 { // 通道关闭后会退出for range循环 fmt.Println(i) } } 实例/ 生产者消费者模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import \u0026#34;fmt\u0026#34; func CalSquare() { src := make(chan int) // 生产无缓冲 dest := make(chan int, 3) // 消费缓冲3个元素 // 子协程发送0-9数字 go func() { defer close(src) for i := 0; i \u0026lt; 10; i++ { src \u0026lt;- i } }() // 子协程计算输入数字的平方 go func() { defer close(dest) for i := range src { dest \u0026lt;- i * i } }() // 主协程输出最后的平方数 for i := range dest { // 复杂操作 // ... fmt.Println(i) } } func main() { CalSquare() } 互斥锁 互斥锁，确保同时只有一个 goroutine 可以访问共享数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var ( counter = 0 // 保护临界区 mutex sync.Mutex // 保证所有的任务都能完成, 也就是主程序阻塞 wg sync.WaitGroup ) func main() { wg.Add(2) go increment(\u0026#34;Routine 1\u0026#34;) go increment(\u0026#34;Routine 2\u0026#34;) wg.Wait() fmt.Println(\u0026#34;Final counter:\u0026#34;, counter) } func increment(name string) { defer wg.Done() for i := 0; i \u0026lt; 5; i++ { // 对公共资源进行加锁 mutex.Lock() // 修改公共资源 counter++ fmt.Printf(\u0026#34;[%s] Counter: %d\\n\u0026#34;, name, counter) // 解锁公共资源 mutex.Unlock() // 模拟其他操作 time.Sleep(time.Millisecond * 500) } } sync.RWMutex 读写互斥锁，可以同时允许多个读，但写时独占。读写互斥锁实现了读写分离，相比普通的互斥锁可以提供更高的并发性能。\n1 2 3 4 5 6 7 8 9 var mu sync.RWMutex mu.RLock() // 读共享资源 mu.RUnlock() mu.Lock() // 写共享资源 mu.Unlock() sync.WaitGroup 是 Go 语言中的一个常用同步工具，可以用于等待一组 goroutine 结束。主要的使用方式是\n创建一个 WaitGroup, 通常以参数传入函数 在启动 goroutine 前调用 Add 添加计数 在 goroutine 结束时调用 Done 减少计数 等待 goroutine 结束，调用 Wait 阻塞 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func process(i int, wg *sync.WaitGroup) { fmt.Println(\u0026#34;Start goroutine\u0026#34;, i) // 结束时调用 Done 减少计数 defer wg.Done() fmt.Printf(\u0026#34;End goroutine%d\\n\u0026#34;, i) } func main() { var wg sync.WaitGroup for i := 1; i \u0026lt;= 3; i++ { wg.Add(1) go process(i, \u0026amp;wg) } wg.Wait() fmt.Println(\u0026#34;All goroutines finished executing\u0026#34;) } 面向\u0026quot;对象\u0026quot; 尽管 Go 拥有类型和方法，也允许面向对象风格的编程，但它没有类型层级。 在 Go 中 “接口” 的概念提供了不同的方法，我们相信它易于使用且在某些方面更通用。 也有一些在其它类型中嵌入类型的方法，来提供类似（而非完全相同）的东西进行子类化。 此外，Go 中的方法比 C++ 或 Java 中的更通用：它们可被定义为任何种类的数据。 甚至是像普通的 “未装箱” 整数这样的内建类型。它们并不受结构（类）的限制。\n此外，类型层级的缺失也使 Go 中的 “对象” 感觉起来比 C++ 或 Java 的更轻量级。\n\u0026ldquo;继承\u0026quot;成员\u0026mdash;匿名字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type people struct { name string age int } type student struct { people school string } func (s student) say() { fmt.Printf(\u0026#34;我是%s，今年%d岁了，在%s上学。\u0026#34;, s.name, s.age, s.school) } func main() { stu := student{people{\u0026#34;行小观\u0026#34;, 1}, \u0026#34;阳光小学\u0026#34;} stu.say() } 出现了字段冲突，Go 会先访问外层的字段。比如，stu.name 是李向前（外层），stu.people.name 是李二狗（内层）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; type people struct { name string //人名 age int } type student struct { people name string //学生名 school string } func main() { stu := student{people{\u0026#34;李二狗\u0026#34;, 1}, \u0026#34;李向前\u0026#34;, \u0026#34;阳光学校\u0026#34;} fmt.Println(stu.name) //李向前 fmt.Println(stu.people.name) //李二狗 } \u0026ldquo;继承\u0026quot;方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package main import \u0026#34;fmt\u0026#34; // 定义父类 type Parent struct { name string age int } // 父类的方法 func (p *Parent) SayHello() { fmt.Printf(\u0026#34;Hello, I\u0026#39;m %s. \u0026#34;, p.name) fmt.Printf(\u0026#34;I\u0026#39;m %d years old.\\n\u0026#34;, p.age) } // 定义子类 type Child struct { Parent // 组合父类 school string } // 子类的方法 func (c *Child) SayHello() { // 调用父类的方法 c.Parent.SayHello() fmt.Printf(\u0026#34;I study at %s school.\\n\u0026#34;, c.school) } func main() { p := \u0026amp;Parent{ name: \u0026#34;John\u0026#34;, age: 35, } p.SayHello() c := \u0026amp;Child{ Parent: Parent{ name: \u0026#34;Tom\u0026#34;, age: 8, }, school: \u0026#34;ABC\u0026#34;, } c.SayHello() } Hello, I\u0026#39;m John. I\u0026#39;m 35 years old. Hello, I\u0026#39;m Tom. I\u0026#39;m 8 years old. I study at ABC school. 重写 字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; type people struct { name string //乳名 age int } type student struct { people name string //大名 school string } func (s student) say() { fmt.Printf(\u0026#34;我是%s，今年%d岁了，和我一起学习Go语言吧！\\n\u0026#34;, s.name, s.age) } func main() { stu := student{people{\u0026#34;李二狗\u0026#34;, 1}, \u0026#34;李向前\u0026#34;,\u0026#34;阳光小学\u0026#34;} stu.say() } \u0026ldquo;重写\u0026quot;方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import \u0026#34;fmt\u0026#34; type people struct { name string age int } type student struct { people school string } type programmer struct { people language string } func (p people) say() { //people的say方法 fmt.Printf(\u0026#34;我是%s，今年%d岁了，和我一起学习Go语言吧！\\n\u0026#34;, p.name, p.age) } func (s student) say() { //student重写people的say方法 fmt.Printf(\u0026#34;我是%s，是个学生，今年%d岁了，我在%s上学！\\n\u0026#34;, s.name, s.age, s.school) } func (p programmer) say() { //programmer重写people的say方法 fmt.Printf(\u0026#34;我是%s，是个程序员，今年%d岁了，我使用%s语言！\\n\u0026#34;, p.name, p.age, p.language) } func main() { stu := student{people{\u0026#34;李向前\u0026#34;, 1}, \u0026#34;阳光小学\u0026#34;} stu.say() prmger := programmer{people{\u0026#34;张三\u0026#34;, 1}, \u0026#34;Go\u0026#34;} prmger.say() } 我是李向前，是个学生，今年1岁了，我在阳光小学上学！ 我是张三，是个程序员，今年1岁了，我使用Go语言！ 接口 简单地来说，接口就是规范，如果你的类实现了接口，那么该类就必须具有接口所要求的一切功能、行为。接口中通常定义的都是方法。\n接口的声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type human interface { //定义human接口 say() eat() } // 调用接口 h.say() h.eat() type adult interface { //定义adult接口 say() eat() drink() work() } type teenager interface { //定义teenager接口 say() eat() learn() } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 package main import \u0026#34;fmt\u0026#34; type people struct { name string age int } type student struct { people //\u0026#34;继承\u0026#34;people subject string school string } type programmer struct { people //\u0026#34;继承\u0026#34;people language string company string } type human interface { //定义human接口 say() eat() } type adult interface { //定义adult接口 say() eat() drink() work() } type teenager interface { //定义teenager接口 say() eat() learn() } func (p people) say() { //people实现say()方法 fmt.Printf(\u0026#34;我是%s，今年%d。\\n\u0026#34;, p.name, p.age) } func (p people) eat() { //people实现eat()方法 fmt.Printf(\u0026#34;我是%s，在吃饭。\\n\u0026#34;, p.name) } func (s student) learn() { //student实现learn()方法 fmt.Printf(\u0026#34;我在%s学习%s。\\n\u0026#34;, s.school, s.subject) } func (s student) eat() { //student重写eat()方法 fmt.Printf(\u0026#34;我是%s，在%s学校食堂吃饭。\\n\u0026#34;, s.name, s.school) } func (pr programmer) work() { //programmer实现work()方法 fmt.Printf(\u0026#34;我在%s用%s工作。\\n\u0026#34;, pr.company, pr.language) } func (pr programmer) drink() {//programmer实现drink()方法 fmt.Printf(\u0026#34;我是成年人了，能大口喝酒。\\n\u0026#34;) } func (pr programmer) eat() { //programmer重写eat()方法 fmt.Printf(\u0026#34;我是%s，在%s公司餐厅吃饭。\\n\u0026#34;, pr.name, pr.company) } func main() { xiaoguan := people{\u0026#34;行小观\u0026#34;, 20} zhangsan := student{people{\u0026#34;张三\u0026#34;, 20}, \u0026#34;数学\u0026#34;, \u0026#34;银河大学\u0026#34;} lisi := programmer{people{\u0026#34;李四\u0026#34;, 21},\u0026#34;Go\u0026#34;, \u0026#34;火星有限公司\u0026#34;} var h human h = xiaoguan h.say() h.eat() fmt.Println(\u0026#34;------------\u0026#34;) var a adult a = lisi a.say() a.eat() a.work() fmt.Println(\u0026#34;------------\u0026#34;) var t teenager t = zhangsan t.say() t.eat() t.learn() } 接口值 是不是可以理解为, 有着共同方法的一组对象 接口也是值，这就意味着接口能像值一样进行传递，并可以作为函数的参数和返回值。 如果定义了一个接口类型变量，那么该变量中可以存储实现了该接口的任意类型值： 不能存储未实现该 interface 接口的类型值： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { //这三个人都实现了human接口 xiaoguan := people{\u0026#34;行小观\u0026#34;, 20} zhangsan := student{people{\u0026#34;张三\u0026#34;, 20}, \u0026#34;数学\u0026#34;, \u0026#34;银河大学\u0026#34;} lisi := programmer{people{\u0026#34;李四\u0026#34;, 21},\u0026#34;Go\u0026#34;, \u0026#34;火星有限公司\u0026#34;} var h human //定义human类型变量 //所以h变量可以存这三个人 h = xiaoguan h = zhangsan h = lisi } // 不可以 func main() { xiaoguan := people{\u0026#34;行小观\u0026#34;, 20} //实现human接口 zhangsan := student{people{\u0026#34;张三\u0026#34;, 20}, \u0026#34;数学\u0026#34;, \u0026#34;银河大学\u0026#34;} //实现teenager接口 lisi := programmer{people{\u0026#34;李四\u0026#34;, 21},\u0026#34;Go\u0026#34;, \u0026#34;火星有限公司\u0026#34;} //实现adult接口 var a adult //定义adult类型变量 //但zhangsan没实现adult接口 a = zhangsan //所以a不能存zhangsan，会报错 } 空接口 1 2 3 4 5 6 interface {} a := people{\u0026#34;zhang san\u0026#34;, 14} var ept interface{} ept = 10 ept = a 接口做返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; type sayer interface {//接口 say() } func foo(a sayer) { //函数的参数是接口值 a.say() } type people struct { //结构体类型 name string age int } func (p people) say() { //people实现了接口sayer fmt.Printf(\u0026#34;我是%s，今年%d岁。\u0026#34;, p.name, p.age) } type MyInt int //MyInt类型 func (m MyInt) say() { //MyInt实现了接口sayer fmt.Printf(\u0026#34;我是%d。\\n\u0026#34;, m) } func main() { xiaoguan := people{\u0026#34;行小观\u0026#34;, 20} foo(xiaoguan) //结构体类型作为参数 i := MyInt(5) foo(i) //MyInt类型作为参数 } \u0026ldquo;继承\u0026quot;接口 就是把一个接口当做匿名字段嵌入另一个接口中\n它定义了两个结构体 animal 和 dog，dog 结构体使用匿名字段 animal 来实现继承。 接口 runner 和 watcher 定义了方法 run() 和 watch()，watcher 接口继承了 runner 接口。 然后，在 main() 函数中创建了一个 animal 类型的变量 a 和一个 dog 类型的变量 d。最后调用了 a.run()、d.run() 和 d.watch() 方法来输出结果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import \u0026#34;fmt\u0026#34; type animal struct { //结构体animal name string age int } type dog struct { //结构体dog animal //“继承”animal address string } type runner interface { //runner接口 run() } type watcher interface { //watcher接口 runner //“继承”runner接口 watch() } func (a animal) run() { //animal实现runner接口 fmt.Printf(\u0026#34;%s会跑\\n\u0026#34;, a.name) } func (d dog) watch() { //dog实现watcher接口 fmt.Printf(\u0026#34;%s在%s看门\\n\u0026#34;, d.name, d.address) } func main() { a := animal{\u0026#34;小动物\u0026#34;, 12} d := dog{animal{\u0026#34;哮天犬\u0026#34;, 13}, \u0026#34;天庭\u0026#34;} a.run() d.run() //哮天犬可以调用“继承”得到的接口中的方法 d.watch() } 依赖管理 go 依赖管理主要经历以下三个阶段：\nGOPATH GO VENDOR GO Module gopath GOROOT 和 GOPATH 是两个与 Go 语言开发环境相关的环境变量，它们有不同的作用和含义。\nGOROOT（Go Root）：GOROOT 是指向你的 Go 安装目录的环境变量。它用于告诉 Go 编译器和工具在哪里找到 Go 的标准库和其他系统级别的包。当你安装 Go 时，会自动设置 GOROOT 环境变量。 GOPATH（Go Path）：GOPATH 是指向你的 Go 工作区的环境变量。它是你的项目代码和第三方包的存放路径。在 GOPATH 下，按照约定的目录结构，你可以创建 src、pkg 和 bin 三个目录。src 目录用于存放你的项目代码，pkg 目录用于存放编译后的包对象文件，bin 目录用于存放可执行文件。 联系：\nGOPATH 可以包含多个路径，用冒号（Unix/Linux）或分号（Windows）分隔，以指定多个工作区。 在 GOPATH 下的 src 目录中，你可以创建多个项目目录，每个目录对应一个独立的项目。 在项目目录中，你可以使用 import 语句引入其他项目或第三方包，Go 编译器会在 GOPATH 下的相应目录中查找这些包。 区别：\nGOROOT 是指向 Go 的安装目录，用于找到 Go 的标准库和系统级别的包。 GOPATH 是指向你的工作区目录，用于存放你的项目代码和第三方包。 gopath 是 go 语言支持的一个环境变量，value 是 Go 项目的工作区。\n1 2 3 4 cd $GOPATH |---bin 项目编译的二进制文件 |---pkg 项目编译的中间产物加速编译 |---src 项目源码 项目代码直接依赖src下的代码 go get下载最新版本的包到src 目录下 同一个 pkg，但是 pkg 有不同版本 pkg v1 和 pkg v2, 里面包含两个方法。而 src 下只能有一个版本存在，那 AB 项目无法保证都能编译通过。\n就是在 gopath 管理模式下，如果多个项目依赖同一个库，则依赖该库是同一份代码，所以不同项目不能依赖同一个库的不同版本，这很显然不能满足我们的项目依赖需求。无法实现 package 的多版本控制。\n为了解决这个问题，go vendor 出现了。\nGo Vendor 项目目录下增加 vendor 文件, 所有依赖包副本形式放在$ProjectRoot/vendor 依赖寻址方式:vendor=\u0026gt;GOPATH 问题\nA依赖于 B C B C 依赖于 D不同的版本 go module 有了 Go module 之后，可以方便地管理项目的依赖关系，并且不需要手动下载库。使用 Go module，你可以在代码中引入需要的库，并通过指定版本或者版本范围来自动获取相应的库。当你首次引入一个新的库时，Go module 会自动下载该库及其依赖到本地的缓存中。这样，你就可以随意引入库，而无需手动下载。\n依赖管理三要素\n1.配置文件, 描述依赖go.mod 2.中心仓库管理依赖库 Proxy 3.本地工具 go get/mod 1 2 3 4 5 6 7 8 module example/project/ap // p依赖管理基本单元 go 1.16 // 原生库 require ( // 单元依赖 example/lib1 v1.0.2 example/lib2 v1.0.0 // indirect example/lib3 v0.1.0-20190725025543-5a5fe074e612 example/lib4 v0.0.0-20180306012644-bacd9c7ef1dd // indirect example/lib5/v3 v3.0.2 ) 依赖配置 - indirect 关键字\nA-\u0026gt;B-\u0026gt;C，A-\u0026gt;B 属于直接依赖，A-\u0026gt;C 属于间接依赖。 在 go.mod 中，对于没有直接导入该依赖模块的包，也就是非直接依赖，标识间接依赖。所以加上 indirect 后缀。 为什么需要 Proxy\n直接使用版本管理仓库下载依赖，存在多个问题，\n无法保证构建确定性：软件作者可以直接代码平台增加 / 修改 / 删除软件版本，导致下次构建使用另外版本的依赖，或者找不到依赖版本。 无法保证依赖可用性：依赖软件作者可以直接代码平台删除软件，导致依赖不可用。 增加第三方代码托管平台的压力，代码托管平台负载问题。 使用 go proxy 之后，构建时会直接从 go proxy 站点拉取依赖。类比项目中，下游无法满足我们上游的需求。\n1 GOPROXY=\u0026#34;https://proxy1.cn, https://proxy2.cn ,direct\u0026#34; 工具 - go get/mod 开头提到 go model 有两个本地工具，go get/mod。\n指令功能 @update 默认 @none 删除依赖 @v1.1.2 下载指定tag版本,语义版本 @23dfdd5 下载特定的commit版本 @master 下载分支的最新commit go mod\n指令 功能 init 初始化,创建go.mod文件 tidy 增加需要的依赖,删除不需要的依赖 go module 使用方法 确保你的项目目录下有一个有效的 go.mod 文件。如果没有，可以通过运行 go mod init 命令来初始化一个新的模块。 在你的项目中，使用 import 语句导入你需要的依赖项。 运行 go mod tidy 命令来自动分析你的代码并下载缺少的依赖项。这个命令会根据你的代码中的导入语句自动更新 go.mod 文件，并下载相应的依赖项。 如果你想手动下载特定的依赖项，可以使用 go get 命令，例如 go get github.com/example/package。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 $ go env GO111MODULE=\u0026#34;on\u0026#34; GOARCH=\u0026#34;amd64\u0026#34; GOBIN=\u0026#34;\u0026#34; GOCACHE=\u0026#34;/home/runner/.cache/go-build\u0026#34; GOENV=\u0026#34;/home/runner/.config/go/env\u0026#34; GOEXE=\u0026#34;\u0026#34; GOEXPERIMENT=\u0026#34;\u0026#34; GOFLAGS=\u0026#34;\u0026#34; GOHOSTARCH=\u0026#34;amd64\u0026#34; GOHOSTOS=\u0026#34;linux\u0026#34; GOINSECURE=\u0026#34;\u0026#34; GOMODCACHE=\u0026#34;/home/runner/go/pkg/mod\u0026#34; GONOPROXY=\u0026#34;\u0026#34; GONOSUMDB=\u0026#34;\u0026#34; GOOS=\u0026#34;linux\u0026#34; GOPATH=\u0026#34;/home/runner/go\u0026#34; GOPRIVATE=\u0026#34;\u0026#34; GOPROXY=\u0026#34;https://goproxy.cn,direct\u0026#34; GOROOT=\u0026#34;/nix/store/4m1nfq0xhc9p1hi6dnxbcpppcgz22yf9-go-1.17.5/share/go\u0026#34; GOSUMDB=\u0026#34;sum.golang.org\u0026#34; GOTMPDIR=\u0026#34;\u0026#34; GOTOOLDIR=\u0026#34;/nix/store/4m1nfq0xhc9p1hi6dnxbcpppcgz22yf9-go-1.17.5/share/go/pkg/tool/linux_amd64\u0026#34; GOVCS=\u0026#34;\u0026#34; GOVERSION=\u0026#34;go1.17.5\u0026#34; GCCGO=\u0026#34;gccgo\u0026#34; AR=\u0026#34;ar\u0026#34; CC=\u0026#34;gcc\u0026#34; CXX=\u0026#34;g++\u0026#34; CGO_ENABLED=\u0026#34;1\u0026#34; GOMOD=\u0026#34;/home/runner/app/go.mod\u0026#34; CGO_CFLAGS=\u0026#34;-g -O2\u0026#34; CGO_CPPFLAGS=\u0026#34;\u0026#34; CGO_CXXFLAGS=\u0026#34;-g -O2\u0026#34; CGO_FFLAGS=\u0026#34;-g -O2\u0026#34; CGO_LDFLAGS=\u0026#34;-g -O2\u0026#34; PKG_CONFIG=\u0026#34;pkg-config\u0026#34; GOGCCFLAGS=\u0026#34;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build2769124553=/tmp/go-build -gno-record-gcc-switches\u0026#34; # 设置 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct GO111MODULE 有三个值：off、on 和 auto (默认值)\nGO111MODULE=off ：go 命令行将不会支持 module 功能，寻找依赖包的方式将会沿用旧版本那种通过 vendor 目录或者 GOPATH 模式来查找。\nGO111MODULE=on ：go 命令行会使用 modules，而一点也不会去 GOPATH 目录下查找。\n1 GO111MODULE=auto ：默认值，go 命令行将会根据当前目录来决定是否启用 module 功能。这种情况下可以分为两种情形：\n当前目录在 GOPATH/src 之外且该目录包含 go.mod 文件 当前文件在包含 go.mod 文件的目录下面。 go mod 使用 | 全网最详细 - 知乎 (zhihu.com)\n直接在文件里 import 然后运行 go mod tidy就行吗\ngo build 编译的时候会根据 go.mod 里自己下载包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 go mod init packagename Go mod provides access to operations on modules. Note that support for modules is built into all the go commands, not just \u0026#39;go mod\u0026#39;. For example, day-to-day adding, removing, upgrading, and downgrading of dependencies should be done using \u0026#39;go get\u0026#39;. See \u0026#39;go help modules\u0026#39; for an overview of module functionality. Usage: go mod \u0026lt;command\u0026gt; [arguments] The commands are: download download modules to local cache edit edit go.mod from tools or scripts graph print module requirement graph init initialize new module in current directory tidy add missing and remove unused modules vendor make vendored copy of dependencies verify verify dependencies have expected content why explain why packages or modules are needed Use \u0026#34;go help mod \u0026lt;command\u0026gt;\u0026#34; for more information about a command. 如何指定包版本 在 Go 中，可以使用 Go Modules 来管理和指定包的版本。Go Modules 是 Go 1.11 版本引入的一种包管理机制，它允许你在项目中明确指定所使用的包的版本。\n以下是一些常用的指定包版本的方法：\n使用固定版本号：在你的项目的 go.mod 文件中，可以直接指定包的固定版本号。例如：\n1 2 3 4 5 go 1.16 require ( github.com/gin-gonic/gin v1.7.4 ) 在这个例子中，我们明确指定了使用 github.com/gin-gonic/gin 的 v1.7.4 版本。\n使用语义化版本控制：除了指定固定版本号，你还可以使用语义化版本控制来指定包的版本。例如，你可以使用 ^ 符号来指定兼容的最新版本。例如：\n1 2 3 4 5 go 1.16 require ( github.com/gin-gonic/gin ^1.7.0 ) 在这个例子中，我们指定了使用 github.com/gin-gonic/gin 的兼容版本大于等于 1.7.0 且小于 2.0.0 的最新版本。\n使用特定的版本范围：除了使用 ^ 符号，你还可以使用其他运算符来指定特定的版本范围。例如，你可以使用 \u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;= 等符号来指定版本的范围。例如：\n1 2 3 4 5 go 1.16 require ( github.com/gin-gonic/gin \u0026gt;=1.7.0, \u0026lt;1.8.0 ) 在这个例子中，我们指定了使用 github.com/gin-gonic/gin 的版本大于等于 1.7.0 且小于 1.8.0。\n项目构建/ 编译 一个 Go 工程中主要包含以下三个目录：\n1 2 3 src：源代码文件 pkg：包文件 bin：相关bin文件 1: 建立工程文件夹 goproject\n2: 在工程文件夹中建立 src,pkg,bin 文件夹\n3: 在 GOPATH 中添加 projiect 路径 例 e:/goproject\n4: 如工程中有自己的包 examplepackage，那在 src 文件夹下建立以包名命名的文件夹 例 examplepackage\n5：在 src 文件夹下编写主程序代码代码 goproject.go\n6：在 examplepackage 文件夹中编写 examplepackage.go 和 包测试文件 examplepackage_test.go\n7：编译调试包\ngo build examplepackage\ngo test examplepackage\ngo install examplepackage\n这时在 pkg 文件夹中可以发现会有一个相应的操作系统文件夹如 windows_386z, 在这个文件夹中会有 examplepackage 文件夹，在该文件中有 examplepackage.a 文件\n8：编译主程序\ngo build goproject.go\n成功后会生成 goproject.exe 文件\n至此一个 Go 工程编辑成功。\n1 2 3 4 5 6 7 8 9 1.建立工程文件夹 go $ pwd /Users/***/Desktop/go 2: 在工程文件夹中建立src,pkg,bin文件夹 $ ls bin conf pkg src 3: 在GOPATH中添加projiect路径 $ go env GOPATH=\u0026#34;/Users/liupengjie/Desktop/go\u0026#34; go命令 go env 用于打印 Go 语言的环境信息。\ngo run 命令可以编译并运行命令源码文件。\ngo get 可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。\ngo build 命令用于编译我们指定的源码文件或代码包以及它们的依赖包。\ngo install 用于编译并安装指定的代码包及它们的依赖包。\ngo clean 命令会删除掉执行其它命令时产生的一些文件和目录。\ngo doc 命令可以打印附于 Go 语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。\ngo test 命令用于对 Go 语言编写的程序进行测试。\ngo list 命令的作用是列出指定的代码包的信息。\ngo fix 会把指定代码包的所有 Go 语言源码文件中的旧版本代码修正为新版本的代码。\ngo vet 是一个用于检查 Go 语言源码中静态错误的简单工具。\ngo tool pprof 命令来交互式的访问概要文件的内容。\n","date":"2023-08-23T20:26:16Z","permalink":"https://li54426.github.io/p/go_quick_book/","title":"Go_quick_book"},{"content":" content {:toc} 函数模板不能使用 auto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 bool cmp(pair\u0026lt;int, int\u0026gt; \u0026amp;a, pair\u0026lt;int, int\u0026gt; \u0026amp;b){ if( a.first == b.first){ a.second = b.second; return 1; } return 0; } class Solution { public: vector\u0026lt;int\u0026gt; smallestSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 找一个最短的子数组, 使得 | 之后的值最大 // 按位或的性质? // 从x=nums[i]出发,OR的结果至多有多少种? // 关键:1不能变成0, 0可以变成1至多能变多少次?变29次,总共30种 int len = nums.size(); vector\u0026lt;int\u0026gt; res(len, 0); vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; ors; for(int i= len-1; i\u0026gt;-1; --i){ ors.push_back({nums[i], i}); for(int j = 0; j\u0026lt; ors.size(); ++j){ ors[j].first |= nums[i]; } auto it = unique(ors.begin(), ors.end(), cmp); ors.resize(it - ors.begin()); res[i] = ors[0].second-i +1; } return res; } }; 在 C++ 中，使用 auto 关键字可以让编译器自动推导变量的类型。然而，在函数模板中，编译器无法自动推导函数参数的类型，因此必须使用显示的类型。\n在给定的代码中，cmp 函数被用作 unique 函数的比较函数。unique 函数是一个函数模板，它接受两个迭代器和一个比较函数作为参数，并在指定范围内移除相邻的重复元素。\n因为 cmp 函数是作为比较函数传递给 unique 函数的，所以编译器无法自动推导参数的类型。因此，参数类型必须显式地指定为 pair\u0026lt;int, int\u0026gt;\u0026amp;，以便 unique 函数正确调用 cmp 函数进行比较。\n如果将参数类型改为 auto，编译器将无法确定参数类型，从而无法正确调用 cmp 函数，导致编译错误。\nlambda表达式 使用 auto 1 2 vector\u0026lt;int\u0026gt; aaaa (7, 0); unique (aaaa.begin (), aaaa.end (), [](auto a, auto b){return a== b;} ); 对于标准库算法函数（如 unique），它们是在 C++98/03 标准中定义的，不支持使用模板参数推导，因此无法直接使用 lambda 表达式作为比较函数。\n在 C++11 引入 lambda 表达式之前，为了使用自定义比较函数，我们通常需要使用函数指针或函数对象来传递函数。这要求我们定义一个具体的函数或函数对象，并显式地指定其类型。\n然而，在 C++11 之后的版本（包括 C++11、C++14 和 C++17），lambda 表达式提供了更简洁和灵活的方式来定义匿名函数，并可以在标准库算法中直接使用。\n所以，你可以使用 lambda 表达式作为比较函数传递给 unique 函数，而不需要使用函数指针或函数对象。这种语法糖使代码更简洁、可读性更好，并且能够自动推导参数类型。\n总而言之，C++11 以后的标准支持 lambda 表达式作为比较函数的直接传递，而之前的标准则需要使用函数指针或函数对象来传递自定义函数。\n","date":"2023-08-23T11:43:45Z","permalink":"https://li54426.github.io/p/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E-auto-%E5%85%B3%E9%94%AE%E5%AD%97/","title":"函数模板与 auto 关键字"},{"content":" content {:toc} 服务端漏洞 安全事件 数据泄漏 服务瘫痪 成果失窃 系统劫持 SQL注入 SQL语句静态模板和动态数据部分没有严格区分,如果在数据项中加入了某些SOL语句关键字(比如说SELECT、DROP等等),这些SQL语句就很可以在数据库写入或读取数据时得到执行.\n防护方式:\n1.尽量不要基于DB的Raw方法拼接构造SQL语句,而应该使用预编译、ORM框架 2.使用ORM框架时,应该注意框架中的特性,可能存在不安全的写法导致的SQL注入问题. 3.在复杂场景一定要使用拼接SQL,需要对外部输入进行转义. 命令执行 代码中遇到需要调用某个命令才能完成的功能时候, 会涉及到命令拼接, 如果命令拼接没有做好安全过滤, 那么将会导致命令注入风险, 服务器权限将会被控制\n防护方式:\n1.对动态的值尽可能设置白名单进行验证. 2.如果某些位置无法白名单,需要尝试对数据类型进行校验. 3.特殊字符黑名单的过滤,或者转义. 越权漏洞 未授权 水平越权 垂直越权 SSRF SSRF又称服务端请求伪造攻击,指攻击者利用后端服务器为跳板,让后端服务向非预期网络地址(主要指内网地址)发出恶意请求,获取敏感信息或执行恶意操作.\n实例: 设置头像, 输入一个网址\n文件上传漏洞 防护方案:\n1.限制文件类型:如果系统只需要图片类型, 可以从服务端解析文件格式, 限制只能传入特定的文件格式. 2.站库分离:应用部署的位置和上传的文件分离, 一般可以使用TOS、OSS等进行文件存储. 3.防止图床:对图片访问链接进行限制,包括时间限制, 访问身份限制等. 客户端漏洞 开放重定向 开放重定向: 某些需要重定向到其他站点的功能, 往往在参数中携带需要重定向的URL, 但实际程序逻辑没有控制好重定向的范围, 导致攻击者可以构造恶意链接, 诱导用户重定向到恶意站点.\n危害:钓鱼攻击. 修复方案:对重定向严格进行白名单控制并正确校验匹配白名单.\nXSS 防护方法:\n1.输入过滤:对输入的特殊字符进行拦截,禁止前端提交特殊字符 2.输出过滤: a.当字符输出到Dom时候,对危险字符进行html encode,避免XSS. b.使用vue/react等框架时候,避免使用危险指令,而应该使用安全指令.v-html/v-text 3.富文本场景:比如文章发布场景,本身是需要提供富文本功能,这时候需要严格限制tag和attribute,可以在代码层面做白名单或者黑名单. 4.CSP:用于缓解XSS,理念是对当前站点允许加载什么源的资源、发送什么请求能进行限制. CSRF 跨站请求伪造(CSRF): 允许攻击者诱导用户访问恶意链接,执行用户非预期执行的操作. 危害: 用户执行敏感操作,如关注其他用户,或者更改账号的安全邮箱等.\n防护方式: 防护的核心是判断请求的来源\nCSRF tokens: 首次访问时候给客户端传递一个token, 客户端每次访问时候都必须带上此 token 才能访问. SameSite cookies: Strick -\u0026gt; Lax(Default) -\u0026gt; None.核心是禁止某些场景发送第三方cookie. Referer-based validation:校验 Referer来源是否是合法站点. 思考:大厂微服务场景,CSRF防护应该怎么做? ","date":"2023-08-18T12:59:58Z","permalink":"https://li54426.github.io/p/%E6%BC%8F%E6%B4%9E/","title":"漏洞"},{"content":" content {:toc} 三、测试 测试是避免事物的最后一道屏障。\n回归测试 集成测试 单元测试 从上到下，覆盖率逐层变大，成本却逐层降低\nGo 语言内置有对单元测试的支持，主要通过 testing 包实现。\n所有测试文件以_test.go结尾 func TestXxx(t *testing.T) 初始化逻辑放到TestMain中 1 2 3 4 5 6 7 8 9 10 11 func Add(a int, b int) int{ return a+b } func TestAdd(t *testing.T) { output:=Add(1, 2) expectOutput:=3 if output != expectOutput{ t.Error(\u0026#34;Add failed\u0026#34;) } } assert Go 语言内置的 testing 包提供了 assert 包来进行单元测试的断言，assert 能大大简化测试代码，不需要过多的 if 条件判断，只要最终结果不符合断言，就会自动标记为测试失败。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package Test import ( \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;testing\u0026#34; ) func Add(a int, b int) int { return a + b } func TestAdd(t *testing.T) { output := Add(1, 2) expectOutput := 3 assert.Equal(t, expectOutput, output) } 性能优化与软件质量\n软件质量至关重要 在保证接口稳定的前提下改进具体实现 测试用例: 覆盖尽可能多的场景,方便回归, 测试驱动开发 文档:做了什么,没做什么,能达到怎样的效果 隔离:通过选项控制是否开启优化 可观测:必要的日志输出 自动内存管理主要管理的是动态内存，动态内存指的是程序在运行时根据需求动态分配的内存，比如 C 语言中的 malloc() 函数分配的内存。\n自动内存管理也称为垃圾回收，主要目的是由程序语言的运行时系统管理动态内存，这样做有以下两方面的好处：\n避免手动内存管理，专注于实现业务逻辑 保证内存使用的正确性和安全性，比如 C 语言中的内存多次释放：double-free problem, 释放后再次使用 use-after-free problem。 由此可见，手动释放内存存在很多问题，如果使用不当的话，可能会引起程序的崩溃、漏洞，而自动内存管理可以帮我们自动处理这些问题。\n自动内存管理有 3 个主要的核心任务：\n为新对象分配空间 找到存活对象 回收死亡对象的内存空间 基本概念 Mutator：业务线程，分配新对象，修改对象指向关系 Collector：GC 线程，找到存活对象，回收死亡对象的内存空间 Serial GC：只有一个 collector，会暂停 (STW) Parallec GC：支持多个 collectors 同时回收 GC 算法，会暂停 (STW) Concurrent GC：mutator(s) 和 collector(s) 可以同时执行，Collectors 必须感知对象指向关系的改变。 gc 算法 接下来将介绍两种常见的 GC 相关的技术：\n追踪垃圾回收 (Tracing garbage collection) 引用计数 (Reference counting) 追踪垃圾分类 追踪垃圾回收，当一个对象的指针指向关系不可达的时候，该对象就要被回收了。\n追踪垃圾回收算法垃圾回收步骤：\n标记根对象 标记包括 静态变量、全局变量、常量、线程栈等 标记：找到可达对象 求指针指向关系的传递闭包：从根对象触发，找到所有可达对象 清理：所有不可达对象 将存活对象复制到另外的内存空间 (Copying GC) 将死亡对象的内存标记为” 可分配 “(Marking-sweep GC) 移动并整理存活对象 (Mark-compact GC) 清理策略有很多种，在实际清理的时候应该根据对象的生命周期，使用不同的标记和清理策略。\n分代 gc 分代GC(Generational GC) 是一种常见的内存管理方式，思想是基于分代假说 (Generational hypothesis)—— 大多数对象很快就死掉了 (most objects die young)，很多对象在分配出来后很快就不再使用了。\n每个对象都有年龄，也就是对象经历过 GC 的次数，比如经历了 2 次 GC 那么他的年龄就为 2。\n分代GC 根据对象年龄的不同，把对象放在不同的区域，年轻代对象放在 Young Generation 区域，老年代放在 Old Generation 区域，这样做的目的为对年轻和老年的对象，制定不同的 GC策略，降低整体内存管理的开销。\n年轻代为常规的对象分配，由于存活对象很少，可以采用 copying collection算法，GC 吞吐量很高。\n老年代内对象趋向于一直活着，反复复制开销较大，可以采用 mark-sweep collection算法。\n引用计数 引用计数管理内存的方式为每个对象都有一个与之相关联的引用数目，对象存活的条件为当且仅当引用数大于 0。\n引用计数管理内存的优点如下：\n内存管理的操作被平摊到程序执行过程中 内存管理不需要了解 runtime 的实现细节，有一些库可以帮助实现引用计数，比如 C++ 智能指针 (smart pointer)。 当然引用计数也有缺点：\n维护引用计数的开销较大：通过原子操作保证对引用计数操作的原子性和可见性 无法回收环形数据结构 ——weak reference 内存开销：每个对象都引入的额外内存空间存储引用数目 回收内存时可能引发暂停 —— 大的数据结构 ","date":"2023-08-17T10:11:09Z","permalink":"https://li54426.github.io/p/go_/","title":"Go_"},{"content":" content {:toc} 携程 Go 语言中的 goroutine 就是这样一种机制，goroutine 的概念类似于线程，但 goroutine 是由 Go 的运行时（runtime）调度和管理的。Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。Go 语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。\n在 Go 语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个 goroutine 去执行这个函数就可以了，就是这么简单粗暴。\n协程:用户态,轻量级线程, 栈KB级别\n线程:内核态,线程跑多个协程, 栈MB级别\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go hello() // 启动一个新的协程执行 hello() 函数 // 主线程继续执行其他任务 for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;Main Thread:\u0026#34;, i) time.Sleep(time.Second) } } func hello() { for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;Hello Goroutine:\u0026#34;, i) time.Sleep(time.Second) } } 使用匿名函数启动协程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 定义匿名函数，作为协程的运行函数 go func() { fmt.Println(\u0026#34;协程开始执行\u0026#34;) time.Sleep(2 * time.Second) // 模拟一些耗时操作 fmt.Println(\u0026#34;协程执行完成\u0026#34;) }() // 主线程继续执行其他任务 fmt.Println(\u0026#34;主线程执行其他任务\u0026#34;) // 防止主线程退出，等待一些时间以便协程执行完毕 time.Sleep(3 * time.Second) } CSP (Communicating Sequential Processes) 通信顺序进程，是 Go 语言中重要的并发模型。\n主要特征有\n顺序进程：每个进程内部按顺序执行。 通信进程：进程间通过通信 (Message Passing) 来协作。 数据流：程序通过在进程间传递数据来工作。 Go 语言的 CSP 实现主要通过 goroutine 和 channel\ngoroutine 作为顺序执行的进程 channel 用于 goroutine 间的通信 通信 / channel 提倡通过通信共享内存而不是通过共享内存而实现通信\n通过通信共享内存\u0026mdash;通道 通过共享内存实现通信\u0026mdash;临界区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var ch1 chan int // 声明一个传递整型的通道 var ch2 chan bool // 声明一个传递布尔型的通道 var ch3 chan []int // 声明一个传递int切片的通道 // 通道是引用类型，通道类型的空值是 nil。 // 声明的通道后需要使用 make 函数初始化之后才能使用。 ch4 := make(chan int) ch5 := make(chan bool) ch6 := make(chan []int) // 发送 将一个值发送到通道中。 ch \u0026lt;- 10 // 把10发送到ch中 // 接收----从一个通道中接收值。 x := \u0026lt;- ch // 从ch中接收值并赋值给变量x \u0026lt;-ch // 从ch中接收值，忽略结果 // close 函数来关闭通道。关闭通道不是必须 close(ch) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func main() { ch1 := make(chan int) ch2 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 go func() { for i := 0; i \u0026lt; 100; i++ { ch1 \u0026lt;- i } close(ch1) }() // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中 go func() { for { i, ok := \u0026lt;-ch1 // 通道关闭后再取值ok=false if !ok { break } ch2 \u0026lt;- i * i } close(ch2) }() // 在主goroutine中从ch2中接收值打印 for i := range ch2 { // 通道关闭后会退出for range循环 fmt.Println(i) } } 实例/ 生产者消费者模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import \u0026#34;fmt\u0026#34; func CalSquare() { src := make(chan int) // 生产无缓冲 dest := make(chan int, 3) // 消费缓冲3个元素 // 子协程发送0-9数字 go func() { defer close(src) for i := 0; i \u0026lt; 10; i++ { src \u0026lt;- i } }() // 子协程计算输入数字的平方 go func() { defer close(dest) for i := range src { dest \u0026lt;- i * i } }() // 主协程输出最后的平方数 for i := range dest { // 复杂操作 // ... fmt.Println(i) } } func main() { CalSquare() } 互斥锁 互斥锁，确保同时只有一个 goroutine 可以访问共享数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var ( counter = 0 // 保护临界区 mutex sync.Mutex // 保证所有的任务都能完成, 也就是主程序阻塞 wg sync.WaitGroup ) func main() { wg.Add(2) go increment(\u0026#34;Routine 1\u0026#34;) go increment(\u0026#34;Routine 2\u0026#34;) wg.Wait() fmt.Println(\u0026#34;Final counter:\u0026#34;, counter) } func increment(name string) { defer wg.Done() for i := 0; i \u0026lt; 5; i++ { // 对公共资源进行加锁 mutex.Lock() // 修改公共资源 counter++ fmt.Printf(\u0026#34;[%s] Counter: %d\\n\u0026#34;, name, counter) // 解锁公共资源 mutex.Unlock() // 模拟其他操作 time.Sleep(time.Millisecond * 500) } } sync.RWMutex 读写互斥锁，可以同时允许多个读，但写时独占。读写互斥锁实现了读写分离，相比普通的互斥锁可以提供更高的并发性能。\n1 2 3 4 5 6 7 8 9 var mu sync.RWMutex mu.RLock() // 读共享资源 mu.RUnlock() mu.Lock() // 写共享资源 mu.Unlock() sync.WaitGroup 是 Go 语言中的一个常用同步工具，可以用于等待一组 goroutine 结束。主要的使用方式是\n创建一个 WaitGroup, 通常以参数传入函数 在启动 goroutine 前调用 Add 添加计数 在 goroutine 结束时调用 Done 减少计数 等待 goroutine 结束，调用 Wait 阻塞 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func process(i int, wg *sync.WaitGroup) { fmt.Println(\u0026#34;Start goroutine\u0026#34;, i) // 结束时调用 Done 减少计数 defer wg.Done() fmt.Printf(\u0026#34;End goroutine%d\\n\u0026#34;, i) } func main() { var wg sync.WaitGroup for i := 1; i \u0026lt;= 3; i++ { wg.Add(1) go process(i, \u0026amp;wg) } wg.Wait() fmt.Println(\u0026#34;All goroutines finished executing\u0026#34;) } ","date":"2023-08-17T09:59:12Z","permalink":"https://li54426.github.io/p/go_/","title":"Go_"},{"content":" content {:toc} 实现函数对象 在 Go 中，可以使用函数类型和闭包来实现类似于 C++ 函数对象（Functor）的功能。函数类型可以作为参数传递和返回值，而闭包可以捕获外部变量并形成一个可调用的函数对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; // 定义一个函数类型 type MyFunc func(int) int // 函数对象, 返回类型为 MyFunc func AddN(n int) MyFunc { return func(x int) int { return x + n } } func main() { // 创建一个函数对象 addTwo := AddN(2) // 调用函数对象 result := addTwo(3) fmt.Println(result) // 输出：5 } 分层设计的问题\n不同层次之间的如何转化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 type Response struct { StatusCode int32 `json:\u0026#34;status_code\u0026#34;` StatusMsg string `json:\u0026#34;status_msg,omitempty\u0026#34;` } type Video struct { Id int64 `json:\u0026#34;id,omitempty\u0026#34;` Author User `json:\u0026#34;author\u0026#34;` PlayUrl string `json:\u0026#34;play_url\u0026#34; json:\u0026#34;play_url,omitempty\u0026#34;` CoverUrl string `json:\u0026#34;cover_url,omitempty\u0026#34;` FavoriteCount int64 `json:\u0026#34;favorite_count,omitempty\u0026#34;` CommentCount int64 `json:\u0026#34;comment_count,omitempty\u0026#34;` IsFavorite bool `json:\u0026#34;is_favorite,omitempty\u0026#34;` } type Comment struct { Id int64 `json:\u0026#34;id,omitempty\u0026#34;` User User `json:\u0026#34;user\u0026#34;` Content string `json:\u0026#34;content,omitempty\u0026#34;` CreateDate string `json:\u0026#34;create_date,omitempty\u0026#34;` } type User struct { Id int64 `json:\u0026#34;id,omitempty\u0026#34;` Name string `json:\u0026#34;name,omitempty\u0026#34;` FollowCount int64 `json:\u0026#34;follow_count,omitempty\u0026#34;` FollowerCount int64 `json:\u0026#34;follower_count,omitempty\u0026#34;` IsFollow bool `json:\u0026#34;is_follow,omitempty\u0026#34;` } type Message struct { Id int64 `json:\u0026#34;id,omitempty\u0026#34;` Content string `json:\u0026#34;content,omitempty\u0026#34;` CreateTime string `json:\u0026#34;create_time,omitempty\u0026#34;` } type MessageSendEvent struct { UserId int64 `json:\u0026#34;user_id,omitempty\u0026#34;` ToUserId int64 `json:\u0026#34;to_user_id,omitempty\u0026#34;` MsgContent string `json:\u0026#34;msg_content,omitempty\u0026#34;` } type MessagePushEvent struct { FromUserId int64 `json:\u0026#34;user_id,omitempty\u0026#34;` MsgContent string `json:\u0026#34;msg_content,omitempty\u0026#34;` } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 type User struct { UserId int64 `gorm:\u0026#34;primary_key\u0026#34;` Name string // FollowingCount int64 `gorm:\u0026#34;default:(-)\u0026#34;` // FollowerCount int64 `gorm:\u0026#34;default:(-)\u0026#34;` Password string // Avatar string `gorm:\u0026#34;default:(-)\u0026#34;` // BackgroundImage string `gorm:\u0026#34;default:(-)\u0026#34;` Signature string // TotalFavorited int64 `gorm:\u0026#34;default:(-)\u0026#34;` // WorkCount int64 `gorm:\u0026#34;default:(-)\u0026#34;` // FavoriteCount int64 `gorm:\u0026#34;default:(-)\u0026#34;` // CreateAt time.Time // DeleteAt time.Time } type Video struct { VideoId int64 `gorm:\u0026#34;primaryKey\u0026#34;` UserId int64 PlayUrl string CoverUrl string FavoriteCount int64 CommentCount int64 // Title string `gorm:\u0026#34;default:(-)\u0026#34;` CreateAt time.Time UpdateAt time.Time DeleteAt time.Time } func GetUserDao() *UserDao func (*UserDao) CreateUser(user *User) (int64, error) func (*UserDao) FindUserByName(username string) (*User, error) func (d *UserDao) FindUserById(id int64) (*User, error) func GetVideoDao() *VideoDao func (*VideoDao) CreateVideo(video *Video) (*Video, error) func (d *VideoDao) FindVideoById(id int64) (*Video, error) func (*VideoDao) QueryVideoByUserId(userId int64) ([]*Video, error) // 根据时间和需要查询的条数，获取video列表 func (*VideoDao) QueryVideo(date *string, limit int) []*Video test Go 语言中的测试依赖 go test 命令。编写测试代码和编写普通的 Go 代码过程是类似的，并不需要学习新的语法、规则或工具。\ngo test 命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go 为后缀名的源代码文件都是 go test 测试的一部分，不会被 go build 编译到最终的可执行文件中。\n在 *_test.go 文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。\n类型 格式 作用 测试函数 函数名前缀为 Test 测试程序的一些逻辑行为是否正确 基准函数 函数名前缀为 Benchmark 测试函数的性能 示例函数 函数名前缀为 Example 为文档提供示例文档 Golang 单元测试对文件名和方法名，参数都有很严格的要求。\n文件名必须以xx_test.go命名\n方法必须是Test[^a-z]开头\n方法参数必须 t *testing.T\n使用go test执行单元测试\ngo test参数 1 go test [-c] [-i] [build flags] [packages] [flags for test binary] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // split/split.go package split import \u0026#34;strings\u0026#34; // split package with a single split function. // Split slices s into all substrings separated by sep and // returns a slice of the substrings between those separators. func Split(s, sep string) (result []string) { i := strings.Index(s, sep) for i \u0026gt; -1 { result = append(result, s[:i]) s = s[i+1:] i = strings.Index(s, sep) } result = append(result, s) return } 在当前目录下，我们创建一个 split_test.go 的测试文件，并定义一个测试函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // split/split_test.go package split import ( \u0026#34;reflect\u0026#34; \u0026#34;testing\u0026#34; ) func TestSplit(t *testing.T) { // 测试函数名必须以Test开头，必须接收一个*testing.T类型参数 got := Split(\u0026#34;a:b:c\u0026#34;, \u0026#34;:\u0026#34;) // 程序输出的结果 want := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} // 期望的结果 if !reflect.DeepEqual(want, got) { // 因为slice不能比较直接，借助反射包中的方法比较 t.Errorf(\u0026#34;excepted:%v, got:%v\u0026#34;, want, got) // 测试失败输出错误提示 } } 测试结果\n1 2 3 $ go test PASS ok main/ttt 0.002s log OS 1 2 3 4 5 6 // 如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于 I/O； func Create(name string) (file *File, err error) func Open(name string) (file *File, err error) func Rename(oldpath, newpath string) error IO 1、Reader 1 2 3 type Reader interface { Read(p []byte) (n int, err error) } Reader 是包装基本 Read 方法的接口。\nRead 最多将 len (p) 个字节读入 p。它返回读取的字节数 (0 \u0026lt;= n \u0026lt;= len (p)) 和遇到的错误。即使 Read 返回 n \u0026lt; len (p)，它也可能在调用期间使用所有 p 作为暂存空间。\n如果有一些数据可用，但长度不为 len (p) ，则 Read 通常会返回可用的数据，而不是等待更多数据。\n当 Read 遇到错误，或者在成功读取 n \u0026gt; 0 个字节后，遇到 end-of-file 条件时，返回读取的字节数。它可能会从同一次调用中返回（非空）错误，或者从后续调用中返回错误（并且 n == 0）。 这种情况一个例子是：Reader 在读取到输入流末尾时，返回一个非零的字节数，并返回 err == EOF 或者 err == nil。下一次读取应该返回 0，EOF。\n在考虑错误错误之前，调用者应始终处理返回的 n \u0026gt; 0 字节。这样做可以正确处理读取某些字节后发生的 I/O 错误以及允许的 EOF 行为。\n对于 Read 的实现，不鼓励同时返回零字节计数和 nil 错误，除非 len (p) == 0。 调用者应将返回 0 和 nil 视为表示没有发生任何事情；特别是它不表示 EOF。\n实现不得持有 p。\n2、Writer 1 2 3 type Writer interface { Write(p []byte) (n int, err error) } Writer 是封装了基本 Write 方法的接口。\nWrite 将 len (p) 个字节从 p 写入底层数据流。 它返回从 p (0 \u0026lt;= n \u0026lt;= len (p)) 写入的字节数，以及遇到的任何导致写入提前停止的错误。 如果返回 n \u0026lt;len (p)，则写入必须返回非零错误。 写入不能修改切片数据，即使是临时的。\n实现不得保留 p。\n3、Closer 1 2 3 type Closer interface { Close() error } Closer 是封装了基本 Close 方法的接口。\n第一次调用 Close 后的行为未定义。 具体实现的行为可以查看文档。\n4、Seeker 1 2 3 type Seeker interface { Seek(offset int64, whence int) (int64, error) } Seeker 是封装了基本 Seek 方法的接口。\nSeek 将下一次读取或写入的偏移量设置为偏移量，根据 wherece 进行解释：\nSeekStart 表示相对于文件的开头， SeekCurrent 表示相对于当前偏移量，并且 SeekEnd 表示相对于终点（例如，offset = -2 指定文件的倒数第二个字节）。 Seek 返回相对于文件开头的新偏移量或错误（如果有）。\nSeek 到开始之前的偏移量是错误的。 可以允许 Seek 任何正偏移量，但如果新偏移量超过底层对象的大小，则后续 I/O 操作的行为取决于实现。\nbufio bufio 是 Go 语言标准库中用于缓存 I/O 的包。当程序频繁进行 I/O 读写操作时，使用 bufio 包可以减少系统调用次数，大大提高程序性能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // NewReader 创建一个具有默认大小缓冲、从 r 读取的 * Reader。NewReader 相当于 NewReaderSize (rd, 4096) func NewReader(rd io.Reader) *Reader // NewReaderSize 创建一个具有最少有 size 尺寸的缓冲、从 r 读取的 Reader。如果参数 r 已经是一个具有足够大缓冲的 Reader 类型值，会返回 r。 func NewReaderSize(rd io.Reader, size int) *Reader // Reset 丢弃缓冲中的数据，清除任何错误，将 b 重设为其下层从 r 读取数据。 func (b *Reader) Reset(r io.Reader) // Buffered 返回缓冲中现有的可读取的字节数。 func (b *Reader) Buffered() int // 返回输入流的下 n 个字节, 而不会移动读取位置。 func (b *Reader) Peek(n int) ([]byte, error) string 1 2 // strings.NewReader() 可以方便地将一个字符串转换为实现了 io.Reader 接口的读取器 func NewReader(s string) *Reader GORM ORM（对象关系映射）框架是一种软件工具，用于在面向对象编程语言和关系型数据库之间建立映射关系。它提供了一种将数据库表格的数据映射到面向对象编程语言中的对象的方法，使得开发人员可以使用面向对象的方式来操作数据库。\nORM 框架的主要目标是解决对象模型与关系数据库之间的不匹配问题。在传统的关系型数据库中，数据是以表格的形式进行组织和存储的，而在面向对象编程语言中，数据是以对象的形式表示的。ORM 框架通过自动将对象转换为数据库中的表格以及表格中的行和列转换为对象的属性和关系，实现了面向对象编程语言和关系型数据库之间的无缝集成。\nORM 框架通常提供了一组 API 和工具，用于执行以下任务：\n对象关系映射：将数据库表格的数据映射到面向对象编程语言中的对象，并将对象的属性和关系映射到数据库的列和行。 数据库操作：提供了一组简化的方法来执行常见的数据库操作，如插入、更新、删除和查询数据。 数据库事务管理：支持事务操作，确保数据库操作的一致性和完整性。 查询语言：提供了一种类似于编程语言的接口，用于指定和执行复杂的数据库查询。 缓存管理：提供了缓存机制，以减少对数据库的频繁访问，并提高性能。 数据库迁移：简化数据库结构的变更和迁移操作，保证数据的一致性和无缝升级。 模型定义 | GORM - The fantastic ORM library for Golang, aims to be developer friendly.\ngo 语言 gorm 基本使用_go gorm_含光君～的博客 - CSDN 博客\nGorm使用名为ID的字段作为主键 GORM 支持 MySQLSQLServer、 PostgreSQLSQLite. demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import ( \u0026#34;gorm.io/driver/mysql\u0026#34; \u0026#34;gorm.io/gorm\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) type User struct { // 默认表名是`users` gorm.Model Name string } func main() { // refer https://github.com/go-sql-driver/mysql#dsn-data-source-name for details dsn := fmt.Sprintf(\u0026#34;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4\u0026amp;parseTime=True\u0026amp;loc=Local\u0026#34;, os.Getenv(\u0026#34;MYSQL_USER\u0026#34;), os.Getenv(\u0026#34;MYSQL_PASSWORD\u0026#34;), os.Getenv(\u0026#34;MYSQL_HOST\u0026#34;), os.Getenv(\u0026#34;MYSQL_PORT\u0026#34;), // conf.UserName, // conf.Password, // conf.Url, // conf.Port, conf.DBName, ) // 创建了一个新的 gorm.Config 对象，并将其作为参数传递给 Open 函数 db, err := gorm.Open(mysql.Open(dsn), \u0026amp;gorm.Config{}) if err != nil { panic(err) } // 自动迁移 db.AutoMigrate(\u0026amp;User{}) // 创建 db.Create(\u0026amp;User{Name: \u0026#34;张三\u0026#34;}) // 查询 res := User{} db.Where(\u0026amp;User{Name: \u0026#34;张三\u0026#34;}).First(\u0026amp;res) // 不为 字符串 db.Where(\u0026amp;models.User{UserId:17}).First(\u0026amp;user) db.Where(\u0026#34;user_id=?\u0026#34;, 18).First(\u0026amp;user) db.Find(\u0026amp;res, \u0026#34;hobby=?\u0026#34;, \u0026#34;足球\u0026#34;) // 批量查询 var list = make([]User, 9) models.SqlSession.Where(\u0026#34;user_id\u0026lt;?\u0026#34;, 18).Find(\u0026amp;list) fmt.Printf(\u0026#34;%+v\u0026#34;, list) // 输出了1~17 // 单列修改 // 该列名不存在，那么 GORM 将不会执行任何操作，也不会返回任何错误。 db.Model(\u0026amp;User{}).Where(\u0026#34;user_id = ?\u0026#34;, 17).Update(\u0026#34;name\u0026#34;, \u0026#34;changed\u0026#34;) // Close sqlDB, err := db.DB() sqlDB.Close() } 定义数据类型 字段 解释 autoIncrement 指定列为自动增长 primaryKey 将列定义为主键 unique 将列定义为唯一键 default 定义列的默认值 not null 指定列为 NOT NULL autoCreateTime 创建时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano/milli 来追踪纳秒、毫秒时间戳，例如：autoCreateTime:nano autoUpdateTime 创建 / 更新时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano/milli 来追踪纳秒、毫秒时间戳，例如：autoUpdateTime:milli 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 内部定义类型, 直接引用就好 type Model struct { ID uint `gorm:\u0026#34;primaryKey\u0026#34;` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:\u0026#34;index\u0026#34;` } // 对于匿名字段，GORM 会将其字段包含到其父结构中 // 表名默认是模型的复数形式，列名默认是字段名的驼峰形式 type User struct { // 默认表名是`users` gorm.Model Name string } // equals type User struct { ID uint `gorm:\u0026#34;primaryKey\u0026#34;` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:\u0026#34;index\u0026#34;` Name string } // default 的使用 type User struct { ID uint `gorm:\u0026#34;not null;comment:\u0026#39;用户ID\u0026#39;\u0026#34;` Name string `gorm:\u0026#34;type:varchar(50);default:\u0026#39;张三\u0026#39;;comment:\u0026#39;姓名\u0026#39;\u0026#34;` Age int `gorm:\u0026#34;default:\u0026#39;18\u0026#39;;comment:\u0026#39;年龄\u0026#39;\u0026#34;` } type User struct{ UserId int64 `gorm:\u0026#34;primary_key\u0026#34;` Name string Password string signature string CreatedAt time.Time `gorm:\u0026#34;default(autoCreateTime)\u0026#34;` // DeleteAt time.Time } 连接/ 关闭数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import ( \u0026#34;gorm.io/driver/mysql\u0026#34; \u0026#34;gorm.io/gorm\u0026#34; ) func main() { // refer https://github.com/go-sql-driver/mysql#dsn-data-source-name for details dsn := \u0026#34;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4\u0026amp;parseTime=True\u0026amp;loc=Local\u0026#34; // 创建了一个新的 gorm.Config 对象，并将其作为参数传递给 Open 函数 db, err := gorm.Open(mysql.Open(dsn), \u0026amp;gorm.Config{}) // Close sqlDB, err := db.DB() sqlDB.Close() } 使用环境变量连接数据库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) func main() { db, err := sql.Open(\u0026#34;mysql\u0026#34;, getConnectionString()) if err != nil { log.Fatal(err) } defer db.Close() err = db.Ping() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Connected to MySQL database!\u0026#34;) } func getConnectionString() string { server := os.Getenv(\u0026#34;MYSQL_HOST\u0026#34;) port := os.Getenv(\u0026#34;MYSQL_PORT\u0026#34;) user := os.Getenv(\u0026#34;MYSQL_USER\u0026#34;) password := os.Getenv(\u0026#34;MYSQL_PASSWORD\u0026#34;) database := \u0026#34;mydatabase\u0026#34; portInt, err := strconv.Atoi(port) if err != nil { log.Fatal(err) } return fmt.Sprintf(\u0026#34;%s:%s@tcp(%s:%d)/%s\u0026#34;, user, password, server, portInt, database) } dsn := fmt.Sprintf(\u0026#34;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4\u0026amp;parseTime=True\u0026amp;loc=Local\u0026#34;, conf.UserName, conf.Password, conf.Url, conf.Port, conf.DBName, ) 创建 GORM 在创建对象时不需要显式地指定要将其创建到哪张表中。GORM 会根据您定义的模型类和数据库的映射关系，自动确定要创建的表和列。\n您只需要定义模型类，并在需要时调用 Gorm 的创建方法即可。Gorm 会自动处理数据库操作，并确保在数据库中正确地创建对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 user := User{Name: \u0026#34;Jinzhu\u0026#34;, Age: 18, Birthday: time.Now()} result := db.Create(\u0026amp;user) // pass pointer of data to Create // 批量处理数据 users := []*User{ User{Name: \u0026#34;Jinzhu\u0026#34;, Age: 18, Birthday: time.Now()}, User{Name: \u0026#34;Jackson\u0026#34;, Age: 19, Birthday: time.Now()}, } result := db.Create(users) // pass a slice to insert multiple row // 如果 users 中的 user 已经存在于数据库中，则会返回一个错误。具体的错误类型和错误信息取决于所使用的 ORM 库和数据库驱动程序。 result.Error // returns error result.RowsAffected // returns inserted records count 简单查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 函数原型 DB.First(dest interface{}, conds ...interface{}) error // 获取第一条记录，按主键排序 db.First(\u0026amp;user); select * from users order by id limit 1; // 获取最后一条记录，按主键排序 db.Last(\u0026amp;user); select * from users order by id desc limit 1; // 获取所有记录 db.Find(\u0026amp;user); select * from users; // GORM 允许通过内联条件指定主键来检索对象，但只支持整形数值，因为 string 可能导致 SQL 注入。 // select * from users where id =10; db.First(\u0026amp;user,10); // 如果表里没有数据，会报错 result.Error返回:ErrRecordNotFound, // 检查 ErrRecordNotFound 错误 errors.Is(result.Error, gorm.ErrRecordNotFound) select 语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // select name, age from users; db.Select(\u0026#34;name\u0026#34;,\u0026#34;age\u0026#34;).Find(\u0026amp;user); db.Select([]string{\u0026#34;name\u0026#34;,\u0026#34;age\u0026#34;}).Find(\u0026amp;user); db.Table(\u0026#34;users\u0026#34;).Select(\u0026#34;COALESCE(age,?)\u0026#34;, 42).Rows() SELECT COALESCE(age,\u0026#39;42\u0026#39;) FROM users; // Struct db.Where(\u0026amp;User{Name: \u0026#34;jinzhu\u0026#34;, Age: 20}).First(\u0026amp;user) // SELECT * FROM users WHERE name = \u0026#34;jinzhu\u0026#34; AND age = 20 ORDER BY id LIMIT 1; // Map db.Where(map[string]interface{}{\u0026#34;name\u0026#34;: \u0026#34;jinzhu\u0026#34;, \u0026#34;age\u0026#34;: 20}).Find(\u0026amp;users) // SELECT * FROM users WHERE name = \u0026#34;jinzhu\u0026#34; AND age = 20; // 主键切片条件 db.Where([]int64{20, 21, 22}).Find(\u0026amp;users) // SELECT * FROM users WHERE id IN (20, 21, 22); 返回多条记录 1 2 3 4 5 6 var userList []gorme.User // 指针查询字段 result := mysqlClient.Select(\u0026#34;id\u0026#34;, \u0026#34;nick_name\u0026#34;).Find(\u0026amp;userList) for _, user := range userList { fmt.Printf(\u0026#34;id: %d nick_name: %s \\n\u0026#34;, user.ID, user.NickName) } 更新 1 2 3 4 5 6 7 8 9 10 11 12 13 func (db *DB) Update(column string, value interface{}) (tx *DB) // 条件更新 db.Model(\u0026amp;User{}).Where(\u0026#34;active = ?\u0026#34;, true).Update(\u0026#34;name\u0026#34;, \u0026#34;hello\u0026#34;) // UPDATE users SET name=\u0026#39;hello\u0026#39;, updated_at=\u0026#39;2013-11-17 21:34:10\u0026#39; WHERE active=true; // User 的 ID 是 `111` db.Model(\u0026amp;user).Update(\u0026#34;name\u0026#34;, \u0026#34;hello\u0026#34;) // UPDATE users SET name=\u0026#39;hello\u0026#39;, updated_at=\u0026#39;2013-11-17 21:34:10\u0026#39; WHERE id=111; // 根据条件和 model 的值进行更新 db.Model(\u0026amp;user).Where(\u0026#34;active = ?\u0026#34;, true).Update(\u0026#34;name\u0026#34;, \u0026#34;hello\u0026#34;) // UPDATE users SET name=\u0026#39;hello\u0026#39;, updated_at=\u0026#39;2013-11-17 21:34:10\u0026#39; WHERE id=111 AND active=true; 不存在则创建 1 db.FirstOrCreate(\u0026amp;user, User{Name: \u0026#34;John Doe\u0026#34;}) net/ http Http・Go 语言中文文档 (topgoer.com)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func Hello(w http.ResponseWriter, r *http.Request) { fmt.Println(\u0026#34;handle hello\u0026#34;)\t// 服务端打印输出 fmt.Fprintf(w, \u0026#34;hello GoLangWEB\u0026#34;) } func login(w http.ResponseWriter, r *http.Request) { fmt.Println(\u0026#34;handle login\u0026#34;)\t// 服务端打印输出 fmt.Fprintf(w, \u0026#34;login...\u0026#34;) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, Hello)\t// 匹配根路由 http.HandleFunc(\u0026#34;/login\u0026#34;, login)\t// 匹配根路由/login err := http.ListenAndServe(\u0026#34;0.0.0.0:8080\u0026#34;, nil) if err != nil{ fmt.Println(\u0026#34;http listen failed\u0026#34;) } } 客户端方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 resp, err := http.Get(\u0026#34;http://5lmh.com/\u0026#34;) // 程序在使用完 response 后必须关闭回复的主体。 if err != nil { // handle error } defer resp.Body.Close() ... resp, err := http.Post(\u0026#34;http://5lmh.com/upload\u0026#34;, \u0026#34;image/jpeg\u0026#34;, \u0026amp;buf) ... resp, err := http.PostForm(\u0026#34;http://5lmh.com/form\u0026#34;, url.Values{\u0026#34;key\u0026#34;: {\u0026#34;Value\u0026#34;}, \u0026#34;id\u0026#34;: {\u0026#34;123\u0026#34;}}) body, err := ioutil.ReadAll(resp.Body) // ... 客户端参数 net/url 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func ParseRequestURI(requestURI string) (*url.URL, error) // requestURI 是要解析的 URL 请求 URI，而返回值是一个指向 url.URL 结构体的指针 type URL struct { Scheme string // 协议，例如 \u0026#34;http\u0026#34;、\u0026#34;https\u0026#34; 等 Opaque string // 不透明部分，用于存储不透明数据，例如 \u0026#34;//example.com/path\u0026#34; User string // 用户名，例如 \u0026#34;user\u0026#34; Password string // 密码，例如 \u0026#34;passwd\u0026#34; Host string // 域名或 IP 地址，例如 \u0026#34;example.com\u0026#34; 或 \u0026#34;127.0.0.1\u0026#34; port string // 端口号，例如 \u0026#34;8080\u0026#34; path string // 路径，例如 \u0026#34;/path/to/file.html\u0026#34; query string // 查询字符串，例如 \u0026#34;key1=value1\u0026amp;key2=value2\u0026#34; fragment string // 片段标识符，例如 \u0026#34;#fragment\u0026#34; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // net/url 处理带参数的请求 func main() { apiUrl := \u0026#34;http://127.0.0.1:9090/get\u0026#34; // URL param data := url.Values{} data.Set(\u0026#34;name\u0026#34;, \u0026#34;枯藤\u0026#34;) data.Set(\u0026#34;age\u0026#34;, \u0026#34;18\u0026#34;) u, err := url.ParseRequestURI(apiUrl) if err != nil { fmt.Printf(\u0026#34;parse url requestUrl failed,err:%v\\n\u0026#34;, err) } u.RawQuery = data.Encode() // URL encode fmt.Println(u.String()) resp, err := http.Get(u.String()) if err != nil { fmt.Println(\u0026#34;post failed, err:%v\\n\u0026#34;, err) return } defer resp.Body.Close() b, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(\u0026#34;get resp failed,err:%v\\n\u0026#34;, err) return } fmt.Println(string(b)) } post方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strings\u0026#34; ) // net/http post demo func main() { url := \u0026#34;http://127.0.0.1:9090/post\u0026#34; // 表单数据 //contentType := \u0026#34;application/x-www-form-urlencoded\u0026#34; //data := \u0026#34;name=枯藤\u0026amp;age=18\u0026#34; // json contentType := \u0026#34;application/json\u0026#34; data := `{\u0026#34;name\u0026#34;:\u0026#34;枯藤\u0026#34;,\u0026#34;age\u0026#34;:18}` resp, err := http.Post(url, contentType, strings.NewReader(data)) if err != nil { fmt.Println(\u0026#34;post failed, err:%v\\n\u0026#34;, err) return } defer resp.Body.Close() b, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(\u0026#34;get resp failed,err:%v\\n\u0026#34;, err) return } fmt.Println(string(b)) } 服务器端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // http server func sayHello(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, \u0026#34;Hello 枯藤！\u0026#34;) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, sayHello) err := http.ListenAndServe(\u0026#34;:9090\u0026#34;, nil) if err != nil { fmt.Printf(\u0026#34;http server failed, err:%v\\n\u0026#34;, err) return } } gin 官方文档\nGin 的基本架构：\nRouter：它是 Gin 应用程序的核心部分，它接收 HTTP 请求并根据请求的路径和 HTTP 方法将其路由到正确的处理程序。 Handlers：它是 Gin 应用程序中的业务逻辑代码，它接收 HTTP 请求并返回 HTTP 响应。 Middleware：它是在 HTTP 请求和处理程序之间发生的代码。它可以用来完成一些常见的操作，如身份验证、日志记录、处理请求等。 gin.context Context 是gin中最重要的部分。 例如，它允许我们在中间件之间传递变量、管理流程、验证请求的 JSON 并呈现 JSON 响应。 Context 中封装了原生的 Go http 请求和响应对象，同时还提供了一些方法，用于获取请求和响应的信息、设置响应头、设置响应状态码等操作。 在 Gin 中，Context 是通过中间件来传递的。在处理 HTTP请求 时，Gin 会依次执行注册的中间件，每个中间件可以对 Context 进行一些操作，然后将 Context 传递给下一个中间件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 type Context struct { writermem responseWriter Request *http.Request Writer ResponseWriter Params Params handlers HandlersChain index int8 fullPath string engine *Engine params *Params skippedNodes *[]skippedNode // 该互斥锁保护键映射。 mu sync.RWMutex // Keys 是专门用于每个请求上下文的键/值对。 Keys map[string]any // 错误是附加到使用此上下文的所有处理程序/中间件的错误列表。 Errors errorMsgs // 已接受定义了用于内容协商的手动接受格式的列表。 Accepted []string // queryCache 缓存 c.Request.URL.Query() 的查询结果。 queryCache url.Values // formCache 缓存 c.Request.PostForm，其中包含从 POST、PATCH 或 PUT 正文参数解析的表单数据。\tformCache url.Values // SameSite 允许服务器定义 cookie 属性，从而使浏览器无法随跨站点请求发送此 cookie。 sameSite http.SameSite } 下面是 Context 提供的一些常用方法：\nContext.Key ()：获取上下文中的键值。 Context.Get ()：获取上下文中的值，如果不存在则返回默认值。 Context.Set ()：设置上下文中的值。 Context.Map ()：获取上下文中的所有键值对。 Context.PostForm ()：获取请求的表单数据。 Context.Query ()：获取请求的查询字符串参数。 Context.Param ()：获取请求的路径参数。 Context.Cookie ()：获取请求的 cookie。 Context.Redirect ()：重定向到指定的 URL。 Context.Render ()：渲染模板并返回响应。 Context.String ()：返回一个字符串响应。 Context.HTML ()：返回一个 HTML 响应。 Context.JSON ()：返回一个 JSON 响应。 Context.XML ()：返回一个 XML 响应。 快速使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { // 创建一个Gin路由器 r := gin.Default() // 定义路由 r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;Hello World!\u0026#34;, }) }) r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;pong!\u0026#34;, }) }) r.POST(\u0026#34;/submit\u0026#34;, func(c *gin.Context) { var json struct { Name string `json:\u0026#34;name\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` } if err := c.Bind(\u0026amp;json); err == nil { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;JSON received\u0026#34;, \u0026#34;name\u0026#34;: json.Name, \u0026#34;email\u0026#34;: json.Email, }) } else { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: err.Error()}) } }) // 启动Gin应用程序 r.Run() } json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { r := gin.Default() r.GET(\u0026#34;/someJSON\u0026#34;, func(c *gin.Context) { data := map[string]interface{}{ \u0026#34;lang\u0026#34;: \u0026#34;GO语言\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;\u0026lt;br\u0026gt;\u0026#34;, } // 输出 : {\u0026#34;lang\u0026#34;:\u0026#34;GO\\u8bed\\u8a00\u0026#34;,\u0026#34;tag\u0026#34;:\u0026#34;\\u003cbr\\u003e\u0026#34;} c.AsciiJSON(http.StatusOK, data) }) // 监听并在 0.0.0.0:8080 上启动服务 r.Run(\u0026#34;:8080\u0026#34;) } 获取参数 可以通过 Context 的 Param 方法来获取 API 参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;net/http\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { r := gin.Default() r.GET(\u0026#34;/user/:name/*action\u0026#34;, func(c *gin.Context) { name := c.Param(\u0026#34;name\u0026#34;) action := c.Param(\u0026#34;action\u0026#34;) //截取/ action = strings.Trim(action, \u0026#34;/\u0026#34;) c.String(http.StatusOK, name+\u0026#34; is \u0026#34;+action) }) //默认为监听8080端口 r.Run(\u0026#34;:8000\u0026#34;) } 其中 :name 和 *action 都是动态参数。当客户端向服务器发送 GET /user/小明/list 的请求时，服务器将匹配到该路由，并将 小明 和 list 两个参数的值分别赋值给 :name 和 *action。\n在 Go 语言的路由匹配中，: 和 * 符号具有不同的含义：\n: 符号表示一个动态参数，它可以匹配任意长度的字符串，包括空字符串。例如，r.GET(\u0026quot;/user/:name\u0026quot;) 表示一个处理 GET 请求的路由，其中 :name 是一个动态参数，它可以匹配任意长度的字符串，包括空字符串。 * 符号表示一个可选的动态参数，它可以匹配任意长度的字符串，但不能为空字符串。例如，r.GET(\u0026quot;/user/:name/*action\u0026quot;) 表示一个处理 GET 请求的路由，其中 :name 是一个动态参数，而 *action 是一个可选的动态参数。当客户端向服务器发送 GET /user/小明/list 的请求时，服务器将匹配到该路由，并将 小明 和 list 两个参数的值分别赋值给 :name 和 *action。但是，如果客户端发送 GET /user/小明 的请求，则服务器将无法匹配该路由，因为 *action 参数不能为空字符串。 路由 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;fmt\u0026#34; ) // gin的helloWorld func main() { // 1.创建路由 // 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // 路由组1 ，处理GET请求 v1 := r.Group(\u0026#34;/v1\u0026#34;) // {} 是书写规范 { v1.GET(\u0026#34;/login\u0026#34;, login) v1.GET(\u0026#34;submit\u0026#34;, submit) } v2 := r.Group(\u0026#34;/v2\u0026#34;) { v2.POST(\u0026#34;/login\u0026#34;, login) v2.POST(\u0026#34;/submit\u0026#34;, submit) } r.Run(\u0026#34;:8000\u0026#34;) } func login(c *gin.Context) { name := c.DefaultQuery(\u0026#34;name\u0026#34;, \u0026#34;jack\u0026#34;) c.String(200, fmt.Sprintf(\u0026#34;hello %s\\n\u0026#34;, name)) } func submit(c *gin.Context) { name := c.DefaultQuery(\u0026#34;name\u0026#34;, \u0026#34;lily\u0026#34;) c.String(200, fmt.Sprintf(\u0026#34;hello %s\\n\u0026#34;, name)) } GET /user//res是合法的么\n1 GET /user/ /res 因为 GET 请求的路径中包含了两个连续的 / 符号，所以它将匹配到 GET /user//res 这个路由。在这个路由中，两个 / 符号之间的部分是一个可选的动态参数，它可以是任意长度的字符串，但不能为空字符串。因此，如果客户端向服务器发送 GET /user//res 的请求，则服务器将匹配到该路由，并将 res 参数的值赋值给该动态参数。\n中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // 定义中间 func MiddleWare() gin.HandlerFunc { return func(c *gin.Context) { t := time.Now() fmt.Println(\u0026#34;中间件开始执行了\u0026#34;) // 设置变量到Context的key中，可以通过Get()取 c.Set(\u0026#34;request\u0026#34;, \u0026#34;中间件\u0026#34;) // 执行函数 c.Next() // 中间件执行完后续的一些事情 status := c.Writer.Status() fmt.Println(\u0026#34;中间件执行完毕\u0026#34;, status) t2 := time.Since(t) fmt.Println(\u0026#34;time:\u0026#34;, t2) } } func main() { // 1.创建路由 // 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // 注册中间件 r.Use(MiddleWare()) // {}为了代码规范 { r.GET(\u0026#34;/ce\u0026#34;, func(c *gin.Context) { // 取值 req, _ := c.Get(\u0026#34;request\u0026#34;) fmt.Println(\u0026#34;request:\u0026#34;, req) // 页面接收 c.JSON(200, gin.H{\u0026#34;request\u0026#34;: req}) }) } r.Run() } 日志 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { // 禁用控制台颜色，将日志写入文件时不需要控制台颜色。 gin.DisableConsoleColor() // 记录到文件。 f, _ := os.Create(\u0026#34;gin.log\u0026#34;) gin.DefaultWriter = io.MultiWriter(f) // 如果需要同时将日志写入文件和控制台，请使用以下代码。 // gin.DefaultWriter = io.MultiWriter(f, os.Stdout) router := gin.Default() router.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;pong\u0026#34;) }) router.Run(\u0026#34;:8080\u0026#34;) } 回复 1 2 3 4 5 6 7 // 回复 json 字符串 func JSON(c *Context, code int, obj interface{}) error c.JSON(200, map[string]interface{}{ \u0026#34;message\u0026#34;: \u0026#34;Hello, World!\u0026#34;, }) gin 项目目录结构 其中：\nconfigs 目录包含项目的配置文件 controllers 目录包含控制器文件 middleware 目录包含中间件文件 models 目录包含模型（ORM）文件 routes 目录包含路由文件 services 目录包含服务文件 utils 目录包含多个工具文件 main.go 是项目的入口文件，README.md 是项目的介绍文件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ├── configs │ ├── config.yaml │ └── db.yaml ├── controllers │ ├── auth_controller.go │ └── user_controller.go ├── middleware │ ├── auth_middleware.go │ └── logger_middleware.go ├── models │ ├── db.go │ ├── user.go │ └── ... ├── routes │ └── routes.go ├── services │ ├── auth_service.go │ └── user_service.go ├── utils │ ├── response.go │ └── ... ├── main.go └── README.md YAML go-yaml/yaml: YAML support for the Go language. (github.com)\n官方文档\nYAML 全称是 ”YAML Ain’t a Markup Language” 的递归缩写，该语言的设计参考了 JSON / XML 和 SDL 等语言，强调以数据为中心，简洁易读，编写简单。\n语法特点 大小写敏感 通过缩进表示层级关系 禁止使用 tab 缩进，只能使用空格键 缩进的空格数目不重要，只要相同层级左对齐 使用 # 表示注释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 以下是yaml languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org # 以下是Json { languages: [ \u0026#39;Ruby\u0026#39;, \u0026#39;Perl\u0026#39;, \u0026#39;Python\u0026#39; ], websites: { YAML: \u0026#39;yaml.org\u0026#39;, Ruby: \u0026#39;ruby-lang.org\u0026#39;, Python: \u0026#39;python.org\u0026#39;, Perl: \u0026#39;use.perl.org\u0026#39; } } 属性 omitempty 是一个属性，用于指示该字段是否可以为空。如果这些字段没有值，它们将不会被序列化到 YAML 文件中 使用说明 1 func Marshal(in interface{}) (out []byte, err error) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gopkg.in/yaml.v3\u0026#34; ) var data = ` a: Easy! b: c: 2 d: [3, 4] ` // Note: struct fields must be public in order for unmarshal to // correctly populate the data. type T struct { A string B struct { RenamedC int `yaml:\u0026#34;c\u0026#34;` D []int `yaml:\u0026#34;,flow\u0026#34;` } } func main() { t := T{} err := yaml.Unmarshal([]byte(data), \u0026amp;t) if err != nil { log.Fatalf(\u0026#34;error: %v\u0026#34;, err) } fmt.Printf(\u0026#34;--- t:\\n%v\\n\\n\u0026#34;, t) d, err := yaml.Marshal(\u0026amp;t) if err != nil { log.Fatalf(\u0026#34;error: %v\u0026#34;, err) } fmt.Printf(\u0026#34;--- t dump:\\n%s\\n\\n\u0026#34;, string(d)) m := make(map[interface{}]interface{}) err = yaml.Unmarshal([]byte(data), \u0026amp;m) if err != nil { log.Fatalf(\u0026#34;error: %v\u0026#34;, err) } fmt.Printf(\u0026#34;--- m:\\n%v\\n\\n\u0026#34;, m) d, err = yaml.Marshal(\u0026amp;m) if err != nil { log.Fatalf(\u0026#34;error: %v\u0026#34;, err) } fmt.Printf(\u0026#34;--- m dump:\\n%s\\n\\n\u0026#34;, string(d)) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 --- t: {Easy! {2 [3 4]}} --- t dump: a: Easy! b: c: 2 d: [3, 4] --- m: map[a:Easy! b:map[c:2 d:[3 4]]] --- m dump: a: Easy! b: c: 2 d: - 3 - 4 jwt 摘要 golang-jwt/jwt: Community maintained clone of https://github.com/dgrijalva/jwt-go\nStarting with v4.0.0 this project adds Go module support\n在介绍 JWT 之前，我们先来回顾一下利用 token 进行用户身份验证的流程：\n客户端使用用户名和密码请求登录 服务端收到请求，验证用户名和密码 验证成功后，服务端会签发一个 token，再把这个 token 返回给客户端 客户端收到 token 后可以把它存储起来，比如放到 cookie 中 客户端每次向服务端请求资源时需要携带服务端签发的 token，可以在 cookie 或者 header 中携带 服务端收到请求，然后去验证客户端请求里面带着的 token，如果验证成功，就向客户端返回请求数据 这种基于 token 的认证方式相比传统的 session 认证方式更节约服务器资源，并且对移动端和分布式更加友好。其优点如下：\nJWT 在线解码 - 开发工具箱 (box3.cn)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJsaXF3ZXR0IiwiZXhwIjoxNjkzMjk1MDY3LCJpYXQiOjE2OTMyMDg2NjgsImlzcyI6ImRlbW8iLCJuYmYiOjE2OTMyMDg2Njh9.GWPbzwiNBsCuAeE_dbn21xjAlGpK7Xh683F4-X1NPJc { \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } { \u0026#34;aud\u0026#34;: \u0026#34;liqwett\u0026#34;, \u0026#34;exp\u0026#34;: 1693295067, \u0026#34;iat\u0026#34;: 1693208668, # 发行人 \u0026#34;iss\u0026#34;: \u0026#34;demo\u0026#34;, \u0026#34;nbf\u0026#34;: 1693208668 } 结构 JWT 由 3 部分组成：标头 (Header)、有效载荷 (Payload) 和签名 (Signature)\nHeader\nJWT 头是一个描述 JWT 元数据的 JSON 对象，alg 属性表示签名使用的算法，默认为 HMAC SHA256（写为 HS256）；typ 属性表示令牌的类型，JWT 令牌统一写为 JWT。最后，使用 Base64 URL 算法将上述 JSON 对象转换为字符串保存\n1 2 3 4 { \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } Playload \u0026mdash;有效荷载部分\n默认情况下 JWT 是未加密的，因为只是采用 base64 算法，拿到 JWT 字符串后可以转换回原本的 JSON 数据，任何人都可以解读其内容，因此不要构建隐私信息字段，比如用户的密码一定不能保存到 JWT 中，以防止信息泄露。 JWT 只是适合在网络中传输一些非敏感的信息\njwt 指定七个默认字段共选择\n1 2 3 4 5 6 7 iss：发行人 exp：到期时间 sub：主题 aud：用户 nbf：在此之前不可用 iat：发布时间 jti：JWT ID用于标识该JWT 也可以定义私有字段, 一般吧包含用户信息的数据放到playload中\n1 2 3 4 5 { \u0026#34;sub\u0026#34;: \u0026#34;1234567890\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Helen\u0026#34;, \u0026#34;admin\u0026#34;: true } signature\n需要指定一个密钥（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。 使用 header 中指定的签名算法（默认情况下为 HMAC SHA256）根据以下公式生成签名 $\\text{HMACSHA256}(\\text{base}64\\text{UrlEncode}(\\text{header})+\\text{“.”}+\\text{base}64\\text{UrlEncode}(\\text{payload}),\\text{secret})$\n在计算出签名哈希后，JWT 头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用. 分隔，就构成整个 JWT 对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 base64enc({ \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; }) . base64enc({ \u0026#34;iss\u0026#34;: \u0026#34;toptal.com\u0026#34;, \u0026#34;exp\u0026#34;: 1426420800, \u0026#34;company\u0026#34;: \u0026#34;Toptal\u0026#34;, \u0026#34;awesome\u0026#34;:true }) . HMACSHA256( base64enc(header)+ \u0026#39;.\u0026#39;+ base64enc(payload) , secretKey ) 签名算法 到目前为止，jwt 的签名算法有三种：\nHMAC【哈希消息验证码 (对称)】：HS256/HS384/HS512 RSASSA【RSA 签名算法 (非对称)】（RS256/RS384/RS512） ECDSA【椭圆曲线数据签名算法 (非对称)】（ES256/ES384/ES512） jwt 产生的 token 还需要加密么 签名的目的是为了验证 JWT 的完整性和真实性。当服务器接收到 JWT 时，它可以使用相同的密钥对 JWT 进行解密和验证签名。如果签名验证成功，服务器可以相信 JWT 中的数据是可信的。\n因此，一般情况下，JWT 的签名已经提供了足够的安全性，不需要额外的加密。然而，如果你对数据的保密性有更高的要求，你可以使用加密算法对载荷部分进行加密，然后将加密后的数据放入 JWT 的载荷中。\n在传输 JWT 时可能会被其他人窃取，这确实存在一定的风险。JWT 本身是基于文本的，因此在传输过程中可能会被截获或窃取。\n为了减轻这种风险，有几个常见的做法可以采用：\n使用 HTTPS：使用 HTTPS 协议进行通信可以加密传输的数据，从而提供更高的安全性。这样，即使 JWT 被截获，攻击者也无法轻易解密和篡改其中的数据。 限制 JWT 的有效期：在生成 JWT 时，可以设置一个较短的有效期，使得 JWT 在一段时间后自动失效。这样即使 JWT 被截获，攻击者也只能在有效期内使用，有效期过后就无法继续使用。 避免在 JWT 中存储敏感信息：尽量避免将敏感信息直接存储在 JWT 的载荷中，特别是不要将密码等敏感凭据放在 JWT 中。如果需要传递敏感信息，可以考虑使用加密算法对敏感数据进行加密，然后将加密后的数据放入 JWT 的载荷中。 使用签名验证：在服务器端接收到 JWT 后，始终要进行签名验证，确保 JWT 的完整性和真实性。如果签名验证失败，说明 JWT 可能已被篡改，应该拒绝接受该 JWT。 使用说明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/golang-jwt/jwt/v4\u0026#34; ) func main() { // 创建秘钥 key := []byte(\u0026#34;aaa\u0026#34;) // 创建Token结构体 claims := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{ \u0026#34;user\u0026#34;: \u0026#34;zhangshan\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;123123\u0026#34;, }) // 调用加密方法，发挥Token字符串 signingString, err := claims.SignedString(key) if err != nil { return } fmt.Println(signingString) // 根据Token字符串解析成Claims结构体 _, err = jwt.ParseWithClaims(signingString, jwt.MapClaims{}, func(token *jwt.Token) (interface{}, error) { fmt.Println(token.Header) return []byte(\u0026#34;aaa\u0026#34;), nil }) if err != nil { fmt.Println(err) return } } //这边是输出结果 \u0026amp;{ 0xc0000c2690 map[alg:ES256 typ:JWT] map[user:zhangshan] false} // 这是加密后的字符串 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXNzIjoiMTIzMTIzIiwidXNlciI6InpoYW5nc2hhbiJ9.-2-xIJXMGKV-GyhM24OKbDVqWs4dsIANBsGhzXEfEFM structmapper (github.com) 结构映射器\n实际项目开发中，需要各个层的数据流转，entity 转换到 domain，domain 转换到 response，常见实现的方式基本都是通过反射机制实现，例如 Spring BeanUtils. copyProperties，Golang 的 copier 第三方库，反射的效率众所周知，基本都是惨不忍睹。\n当然也可以手动一个个的赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type User struct { ID int Mobile string Level int Name string RegisterTime time.Time } func (u *User) Mapping (from *User) { u.ID = from.ID u.Mobile = from.Mobile u.Level = from.Level u.Name = from.Name u.RegisterTime = from.RegisterTime } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 //go:generate go run github.com/wizardshan/structmapper -toName User -fromName User -toPath ./response -fromPath ./domain -toVar resp -fromVar dom //go:generate go run github.com/wizardshan/structmapper -toName Orders -fromName Orders -toPath ./response -fromPath ./domain -toVar resp -fromVar dom package response type Users []*User type User struct { ID int `json:\u0026#34;id\u0026#34;` CreateTime DateTime `json:\u0026#34;createTime\u0026#34;` UpdateTime *DateTime `json:\u0026#34;updateTime\u0026#34;` DeleteTime *DateTime `json:\u0026#34;deleteTime\u0026#34;` Mobile string `json:\u0026#34;mobile\u0026#34;` Nickname string `json:\u0026#34;nickname\u0026#34;` Money Money `json:\u0026#34;money\u0026#34;` Level int `json:\u0026#34;level\u0026#34;` } package domain type Users []*User type User struct { ID int CreateTime time.Time UpdateTime *time.Time Mobile string Nickname string Money int } func (dom *User) Level() int { return 1 } user_mapping.go func (resp *User) Mapping(dom *domain.User) { /**************** mapping start ****************/ resp.ID = dom.ID resp.CreateTime = DateTime(dom.CreateTime) if dom.UpdateTime != nil { updateTime := DateTime(*dom.UpdateTime) resp.UpdateTime = \u0026amp;(updateTime) } //resp.DeleteTime = fromStruct property not exist resp.Mobile = dom.Mobile resp.Nickname = dom.Nickname resp.Money = Money(dom.Money) resp.Level = dom.Level() /**************** mapping end ****************/ } orders_mapping.go func (resp *Orders) Mapping(dom domain.Orders) { /**************** mapping start ****************/ domOrdersLen := len(dom) *resp = make(Orders, domOrdersLen) if domOrdersLen \u0026gt; 0 { for domOrdersIndex := 0; domOrdersIndex \u0026lt; domOrdersLen; domOrdersIndex++ { domOrdersItem := dom[domOrdersIndex] respOrder := new(Order) respOrder.ID = domOrdersItem.ID respOrder.Status = domOrdersItem.Status respOrder.Consignee = domOrdersItem.Consignee respOrder.Mobile = domOrdersItem.Mobile respOrder.Province = domOrdersItem.Province respOrder.City = domOrdersItem.City respOrder.Expired = domOrdersItem.Expired() if domOrdersItem.Shop != nil { respOrderShop := new(Shop) respOrderShop.ID = domOrdersItem.Shop.ID respOrderShop.Name = domOrdersItem.Shop.Name respOrder.Shop = respOrderShop } domOrdersItemItemsLen := len(domOrdersItem.Items) respOrderItems := make([]*Item, domOrdersItemItemsLen) if domOrdersItemItemsLen \u0026gt; 0 { for domOrdersItemItemsIndex := 0; domOrdersItemItemsIndex \u0026lt; domOrdersItemItemsLen; domOrdersItemItemsIndex++ { domOrdersItemItemsItem := domOrdersItem.Items[domOrdersItemItemsIndex] respOrderItem := new(Item) respOrderItem.ID = domOrdersItemItemsItem.ID respOrderItem.Title = domOrdersItemItemsItem.Title respOrderItem.Price = Money(domOrdersItemItemsItem.Price) respOrderItems[domOrdersItemItemsIndex] = respOrderItem } } respOrder.Items = respOrderItems (*resp)[domOrdersIndex] = respOrder } } /**************** mapping end ****************/ } hertz thriftgo是什么\nthriftgo 是 Thrift 协议的 Go 语言实现。Thrift 是一种跨语言的服务框架，它可以帮助开发人员在不同的编程语言之间进行通信和数据交换。\nthriftgo 是一个开源的项目，它提供了一个用于生成 Thrift 服务和客户端代码的 Go 语言库。使用 thriftgo，开发人员可以轻松地定义 Thrift 服务契约，生成服务端和客户端代码，并在不同的语言之间进行通信。\nthriftgo 的主要特点如下：\n支持多种语言：thriftgo 可以生成多种语言的代码，包括 Go、Java、C++、Python 等。 简单易用：thriftgo 提供了一个简单的 API，可以帮助开发人员快速生成 Thrift 服务和客户端代码。 高效：thriftgo 使用了 Thrift 协议的二进制编码方式，可以提高通信的效率。 可扩展：thriftgo 支持多种拓展功能，如可定制的生成代码、多种序列化方式等。 总之，thriftgo 是一个非常实用的工具，可以帮助开发人员快速实现跨语言的通信和数据交换。\nprotoc是什么\nprotoc 是 Protocol Buffers 协议的编译器，它用于将定义的 Protocol Buffers 协议文件（.proto 文件）转换成对应的编程语言代码，如 Java、C++、Python 等。Protocol Buffers 是一种用于数据交换的二进制格式，它可以在不同的编程语言和平台之间进行数据交换。\nprotoc 是一个命令行工具，可以在命令行中使用，也可以在代码中调用。使用 protoc 可以极大地简化 Protocol Buffers 协议的使用，减少代码的耦合度，提高代码的可读性和可维护性。\n使用 protoc 编译 Protocol Buffers 协议文件的语法如下：\n","date":"2023-08-17T09:43:00Z","permalink":"https://li54426.github.io/p/go_%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/","title":"Go_常用框架/中间件"},{"content":" content {:toc} 1024 相关/ 项目 1 简介 拿到邀请码以后再去注册\n主要功能\n在线多人协作, 包括代码 code 在线分享: 类似于 kaggle 助手: gpt Git版本管理: Git Commit,管理你的代码版本 数据库: 云端数据库 建议 创建 github仓库\n‌‌‌⁢⁤﻿‍⁣‍‌‬‌‌﻿﻿﻿⁡⁣⁤‌⁡﻿⁣⁤‬⁣‬﻿﻿‍⁡⁢⁡⁣‬⁣⁡⁡⁤⁡‌1024Code 组队协作编程流程说明文档（后端） - 飞书云文档 (feishu.cn)\n产品简介 | 1024Code 文档中心\n2 github 联动 添加公钥到 GitHub/Gitee/GitLab\n打开个人中心设置页面复制个人的 SSH 公钥：添加到你的 GitHub/Gitee/GitLab 账户中：\n创建一个和代码空间同名的远程仓库，或在已存在的远程仓库中复制该仓库地址，如：git@github.com:li382112772/SimpleNES.git 3 创建团队 登录1024Code账号,进入工作台后,点击我的团队区域的\u0026quot;创建团队\u0026ldquo;功能按钮创建团队. 上传团队头像,填写团队名称以及团队简介信息后创建团队. 在团队工作台成员页面,添加或使用链接邀请成员加入团队. 在对团队成员列表里,可以更改成员角色、移出团队成员,可更改的角色包括:\n成员:可自由创建团队代码空间,可见团队所有代码空间,但不可编辑自己未加入协作的代码空间 管理员:可自由创建团队代码空间,可见并可主动加入所有团队代码空间进行协作编辑,可处理团队加入申请、可管理团队 所有者:拥有管理员全部权限的同时,可移交团队给其他成员(将其他成员设为所有者) 4 1024 创建代码空间 进入团队工作台,点击新建按钮选择 Go1.17环境模版,给团队创建代码空间: 代码空间创建成功后,在终端 shell中使用 git clone命令从服务端 Demo仓库(https://github.com/RaymondCode/simple-demo) clone项代码 或者直接Fork现成的项目demo代码空间:抖音项目服务端Demo - 1024Code 邀请队员加入代码空间协作\n在代码空间中点击协作浮窗,搜索添加或链接邀请队员加入代码空间进行实时协作编程. 使用git功能从远程仓库同步代码\n首先前往GitHub/GitLab网站创建一个项目,作为这次组队项目的远程代码仓库,并各自创建分支,以方便团队成员之间异步协作. 之后,打开1024Code代码空间git功能侧边窗口,按照操作提示流程连接远程仓库,同步1024Code代码仓库代码和GitHub/GitLab远程库代. 连接App调试接口\n按照项目要求下载apk 安装App后.在App中设置服务端地址,即1024Code代码空间浏览器输出窗口中的URL地址,进行接口调试,如下图: 注意:1024Code代码空间浏览器输出窗口中的URL地址,如https:/e398ab9bee48dc435e6fd167398b57c3-app.1024paas.com,伴随着代码空间所在容器的释放和重启激活(代码空间长时间无操作或者关闭页面后代码空间所在容器会被释放掉,再次打开后会重启一个容器),该URL地址会变.当服务端URL地址改变后,需要在App中重新设置下服务端地址. 此外,1024Code浏览器输出端口暂时仅支持8080端口,参照demo代码空间, listen and serve on 0.0.0.0:8080.\n5 1024 的问题 使用git clone命令克隆项目代码报错 1024Code IDE环境默认为国内网络环境,国内网络环境连接 GitHub,使用git clone命令会有不稳定的情况导致clone失败,失败时可多次尝试. 如何安装依赖1024 Code IDE代码空间基于Linux环境,并使用了Nixos来管理系统依赖,常用的第三方依赖我们可以使用npm install的方式进行安装,系统级依赖,如node.js和npm包,需要通过nix的方式,具体可参照:https://docs.1024code.com/Tutorials/practice 项目编译被 Killed 1024Code默认提供了1G内存大小的容器环境给每个代码空间,部分项目编译及运行时需要的内存大小瞬时超过1G,内存不足系统会kill掉该进程.遇到这种情况,大家在群里联系我们,青训营期间我们可以直接帮大家调大代码空间容器内存大小. 6 环境问题 1024Code 使用 NixOS 对 IDE 进行环境管理（不支持 sudo 和 apt），我们需要通过修改代码空间的 nix 配置文件 .1024nix，在 .1024nix 的 packages 中添加新的依赖项。 .1024nix 为受限的隐藏文件，所以需要我们在 shell 中用 vim 命令对文件进行修改，或者使用 cp 命令将.1024nix 复制成新文件到文件树打开进行修改， 如 cp .1024nix 1。修改后，再执行 cp 1 .1024nix 命令，使 “1” 文件中的内容覆盖.1024nix 文件中的内容；然后点击运行按钮，重新运行项目，以更新环境基础依赖。 需要哪个包可以提前在nixos.org搜索下； 1 2 3 4 5 6 7 # 复制为可见副本 cp .1024nix 1 # 修改 # 将副本修改为 配置文件 cp 1 .1024nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { pkgs ? import \u0026lt;nixpkgs\u0026gt; {} }: pkgs.mkShell { shellHook = \u0026#39;\u0026#39; alias ll=\u0026#34;ls -l\u0026#34; export PS1=\u0026#34;\\[\\e[0m\\]\\w\\[\\e[0m\\]#\\[\\e[0m\\] \u0026#34; export LANG=en_US.UTF-8 export GO111MODULE=on export GOPROXY=https://goproxy.cn,direct export PATH=$PATH:~/go/bin \u0026#39;\u0026#39;; packages = [ # env pkgs.go_1_17 pkgs.mysql57 pkgs.mongodb pkgs.ffmpeg pkgs.minio pkgs.redis pkgs.postgresql # lsp pkgs.gopls pkgs.glibcLocales ]; } 7 go 如何设置 数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) func main() { db, err := sql.Open(\u0026#34;mysql\u0026#34;, getConnectionString()) if err != nil { log.Fatal(err) } defer db.Close() err = db.Ping() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Connected to MySQL database!\u0026#34;) } func getConnectionString() string { server := os.Getenv(\u0026#34;MYSQL_HOST\u0026#34;) port := os.Getenv(\u0026#34;MYSQL_PORT\u0026#34;) user := os.Getenv(\u0026#34;MYSQL_USER\u0026#34;) password := os.Getenv(\u0026#34;MYSQL_PASSWORD\u0026#34;) database := \u0026#34;mydatabase\u0026#34; return fmt.Sprintf(\u0026#34;%s:%s@tcp(%s:%s)/%s\u0026#34;, user, password, server, port, database) } ","date":"2023-08-15T16:24:03Z","permalink":"https://li54426.github.io/p/1024-code-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","title":"1024 code 使用说明"},{"content":" content {:toc} 引用来实现多态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; using namespace std; class Base { public: virtual void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Base class.\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Derived class.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Derived derivedObj; Base\u0026amp; baseRef = derivedObj; // 使用基类引用引用派生类对象 baseRef.print(); // 调用的是 Derived 类中的 print 函数 return 0; } 不涉及多态时, 删除对象会发生什么 结果, 还能运行函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; using namespace std; class Base { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Base class.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base * p = new Base(); delete(p); p-\u0026gt; print(); cout\u0026lt;\u0026lt; \u0026#34;success\u0026#34;\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;iostream\u0026gt; using namespace std; class Base { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Base class.\u0026#34; \u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;a = \u0026#34;\u0026lt;\u0026lt; a \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } int a = 0; }; int main() { Base * p = new Base(); p-\u0026gt;print(); // a = 0; delete(p); p-\u0026gt; print(); // a = 5898 return 0; } ","date":"2023-08-14T15:09:19Z","permalink":"https://li54426.github.io/p/c-%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%A5%87%E6%80%AA%E7%9A%84%E4%BA%8B%E6%83%85/","title":"c++中那些奇怪的事情"},{"content":" content {:toc} 我的工作\u0026mdash;发布视频 简介 我的工作为发布视频, 将这个任务分解为几个小任务, 先看哪些任务能够自己独立完成,先完成这些任务, 之后再根据小组成员的接口, 实现完整的功能\n环境\n需要提前安装ffmpeg 发布视频的流程\n鉴权 \u0026mdash;\u0026ndash; 使用别人的接口 存储视频 \u0026mdash;- ( demo中 有 ) 抽取封面并存储 视频 和 封面 上传到 cdn ( 没有, 因此没有做 ) 将收到的视频信息( 视频名称, 用户名, 播放地址, 封面的地址 )存储到数据库中 \u0026mdash;- 使用数据库的接口 返回消息 ( 发布成功) 因此最先做的工作就是\n确定资源存储的位置, 通过查找路由得知, 有这样一个映射r.Static(\u0026quot;/static\u0026quot;, \u0026quot;./public\u0026quot;), 我们访问静态资源的时候, 网址为xxx/static/fileName.txt, 通过 c.Request.Host字段, 来获得域名 : 2f781ee3592dd7a9ff0bbd0007fe40ce-app.1024paas.com, 加头(协议)加尾(路径 + 文件名), 进行字符串拼接 使用ffmpeg来抽取某一帧来做封面, 需要设置 其 环境 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // controller/ publish.go // 没有其他合作者的提供的接口 func Publish(c *gin.Context) { // token, 鉴权 // 存储 err := c.SaveUploadedFile(data, saveFile); // 抽取并存储图片 Vedio2Jpeg(saveFile, 6) // 拼接网址 vedio_url := \u0026#34;https://\u0026#34;+ domain + \u0026#34;/static/\u0026#34;+ finalName // 放入数据库 db.creat()..... } 抽取图片 demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 将视频抽取一帧, 转化为流 package examples import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ffmpeg \u0026#34;github.com/u2takey/ffmpeg-go\u0026#34; ) func ExampleReadFrameAsJpeg(inFileName string, frameNum int) io.Reader { buf := bytes.NewBuffer(nil) err := ffmpeg.Input(inFileName). Filter(\u0026#34;select\u0026#34;, ffmpeg.Args{fmt.Sprintf(\u0026#34;gte(n,%d)\u0026#34;, frameNum)}). Output(\u0026#34;pipe:\u0026#34;, ffmpeg.KwArgs{\u0026#34;vframes\u0026#34;: 1, \u0026#34;format\u0026#34;: \u0026#34;image2\u0026#34;, \u0026#34;vcodec\u0026#34;: \u0026#34;mjpeg\u0026#34;}). WithOutput(buf, os.Stdout). Run() if err != nil { panic(err) } return buf } 队友的接口 1 2 3 4 5 6 7 8 9 10 11 12 // 鉴权接口 // 参数: token, 返回: username func ParseToken(token string) (string, error) // 数据库接口---用户 func (*UserDao) FindUserByName(username string) (*User, error) func (d *UserDao) FindUserById(id int64) (*User, error) _, err := models.NewUserDaoInstance().FindUserByName(\u0026#34;qong\u0026#34;); // 数据库接口--- 视频 func (*VideoDao) CreateVideo(video *Video) (*Video, error) 使用了接口之后的伪代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func Publish(c *gin.Context) { // token, 鉴权 token := c.PostForm(\u0026#34;token\u0026#34;) user_name, err := ParseToken(token); user, err := models.NewUserDaoInstance().FindUserByName(user_name) var user_id = user.UserId // 存储 err := c.SaveUploadedFile(data, saveFile); // 抽取并存储图片 Vedio2Jpeg(saveFile, 6) // 拼接网址 vedio_url := \u0026#34;https://\u0026#34;+ domain + \u0026#34;/static/\u0026#34;+ finalName // 放入数据库 video1 := models.Video{UserId : user_id, PlayUrl : vedio_url, CoverUrl : img_url , } _, err = models.NewVideoDaoInstance().CreateVideo(\u0026amp;video1) } 主题 描述 计算机基础 数据结构、算法/ 计算机组成原理、计算机网络、操作系统、编译原理 Linux linux基础操作、unix环境编程、网络编程 数据库 基础理论ACID、MySQL、NoSQL 编程语言 Java、Go、C/C++、Rust 设计模式 23种设计模式 中间件 API网关、Web/RPC框架、消息队列、缓存、定时调度、数据库中间件ORM、日志系统、配置中型 分布式 一致性/CAP、事务、等、微服务、拓展性 高并发、高性能、高可用 C10k、进程、线程、线程、异步、池化、缓存、CDN、集群、负载均衡、限流、容灾、多活 linux 命令\n查看目录 打开文件 两个命令 awk, sed SOA(Service-Oriented Architecture) 1.将应用的不同功能单元抽象为服务 2.定义服务之间的通信标准微服务架构:SOA的去中心化演进方向\nuser 1 2 3 4 5 type Response struct { StatusCode int32 `json:\u0026#34;status_code\u0026#34;` StatusMsg string `json:\u0026#34;status_msg,omitempty\u0026#34;` } 项目分析 service/ message.go tcp 客户端, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package service import ..... // 并发安全的 映射类型 // event.UserId_event.ToUserId var chatConnMap = sync.Map{} func RunMessageServer() { listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:9090\u0026#34;) for { conn, err := listen.Accept() if err != nil { fmt.Printf(\u0026#34;Accept conn failed: %v\\n\u0026#34;, err) continue } go process(conn) } } func process(conn net.Conn) { defer conn.Close() var buf [256]byte for { n, err := conn.Read(buf[:]) if n == 0 { if err == io.EOF { break } fmt.Printf(\u0026#34;Read message failed: %v\\n\u0026#34;, err) continue } // 在 common.go #L39 // 请求事件是什么 var event = controller.MessageSendEvent{} _ = json.Unmarshal(buf[:n], \u0026amp;event) fmt.Printf(\u0026#34;Receive Message：%+v\\n\u0026#34;, event) fromChatKey := fmt.Sprintf(\u0026#34;%d_%d\u0026#34;, event.UserId, event.ToUserId) if len(event.MsgContent) == 0 { chatConnMap.Store(fromChatKey, conn) continue } toChatKey := fmt.Sprintf(\u0026#34;%d_%d\u0026#34;, event.ToUserId, event.UserId) writeConn, exist := chatConnMap.Load(toChatKey) if !exist { fmt.Printf(\u0026#34;User %d offline\\n\u0026#34;, event.ToUserId) continue } pushEvent := controller.MessagePushEvent{ FromUserId: event.UserId, MsgContent: event.MsgContent, } // 转化为 json 字符串 pushData, _ := json.Marshal(pushEvent) _, err = writeConn.(net.Conn).Write(pushData) if err != nil { fmt.Printf(\u0026#34;Push message failed: %v\\n\u0026#34;, err) } } } API / 路由/ 基于 HTTP 协议 做的事情有\n通过调用 r.Static(\u0026quot;/static\u0026quot;, \u0026quot;./public\u0026quot;) 将 \u0026ldquo;/static\u0026rdquo; 路径映射到 \u0026ldquo;./public\u0026rdquo; 目录，用于提供静态资源文件。\n接下来，通过调用 r.LoadHTMLGlob(\u0026quot;templates/*\u0026quot;) 加载了所有位于 \u0026ldquo;templates\u0026rdquo; 目录下的 HTML 模板文件。\n之后，定义了一个处理根路径 (\u0026quot;/\u0026quot;) 的 GET 请求的路由。\n当GET 的路径为douyin/feed/时, 调用controller.Feed, 其他也一样\n注意: Gin 默认情况下会返回 404 错误\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func initRouter(r *gin.Engine) { // public directory is used to serve static resources r.Static(\u0026#34;/static\u0026#34;, \u0026#34;./public\u0026#34;) r.LoadHTMLGlob(\u0026#34;templates/*\u0026#34;) // home page r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;index.html\u0026#34;, gin.H{ \u0026#34;title\u0026#34;: \u0026#34;Main website\u0026#34;, }) }) apiRouter := r.Group(\u0026#34;/douyin\u0026#34;) // basic apis apiRouter.GET(\u0026#34;/feed/\u0026#34;, controller.Feed) apiRouter.GET(\u0026#34;/user/\u0026#34;, controller.UserInfo) apiRouter.POST(\u0026#34;/user/register/\u0026#34;, controller.Register) apiRouter.POST(\u0026#34;/user/login/\u0026#34;, controller.Login) // -------我的工作在这里---------- apiRouter.POST(\u0026#34;/publish/action/\u0026#34;, controller.Publish) apiRouter.GET(\u0026#34;/publish/list/\u0026#34;, controller.PublishList) } 返回类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var DemoVideos = []Video{ { Id: 1, Author: DemoUser, // 静态资源 https://49e48d523a1b2e3ac60f4f7e9aec3628-app.1024paas.com/static/2_mmexport1692111641344.mp4 PlayUrl: \u0026#34;https://www.w3schools.com/html/movie.mp4\u0026#34;, CoverUrl: \u0026#34;https://cdn.pixabay.com/photo/2016/03/27/18/10/bear-1283347_1280.jpg\u0026#34;, FavoriteCount: 0, CommentCount: 0, IsFavorite: false, }, } type Response struct { StatusCode int32 `json:\u0026#34;status_code\u0026#34;` StatusMsg string `json:\u0026#34;status_msg,omitempty\u0026#34;` } 1 2 3 4 // 存储 func (c *gin.Context) SaveUploadedFile(file *multipart.FileHeader, dst string) error func (c *gin.Context) JSON(code int, obj interface{}) GORM 使用 go 语言 gorm 基本使用_go gorm_含光君～的博客 - CSDN 博客\n其他库 抽取图片 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 将视频抽取一帧, 转化为流 package examples import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ffmpeg \u0026#34;github.com/u2takey/ffmpeg-go\u0026#34; ) func ExampleReadFrameAsJpeg(inFileName string, frameNum int) io.Reader { buf := bytes.NewBuffer(nil) err := ffmpeg.Input(inFileName). Filter(\u0026#34;select\u0026#34;, ffmpeg.Args{fmt.Sprintf(\u0026#34;gte(n,%d)\u0026#34;, frameNum)}). Output(\u0026#34;pipe:\u0026#34;, ffmpeg.KwArgs{\u0026#34;vframes\u0026#34;: 1, \u0026#34;format\u0026#34;: \u0026#34;image2\u0026#34;, \u0026#34;vcodec\u0026#34;: \u0026#34;mjpeg\u0026#34;}). WithOutput(buf, os.Stdout). Run() if err != nil { panic(err) } return buf } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { inFileName := \u0026#34;path/to/video.mp4\u0026#34; index := strings.LastIndex(inFileName, \u0026#34;.\u0026#34;) if index != -1 { outFileName := strings.Join([]string{inFileName[:index+1], \u0026#34;jpeg\u0026#34;}, \u0026#34;\u0026#34;) fmt.Print(outFileName) } else { fmt.Println(\u0026#34;Invalid file name\u0026#34;) } } sync.Map sync.Map 是 Go 语言提供的一种并发安全的映射（Map）结构。它可以在多个 goroutine 并发访问时保证数据的安全性，而不需要额外的加锁操作。\nsync.Map 的主要特点如下：\n无需显式初始化，可以直接声明并使用。 支持并发的读取和写入操作，可以在多个 goroutine 中同时访问。 内部自动进行了并发安全的处理，不需要额外的锁机制。 提供了几个常用的方法来对映射进行操作，如 Store、Load、Delete 等。 需要注意的是，sync.Map 相对于普通的 map 有一些限制：\n不允许使用 nil 作为键值。 对于存储的值类型没有约束，可以是任意类型。 没有提供获取映射长度的方法。 ","date":"2023-08-12T21:34:04Z","permalink":"https://li54426.github.io/p/go_/","title":"Go_"},{"content":" content {:toc} 四个场景,如何解决? 系统奔溃\u0026mdash;\u0026mdash;-消息队列, 解耦 服务处理能力有限\u0026mdash;\u0026mdash;削峰, 消息队列 链路耗时长尾\u0026mdash;\u0026mdash;-异步, 消息队列 日志如何处理\u0026mdash;\u0026mdash; 常见的消息队列 Kafka:分布式的、分区的、多副本的日志提交服务,在高吞吐场景下发挥较为出色 RocketMQ:低延迟、强一致、高性能、高可靠、万亿级容量和灵活的可扩展性,在一些实时场景中运用较广 Pulsar:是下一代云原生分布式消息流平台,集消息、存储、轻量化函数式计算为一体、采用存算分离的架构设计 BMQ:和Pulsar架构类似, 存算分离, 初期定位是承接高吞吐的离线业务场景, 逐步替换掉对应的Kafka集群 使用 kafka流程 创建集群 新增Topic 编写生产者逻辑 编写消费者逻辑 基本概念 Topic:逻辑队列, 不同Topic可以建立不同的Topic 每个 topic 内部有 很多 partition, 可以并行处理 Cluster: 物理集群,每个集群中可以建立多个不同的Topic Producer:生产者,负责将业务消息发送到Topic中 Consumer:消费者,负责消费Topic中的消息 ConsumerGroup:消费者组,不同组Consumer消费进度互不干涉 leader 是 负责存储生产者的产品供消费者使用\nfollwer 努力保证 leader一样\n从一条消息的视角,看看为什么Kafka能支撑这么高的吞吐?\n批量发送可以减少O次数, 从而加强发送能力 通过压缩,减少消息大小,目前支持Snappy、Gzip、LZ4、ZSTD压缩算法 采用顺序写的方式进行写入,以提高写入效率 ","date":"2023-08-11T10:11:14Z","permalink":"https://li54426.github.io/p/go_/","title":"Go_"},{"content":" content {:toc} 什么是对象存储 对象存储（Object Storage）是一种用于存储和管理非结构化数据的技术和架构。与传统的文件系统或块存储相比，对象存储更适用于大规模数据的存储和访问。\n在对象存储中，数据以对象（Object）的形式进行存储。一个对象通常由数据本身、唯一的标识符（称为键或对象名）和相关的元数据（Metadata）组成。对象存储将这些对象分布在一个分布式的存储集群中，并提供了可靠性、可扩展性和高性能的数据存储解决方案。\n对象存储的特点和优势包括：\n无限扩展性：对象存储具有无限的存储容量，并可以轻松地扩展以适应不断增长的数据需求。 高可靠性：对象存储使用冗余数据备份机制，确保数据的持久性和可靠性。数据在存储集群中的多个节点之间进行复制，即使某个节点出现故障，数据仍然可用。 高性能：对象存储采用分布式存储和并行访问的方式，实现了高速的数据读写操作。同时，对象存储提供了低延迟的访问方式，适合于需要大规模数据快速检索和访问的场景。 灵活的元数据：对象存储中的对象可以包含丰富的元数据信息，这些元数据描述了对象的属性、标签和其他相关信息。这些元数据可以用于数据分类、搜索和管理。 强大的访问控制：对象存储提供灵活的访问权限控制机制，允许对存储的对象进行细粒度的权限管理。您可以根据需要设置公开访问或私有访问，并通过身份验证机制确保数据的安全性。 对象存储被广泛应用于各种场景，如云存储、大规模数据分析、备份和恢复、内容分发等。知名的对象存储服务提供商包括亚马逊 S3、微软 Azure Blob Storage 和腾讯云对象存储（TOS）等。\n存储备选海量支持单机存储 No 适合数据类型单机文件/KV No 单机数据库 No 少量(半)结构化数据 No 分布式数据库 Yes 大量(半)结构化数据 No 分布式存储 YeS 大数据计算中间结果/视频/图片等 Yes 虾仁猪心 当一口吃不成胖子时,你应该慢慢来,到最后你会发现,肚子总会比钱包先鼓起来!\n业务场景： 注意从三个方面来看, 容量, 查询次数, 安全性\n海量容量场景： 业务持续产生大量数据，数据规模 \u0026raquo;PB 级别，存储容量和成本压力极大\n海量 QPS 场景： 业务场景有高 QPS 读写请求，量级 \u0026raquo;100K/s，并且时延要求极高，对底层存储 IOPS 压力极大\n高可用性场景：业务对于 SLA 要求非常高，要求避免全局性不可用事件发生，但对于一致性要求比较低\n其中带来的工程挑战有：\n可扩展性：架构在存储容量 / 带宽吞吐 / QPS 等关键指标上，线性可扩展，能够承担业务在这些指标上的持续增长需求\n持久度：数据存储成功后，需要能够抵抗单机 / 单机架 / 单机房等各种类型的故障而不丢失\n可用性：系统不可用的时间在整体运行时间的占比需要尽可能小，系统不可用后需要具备快速恢复能力\n性价比：在海量存储容量的情况下，需要尽力降低单位存储成本，以降低业务的成本支出\n99.999% = 服务一年只能5分钟不可用\n换算成人民币 1000 字的问答所消耗的费用 2 分钱左右。\n$0.002/1K tokens\n通常 1000 个 Token 约等于 750 个英文单词或者 400～500 个汉字。GPT-3 每次调用允许处理的最大 Tokens 数量约为 4096。\nx委都行啊, 长黄高委, 最好的是黄\n级别不低 长委副省级 水文局正厅 下设处室人都很少 水文局混不上副处的属实太费了\n长江委水文局, 啥都缺，就是不缺钱\n事业单位\n武汉\n山东中医药高等专科学校 公办 山东医学高等专科学校 公办 菏泽医学专科学校 公办 山东司法警官职业学院 公办 山东商业职业技术学院 公办 临沂职业学院 公办 山东特殊教育职业学院 公办 济南护理职业学院 公办 淄博职业学院 公办 山东外贸职业学院 公办 济南幼儿师范高等专科学校 公办 莱芜职业技术学院 公办 山东职业学院 公办 潍坊护理职业学院 公办 济南职业学院 公办 济南工程职业技术学院 公办 山东畜牧兽医职业学院 公办 聊城职业技术学院 公办 山东劳动职业技术学院 公办 日照职业技术学院 公办 烟台职业学院 公办 潍坊职业学院 公办 菏泽家政职业学院 公办 山东商务职业学院 公办 山东药品食品职业学院 公办 山东城市建设职业学院 公办 威海职业学院 公办 山东科技职业学院 公办 青岛职业技术学院 公办 山东经贸职业学院 公办 山东电子职业技术学院 公办 东营职业学院 公办 济宁职业技术学院 公办 山东信息职业技术学院 公办 青岛港湾职业技术学院 公办 青岛酒店管理职业技术学院 公办 山东水利职业学院 潍坊工商职业学院 民办 枣庄职业学院 山东交通职业学院 枣庄科技职业学院 山东服装职业学院 ","date":"2023-08-10T10:04:35Z","permalink":"https://li54426.github.io/p/go_%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/","title":"Go_对象存储"},{"content":" content {:toc} 基础知识 1 什么是 Redis redis是内存数据库、key-value 数据库、以及 数据结构数据库 Redis 单线程指的是「接收客户端请求 -\u0026gt; 解析请求 -\u0026gt; 进行数据读写等操作 -\u0026gt; 发送数据给客户端」, 但是 redis 程序不是单线程的, redis 在启动的时候，是会启动后台线程 Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。\nRedis 提供了多种数据类型来支持不同的业务场景，比如 String (字符串)、Hash (哈希)、 List (列表)、Set (集合)、Zset (有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。\n除此之外，Redis 还支持事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布 / 订阅模式，内存淘汰机制、过期删除机制等等\nredis内存中的数据与redis磁盘一一对应 mysql有少部分热数据以及索引在mysql缓冲池 结构类型 结构存储的值 结构的读写能力 String字符串 可以是字符串、整数或浮点数 对整个字符串或字符串的一部分进行操作:对整数或浮点数进行自增或自减操作 List列表 一个链表,链表上的每个节点都包含一个字符串 对链表的两端进行push和pop操作,读取单个或多个元素:根据值查找或除元素 Set集合 包含宇符串的无序集合 字符串的集合,包含基础的方法有看是否存在添加、获取、删除:还包合计算交集、并集、差集等 Hash散列 包含键值对的无序散列表 包含方法有添加、获取、删除单个元素 Zset有序集合 和散列一样,用于存储键值对 字符串成员与浮点数分数之间的有序映射:元素的排列顺序由分数的大小决定:包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素 2 安装 Redis Windows 操作系统环境，安装指引链接 Linux 操作系统环境，安装指引链接 MacOS 操作系环境，安装指引链接 3 什么是 QPS QPS（Queries Per Second）是一种衡量系统处理能力和性能的度量单位，表示每秒钟能够处理的查询请求数量。 QPS 通常用于衡量数据库、网络服务器、Web 服务、缓存系统等对查询请求的处理速度。它表示在每秒的时间间隔内，系统能够处理的平均请求数量。QPS 的值越大，说明系统的处理能力越强。 QPS 的计算方式是根据一段时间内的请求数量来进行统计。例如，如果一个系统在 1 秒钟内处理了 100 个查询请求，那么它的 QPS 就是 100。 需要注意的是，QPS 仅仅是衡量系统在某一时刻或时间段内的瞬时处理能力，它并不能全面反映系统的性能。还有其他指标如响应时间、并发数等也需要综合考虑，以全面评估系统的性能。 QPS 的具体值会受到多种因素的影响，包括硬件配置、网络带宽、查询复杂度、系统负载等。因此，针对不同的应用场景和需求，对 QPS 的要求也不同。 总之，QPS 是衡量系统查询处理能力的重要指标，用于评估系统的性能和稳定性。 redis基本工作原理 数据从内存中读写 数据保存到硬盘上防止重启数据丢失 增量数据保存到AOF文件 全量数据RDB文件 单线程处理所有操作命令 ( 顺序执行 ) 应用场景 连续签到 设计一个 包含日期的 key, value 为 天数, 然后设置过期时间 消息通知 例如当文章更新时,将更新后的文章推送到ES, 用户就能搜索到最新的文章数据 排行榜 积分要变化时, 排名要实时变更 mysql 中\nuserid + 积分, 对积分进行排序 限流 要求1秒内放行的请求为N, 超过N则禁止访问 key中有时间戳, 对这个Key调用incr,超过限制N则禁止访问\n分布式锁 并发场景,要求一次只能有一个协程执行. 执行完成后, 其它等待中的协程才能执行. 可以使用redis的setnx实现,利用了两个特性\nRedis是单线程执行命令 setnx只有未设置过才能执行成功 不是高可用的分布式锁实现, 该实现存在的问题:\n(1)业务超时解锁, 导致并发问题. =\u0026gt; 业务执行时间超过锁超时时间 (2)redis主备切换临界点问题.主备切换后,A持有的锁还未同步到新的主节点时, B可在新主节点获取锁, 导致并发问题, (3)redis集群脑裂,导致出现多个主节点 pipeline 一次设置多个 key, 减少网络传输 rehash:rehash操作是将ht[0]中的数据,全部迁移到ht[1]中.数据量小的场景下直接将数据从ht[0]拷贝到ht[1]速度是较快的.数据量大的场景,例如存有上百万的KV时,迁移过程将会明显阻塞用户请求\n渐进式rehash: 为避免出现这种情况,使用了rehash方案.基本原理就是,每次用户访问时都会迁移少量数据.将整个迁移过程, 平摊到所有的访问用不请求过程中.\n2.2 list List 列表是简单的字符串列表，按照插入顺序排序，(这不是就是队列的特性) 可以从头部或尾部向 List 列表添加元素。列表的最大长度为 2^32 - 1，也即每个列表支持超过 40 亿个元素。 List 类型的底层数据结构是由双向链表或压缩列表实现的： 但是在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表 quicklist 每个节点都有很多数据, 结点内每个数据的大小相等的 问题 大 key 大Key的危害\n读取成本高 容易导致慢查询(过期、删除) 主从复制异常,服务阻塞无法正常响应请求 业务侧使用大Key的表现\n请求Redis超时报错 消除 大 key方法\n拆分, 将大key拆分为小key. 例如一个String拆分成多个String\\ 压缩, 将value压缩后写入redis, 读取时解压后再使用. 集合类结构hash、list、set、set (1)拆分:可以用hash取余、位掩码的方式决定放在哪个key中 (2)区分冷热: 如榜单列表场景使用zset, 只缓存前10页数据, 后续数据走db, ( 只关心第一名, 后面的人不关心 ) 热Key的定义 用户访问一个Key的QPS特别高,导致Server实例出现CPU负载突增或者不均的情况. 热key没有明确的标准, QPS超过500 就有可能被识别为热Key 设置Localcache\n在访问Redis前,在业务服务侧设置Localcache, 降低访问 Redis 的 QPS. LocalCache中缓存过期或未命中,则从Redis中将数据更新到LocalCache.Java的Guava、Golang的Bigcache就是这类LocalCache 拆分\n将key:value这一个热Key复制写入多份, 例如key1:value,key2:value, 访问的时候访问多个key, 但value是同一个以此将 qps 分散到不同实例上, 降低负载 .代价是, 更新时需要更新多个key, 存在数据短暂不一致的风险 解决热Key的方法2.使用Redis代理的热Key承载能力字节跳动的Redis访问代理就具备热Key承载能力.本质上是结合了\u0026quot;热Key发现\u0026quot;、\u0026ldquo;LocalCache\u0026quot;两个功能\n慢查询 导致慢查询的操作\n批量操作一次性传入过多的key/value,如mset/hmset/sadd/zadd等O(n)操作建议单批次不要超过100,超过100之后性能下降明显. zset大部分命令都是O(log(n)),当大小超过5k以上时,简单的zadd/zrem也可能导致慢查询 操作的单个value过大,超过10KB.也即,避免使用大Key 对大key的delete/expire操作也可能导致慢查询,Redis4.0之前不支持异步删除unlink,大key删除会阻塞Redis 缓存穿透、缓存雪崩 缓存穿透:热点数据查询绕过缓存,直接查询数据库\n缓存雪崩:大量缓存同时过期\n缓存穿透\n查询一个一定不存在的数据通常不会缓存不存在的数据,这类查询请求都会直接打到db,如果有系统bug或人为攻击,那么容易导致db响应慢甚至宕机 如何减少缓存穿透\n(1)缓存空值 如一个不存在的userlD.这个id在缓存和数据库中都不存在.则可以缓存一个空值,下次再查缓存直接反空值. (2)布隆过滤器通过 bloom filter 算法来存储合法 Key, 得益于该算法超高的压缩率, 只需占用极小的空间就能存储大量 key 值 如何避免缓存雪崩\n1)缓存空值将缓存失效时间分散开,比如在原有的失效时间基础上增加一个随机值, 例如不同Key过期时间可以设置为10分1秒过期,10分23秒过期,10分8秒过期.单位秒部分就是随机时间,这样过期时间就分散了对于热点数据,过期时间尽量设置得长一些,冷门的数据可以相对设置过期时间短一些. 2)使用缓存集群,避免单机宕机造成的缓存雪崩. ","date":"2023-08-08T15:04:16Z","permalink":"https://li54426.github.io/p/go_redis/","title":"Go_Redis"},{"content":" content {:toc} 1 力扣刷题量终于达到了 300\n2 终于拿到了一直没有考出来的教师资格证\n3 终于开始了在linux下编程, 完成了一个项目webserver\n4 终于学会了使用 GDB\n","date":"2023-08-08T10:15:35Z","permalink":"https://li54426.github.io/p/2023-%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/","title":"2023 年中总结"},{"content":" content {:toc} 其他项目\n衍生项目, 剖析muduo源码(未做) 设计模式 STL笔记 http web server c内存管理 ","date":"2023-08-05T11:32:43Z","permalink":"https://li54426.github.io/p/","title":""},{"content":"[TOC]\n数据库 特点 作为后端软件的底座, 性能敏感 ( 没有数据还有服务? ) 存储系统软件架构, 容易受硬件影响 (别人发明了快十倍的硬件, 但是需要从头写, 你用不) 存储系统代码,既\u0026quot;简单\u0026quot;又\u0026quot;复杂\u0026quot; 设计程序原则 「缓存」很重要,贯穿整个存储体系 「拷贝」很昂贵,应该尽量减少 硬件设备五花八门, 需要有抽象统一的接入层 , 例如 linux 的 一切皆文件 高速数据库的设计应该归为操作系统这一级别\n必不可少, 所有的计算机必须存储数据 缓存的数据必须由程序员控制, 而不是操作系统的某个算法来控制 例如, 用户查找了 A表的数据, 下一个行为必须是查询B表, 算法计算出来的是缓存C表, 那缓存还有用吗 RAID技术 RAID（Redundant Array of Independent Disks）技术是一种数据存储技术，通过将多个硬盘组合在一起来提供更高的性能、容错性和数据冗余。RAID 技术可以应用在服务器、工作站和个人计算机等各种存储设备上。\nRAID 技术采用了不同的级别或配置，每种级别都具有其特定的优点和用途。以下是常见的几种 RAID 级别：\nRAID 0\n多块磁盘简单组合\n数据条带化存储, 提高磁盘带宽\n没有额外的容错设计\nRAID 1\n一块磁盘对应一块额外镜像盘 真实空间利用率仅50% 容错能力强 RAID 0+1\n结合了RAID0和RAID1 真实空间利用率仅50% 容错能力强,写入带宽好 为什么要使用数据库 所有的系统都会产生数据, 所以 数据库系统是所有系统不可或缺的模块 逻辑层和物理层之间的 存在 紧耦合 复杂查询很麻烦 事物具有 A(tomicity),事务内的操作要么全做,要么不做 C(onsistency), 事务执行前后,数据状态是一致的 I(solation),可以隔离多个并发事务,避免影响 D(urability),事务一旦提交成功,数据保证持久性 使用文件系统来存储数据的弊端 数据的冗余和不一致 数据访问图难 数据孤立 完整性问题 原子性问题 并发访问异常 概念解释 名词 解释 关系 一组无序的元素或者记录 主键(primary key) 某一个唯一属性或一个属性组能唯一标识一条记录 外键(foreign key ) 指定一张表中的属性必须存在于另一张表中 SQL (Structured Query Language) 结构化查询语言 notes:\n原始关系模型中,所有的值都必须保证原子性或者单个属性值 (不能是数组 或者嵌套对象) relation 和 table 是一回事 n元组 就是一个有n个值的元组,它对应于表中的一行. 关系代数 符号 解释 注释 $\\sigma _{predicate}(R)$ 选择 $\\prod_{A1,A2,,,An}(R)$ 投影, 即选择部分列，而元组不改变 A1是属性 ( R- S ) R中有但是S中没有 并集 交集 $R \\times S$ 笛卡尔积, 产生 所有可能的不重复的组合 $R \\bowtie S$ R表 和 S 中 每个属性都相同 聚合函数 函数名 解释 AVG( col ) 返回平均值 MIN( col ) 返回最小值 MAX( col ) 返回最大值 SUM( col ) 返回 值 COUNT( col ) 计数 Notes:\n聚合函数接收一组 Tuple 作为其输入，然后产生一个单一的标量值作为其输出。 只能在 SELECT 输出列表中使用。 课后思考 写入存储系统的粒度太大，会不会导致数据原子性问题？例如一次性写 100MB，如果系统突然 crash，会不会只有一部分数据持久化了，另一部分丢失了？如果要解决原子性问题，一般会设计什么机制？ 在从应用程序到存储介质的链路上，无论读还是写，数据可能要被拷贝好几次，这几次拷贝能不能去掉？如果我们去掉大部分拷贝操作，会有什么副作用，要怎么缓解副作用？ 一个关系型数据库大概率是会被并发访问的，如果要保证并发安全，除了在行数据上加悲观锁还有其他方式吗？ 在数据库领域，把数据按行存和按列存各有好处，你能从性能优先的角度设计出一种混合存储格式吗？ 主流 存储产品 单机存储=单个计算机节点上的存储软件系统,一般不涉及网络交互\nLinux文件系统的两大数据结构:Index Node\u0026amp;DirectoryEntry\nIndex Node记录文件元数据,如id、大小、权限、磁盘位置等node是一个文件的唯一标识,会被存储到磁盘上node的总数在格式化文件系统时就固定了\nDirectory Entry记录文件名、inode指针,层级关系(parent)等dentry是内存结构,与inode的关系是N:1(hardlink的实现)\n世间一切皆 key-value\nkey是你身份证,value是你的内涵: 感觉就像是数学中的映射 y = f(x), 在数组中, index -\u0026gt; value, map中 key-\u0026gt; value 常见使用方式:put(k,v)\u0026amp;get(k) 常见数据结构:LSM-Tree,某种程度上牺牲读性能,追求写入性能拳头产品:RocksDB\n分布式文件系统\nHDFS:堪称大数据时代的基石 ( 又是谷歌 )\n时代背景:专用的高级硬件很贵,同时数据存量很大,要求超高吞吐\nHDFS核心特点\n支持海量数据存储 高容错性 弱POSIX语义 使用普通x86服务器,性价比高 ( 既要又要还要 )\n分布式存储 一Ceph\nCeph:开源分布式存储系统里的「万金油」 建议去读源码\nCeph的核心特点\n一套系统支持对象接口、块接口、文件接口,但是一切皆对象 数据写入采用主备复制模型 数据分布模型采用CRUSH算法, HASH+权重+随机抽签 关系型数据库的通用组件\nQuery Engine—负责解析query,生成查询计划 TxnManager负责事务并发管理 Lock Manager负责锁相关的策 Storage Engine负责组织内存/磁盘数据结构 Replication负责主备同步 关键内存数据结构:B-Tree、B+-Tree、LRU List等关键\n磁盘数据结构:WriteAheadLog(RedoLog)、Page\nmongoDB\n面向「文档」存储文档\n可序列化成JSON/BSON,支持嵌套\n存在「collection」,collection=文档的集合\n存储和构建索引能力依赖wiredTiger引擎\n4.0后开始支持事务(多文档、跨分片多文档等)\n常用client/SDK交互,可通过插件转译支持弱SQL\n数据结构丰富(hash表、set、zset、list)\nC语言实现,超高性能\n主要基于内存,但支持AOF/RDB持久化\n常用redis-cli/多语言SDK交互\nKernel Space -\u0026gt; User Space\n避免syscall带来的性能损耗,直接从用户态访问磁盘 中断-\u0026gt;轮询\n磁盘性能提高后,中断次数随之上升,不利于IO性能SPDK poller可以绑定特定的cpu核不断轮询,减少cs,提高性能 无锁数据结构\n使用Lock-free queue,降低并发时的同步开销\n传统的网络协议栈,需要基于多层网络协议处理数据包,存在用户态\u0026amp;内核态的切换,足够通用但性能不是最佳RDMA是kernel bypass的流派,不经过传统的网络协议栈,可以把用户态虚拟内存映射给网卡,减少拷贝开销,减少cpu开销\n02 Persistent Memory在NVMeSSD和Main Memory间有一种全新的存储产品:Persistent Memory O时延介于SSD和Memory之间,约百纳秒量级可以用作易失性内存(memorymode),也可以用作持久化介质(app-direct\n03.可编程交换机P4Switch,配有编译器、计算单元、DRAM,可以在交换机层对网络包做计算逻辑.在数据库场景下,可以实现缓存一致性协议等\nCPU/GPU/DPU CPU:从multi-coremany-core GPU:强大的算力\u0026amp;越来越大的显存空间DPU:异构计算,减轻CPU的workload\n存储系统\n块存储:存储软件栈里的底层系统,接口过于朴素 文件存储:日常使用最广泛的存储系统,接口十分友好,实现五花八门 对象存储:公有云上的王牌产品,immutable语义加持 key-value存储:形式最灵活,存在大量的开源/黑盒产品 数据库系统关系型数据库:\n基于关系和关系代数构建的,一般支持事务和SQL访问,使用体验友好的存储产品 非关系型数据库:结构灵活,访问方式灵活,针对不同场景有不同的针对性产品 分布式架构\n数据分布策略:决定了数据怎么分布到集群里的多个物理节点,是否均匀,是否能做到高性能 数据复制协议:影响IO路径的性能、机器故障场景的处理方式 分布式事务算法:多个数据库节点协同保障, 一个事务的ACID特性的算法,通常基于2pc的思想设计 课后作业实现一个(分布式)key-value存储系统要求: 1.基于本地文件系统实现,支持常用的put(k,v)、get(k,v)、scan_by_prefix(prefix)接口 2.支持存储server独立进程部署,支持跨进程或者网络访问 3.1O操作做到低时延4.*可选:支持扩展成分布式架构,多台存储server组成一个分布式key-value存储系统,并保证全局的数据一致性\n","date":"2023-08-05T09:57:32Z","permalink":"https://li54426.github.io/p/go_/","title":"Go_"},{"content":" content {:toc} 0 写在开头 “如无必要，勿增实体”\u0026mdash;\u0026mdash;\u0026mdash;威廉\n这就是著名的奥卡姆剃刀原则, 他说的是, 小就是美, 今天在写处理http的网络库时, 深有感触\nhttp协议位于传输层上方, 但是不一定是最高的层次, 他就像操作系统对于硬件和用户的关系一样, 既要支持用户直接用, 也要支持作为协议的一层\n从支持用户直接使用的角度来看, 报文的请求行, 请求头, 请求体要一块进行处理, 但是从协议的一层来看, 请求体要向上传递, 交给另一个协议进行处理, 设计时, 要让 body部分不处理, 这就带来了一个问题, 如何区分headers和body, 因为headers可以有很多行, 协议的设计人员使用一个空行来进行分隔, 既要用少的规则来区分不同的属性, 又要尽可能的简单\n优点\n有着crlf这个明确的分界线来表示一行, 我们能够逐行处理 请求行中有着空格隔开, 可以十分方便的处理每个值 请求头分为很多行, 可以逐行处理每一对header, 使用同一个逻辑 ( while ) 请求头和请求体之间有着一个空行, 标志着请求头的结束, 能够方便的区分( 判断 )这两者 用户关心的事情只有\n对发送来的 HTTP做出回复 因此, 为用户提供的接口是 1 2 using HttpCallback = function\u0026lt;void(const HttpRequest \u0026amp;, HttpResponse * )\u0026gt;; void setHttpCallback(const HttpCallback \u0026amp; cb); 1 HttpRequest 存储了连接的状态, URL以及 headers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class HttpRequest{ public: using HttpMap= map\u0026lt;string, string\u0026gt; ; enum Method{ kInvalid, kGet, kPost, kHead, kPut, kDelete }; enum Version{ kUnkown, kHttp10 , kHttp11 }; private: Method method_; Version version_; std::string path_; std::string query_; Timestamp receiveTime_; std::map\u0026lt;string, string\u0026gt; headers_; }; 2 HttpContext 2.1 主要的功能: 处理 http报文, 将报文解析出来, 传入成员HttpRequest中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class HttpContext{ public: enum HttpRequestParseState{ kExpectRequestLine, // 期望解析请求行 kExpectHeaders, // 期望解析请求头部 kExpectBody, // 期望解析请求体 kGotAll, // 已经解析完整请求 }; bool parseRequCest(Buffer* buf, Timestamp receivetime); private: HttpRequestParseState state_; HttpRequest request_; }; 2.2 http报文格式 请求行 / 状态行 方法名 URL 协议版本 请求头 / 响应头 请求体 / 响应体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 POST /index.html HTTP/1.1 #(回车换行) Who: Alex #(回车换行) Content-Type: text/plain Host: 127.0.0.1:8888 Content-Length: 28 Cookie: JSESSIONID=24DF2688E37EE4F66D9669D2542AC17B #(回车换行) #(回车换行) Let\u0026#39;s watch a movie together # 响应报文 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Content-Type: application/json Transfer-Encoding: chunked Date: Mon, 12 Sep 2011 12: 41: 24 GMT 6f {\u0026#34;password\u0026#34;:\u0026#34;1234\u0026#34;,\u0026#34;userName\u0026#34;:\u0026#34;tom\u0026#34;,\u0026#34;birthday\u0026#34;:null,\u0026#34;salary\u0026#34;:0, \u0026#34;realName\u0026#34;: \u0026#34;tomson\u0026#34;,\u0026#34;userId\u0026#34;: \u0026#34;1000\u0026#34;,\u0026#34;dept\u0026#34;:null} 0 其中, 状态行和首部中的每行都是以回车符 (\\r，%0d，CR) 和换行符 (\\n，%0a，LF) 结束, headers和body中间有一个空行\n因此我们也要分为三部分处理, 首先处理请求行, 再处理 header, 最后再处理 请求体\n2.3 核心函数bool parseRequCest(Buffer* buf, Timestamp receivetime); 功能: 从buffer中将报文解析出来 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 bool HttpContext::parseRequCest(Buffer *buf, Timestamp receivetime) { bool ok = true; bool has_more = true; while(has_more){ if(state_ ==kExpectRequestLine){ // 找到第一行结束的位置 const char *crlf = buf-\u0026gt;findCRLF(); if(crlf){ // 处理 请求行 ok = processRequestLine(buf-\u0026gt; Peek(), crlf); if(ok){ // 设置时间戳 request_.setReceiveTime(receivetime); buf-\u0026gt; Retrieve(crlf + 2 - buf-\u0026gt; Peek()); // 处理完请求行, 处理 headers state_ = kExpectHeaders; } else{// !ok // 遇到错误, 处理失败 has_more = false; } } else{// ! crlf // 没有找到 crlf, 非法报文 has_more = false; } } // 处理 头部, 本身没有循环, 通过外部循环来**逐行** 处理 else if (state_ == kExpectHeaders){// state_ != kExpectRequestLine const char* crlf = buf-\u0026gt;findCRLF(); if(crlf){ const char * colon = std::find(buf-\u0026gt; Peek(), crlf, \u0026#39;:\u0026#39;); if(colon != crlf){ ++colon; while(*colon == \u0026#39; \u0026#39;){ colon++; } request_.addHeader(string(buf-\u0026gt; Peek(), colon), string(colon, crlf)); } // 有一个空行, 头部处理完毕 else{ state_ = kGotAll; has_more = false; } buf-\u0026gt; Retrieve(crlf + 2 - buf-\u0026gt; Peek()); } // 没找到回车换行, 非法报文 else{ has_more = false; } } // body 部分依旧留在 buf中, // 空语句, 在这里不处理, 只是为了逻辑上更顺畅 else if (state_ == kExpectBody){ } } return ok; } 2.4处理请求行 每个值中间都用空格方法(空格)URL(空格)版本CRLF 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 bool HttpContext::processRequestLine(const char *begin, const char *end) { // 传进来的数据就是一行, 不用找 crlf // 以空格为准 bool succeed = false; const char * start = begin; const char * space = std::find(start, end, \u0026#39; \u0026#39;); // 设置方法名 if(space != end \u0026amp;\u0026amp; request_.setMethod(string(start, space))){ start = space +1; // 继续查找下一个空格 space = std::find(start, end, \u0026#39; \u0026#39;); if(space != end){ const char * question = std::find(start, space, \u0026#39;?\u0026#39;); if(question != space){ request_.setPath(string(start, question)); request_.setQuery(string(question, space)); } else{ request_.setPath(string(start, space)); } start = space+1; succeed = end - start == 8 \u0026amp;\u0026amp; std::equal(start, end-1, \u0026#34;HTTP/1.\u0026#34;); if(succeed ){ if(*(end-1) == \u0026#39;1\u0026#39;){ request_.setVersion(HttpRequest::kHttp11); } if(*(end-1) == \u0026#39;0\u0026#39;){ request_.setVersion(HttpRequest::kHttp10); } else{ succeed = false; } } }// space != end }// set method return succeed; } 3 httpResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class HttpResponse{ public: enum HttpStatusCode { kUnknown, k200Ok = 200, k301MovedPermanently = 301, k400BadRequest = 400, k404NotFound = 404, }; explicit HttpResponse(bool close) : status_code_(kUnknown), close_connection_(close) { } void setStatusCode(HttpStatusCode code) { status_code_ = code; } void setStatusMessage(const string\u0026amp; message) { status_message_ = message; } void setCloseConnection(bool on) { close_connection_ = on; } bool closeConnection() const { return close_connection_; } void setContentType(const string\u0026amp; contentType) { addHeader(\u0026#34;Content-Type\u0026#34;, contentType); } // FIXME: replace string with StringPiece void addHeader(const string\u0026amp; key, const string\u0026amp; value) { headers_[key] = value; } void setBody(const string\u0026amp; body) { body_ = body; } void appendToBuffer(Buffer* output) const; private: HttpStatusCode status_code_; string body_; string status_message_; bool close_connection_; std::map\u0026lt;string, string\u0026gt; headers_; }; 4 HttpServer 用户只需要关心：\n对来的 报文 做 制作 response, 因此using HttpCallback = function\u0026lt;void(const HttpRequest \u0026amp;, HttpResponse * )\u0026gt; ;, 第一个参数用来保存用户的请求, 第二个参数我们用来制作报文 为用户提供的接口是function\u0026lt;void(const HttpRequest \u0026amp;, HttpResponse * )\u0026gt; 因此在 onMessage 中, 库设计者需要\n将tcp中的消息转换为 HTTP报文 调用用户传入的callback函数, 发送 response 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class HttpServer{ public: using HttpCallback = function\u0026lt;void(const HttpRequest \u0026amp;, HttpResponse * )\u0026gt; ; // 实际就是进行 server_的初始化操作 HttpServer(EventLoop *loop, const InetAddress \u0026amp; linten_addr, const string \u0026amp; name, TcpServer::Option option = TcpServer::kNoReusePort); EventLoop * getLoop()const; void setHttpCallback(const HttpCallback \u0026amp; cb){ http_callback_ = cb; } void setThreadNum(int num_thread){ server_.setNumThread(num_thread); } void start(); void onConnection(const TcpConnectionPtr \u0026amp; conn); void onMessage(const TcpConnectionPtr \u0026amp;conn, Buffer *buf, Timestamp receive_time); void onRequest(const TcpConnectionPtr\u0026amp; conn, const HttpRequest \u0026amp; req); private: TcpServer server_; HttpCallback http_callback_; }; void defaultHttpCallback(const HttpRequest \u0026amp;, HttpResponse *resp){ resp-\u0026gt; setStatusCode(HttpResponse::k404NotFound); resp-\u0026gt; setStatusMessage(\u0026#34;Not Found\u0026#34;); resp-\u0026gt; setCloseConnection(true); } HttpServer::HttpServer(EventLoop *loop, const InetAddress \u0026amp;listen_addr, const string \u0026amp;name, TcpServer::Option option): server_(loop, listen_addr, name, option ), http_callback_(defaultHttpCallback) { server_.setConnectionCallback(std::bind(\u0026amp;HttpServer::onConnection, this, _1)); server_.setMessageCallback(std::bind(\u0026amp;HttpServer::onMessage, this, _1, _2, _3)); } EventLoop *HttpServer::getLoop() const { return server_.getLoop(); } void HttpServer::start() { LOG_DEBUG(\u0026#34;httpserver %s start, listen on %s\u0026#34;, server_.name(), server_.ipPort()); server_.start(); } void HttpServer::onConnection(const TcpConnectionPtr \u0026amp;conn) { if(conn-\u0026gt; connected()){ conn-\u0026gt;setContext(); } } void HttpServer::onMessage(const TcpConnectionPtr \u0026amp;conn, Buffer *buf, Timestamp receive_time) { HttpContext context; bool ok = context.parseRequCest(buf, receive_time); if(!ok){ conn-\u0026gt; send(string(\u0026#34;HTTP/1.1 400 Bad Request\\r\\n\\r\\n\u0026#34;)); conn-\u0026gt; shutdown(); } if(context.gotAll()){ onRequest(conn, context.request()); context.reset(); } } void HttpServer::onRequest(const TcpConnectionPtr \u0026amp;conn, const HttpRequest \u0026amp;req) { const string \u0026amp;connection = req.getHeader(\u0026#34;Connection\u0026#34;); bool isclose = connection==\u0026#34;close\u0026#34; || (req.getVersion() == HttpRequest::kHttp10 \u0026amp;\u0026amp; connection != \u0026#34;Keep-Alive\u0026#34;); HttpResponse response(isclose); http_callback_(req, \u0026amp;response); Buffer buf; response.appendToBuffer(\u0026amp;buf); conn-\u0026gt;send(\u0026amp;buf); if(response.closeConnection()){ conn-\u0026gt; shutdown(); } } ","date":"2023-08-02T22:26:13Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} muduo库的优点 高性能：muduo 是一个基于事件驱动的网络库，具有高度可扩展性和高性能。它采用了 Reactor 模式和非阻塞 IO 技术，能够处理大量并发连接和高负载的网络请求，提供出色的性能表现。 轻量级：muduo 库设计简洁，代码量相对较小，不依赖于外部库和框架。这使得集成和使用该库非常方便，并且能够快速构建高性能的网络应用程序。 安装muduo库 mirrors / chenshuo / muduo · GitCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 0.1 在下载路径下解压 unzip muduo-master.zip # 0.2 如果没有安装 cmake sudo apt-get install cmake # 0.3 安装 boost库 sudo apt-get install libboost-dev libboost-test-dev # 1 编译 ./build.sh # 2 安装 ./build.sh install # 完成以后 # 会在 muduo 源码根路径的上一级路径下生成一个 build 目录（下面全文我们以../build 表示） # 生成的可执行文件位于：../build/release-cpp11/bin # 静态文件位于：../build/release-cpp11/lib # 进入安装的地方 cd release-install-cpp11/ # 进入 include 文件夹, 文件夹下有个 muduo, 将其移动至后面的路径 cd include/ mv muduo/ /usr/include/ # 进入 lib 文件夹, 将内部所有的文件, 将其移动至 cd ../lib/ mv * /usr/local/lib/ 编译测试 要记得使用-pthread库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // g++ main.cpp -lmuduo_net -lmuduo_base -lpthread -std=c++11 // ./a.out // 另一个 shell 进行 // echo \u0026#34;hello world\u0026#34; | nc localhost 8888 #include \u0026lt;muduo/net/TcpServer.h\u0026gt; #include \u0026lt;muduo/base/Logging.h\u0026gt; #include \u0026lt;boost/bind.hpp\u0026gt; #include \u0026lt;muduo/net/EventLoop.h\u0026gt; // 使用muduo开发回显服务器 class EchoServer { public: EchoServer(muduo::net::EventLoop* loop, const muduo::net::InetAddress\u0026amp; listenAddr); void start(); private: void onConnection(const muduo::net::TcpConnectionPtr\u0026amp; conn); void onMessage(const muduo::net::TcpConnectionPtr\u0026amp; conn, muduo::net::Buffer* buf, muduo::Timestamp time); muduo::net::TcpServer server_; }; EchoServer::EchoServer(muduo::net::EventLoop* loop, const muduo::net::InetAddress\u0026amp; listenAddr) : server_(loop, listenAddr, \u0026#34;EchoServer\u0026#34;) { server_.setConnectionCallback( boost::bind(\u0026amp;EchoServer::onConnection, this, _1)); server_.setMessageCallback( boost::bind(\u0026amp;EchoServer::onMessage, this, _1, _2, _3)); } void EchoServer::start() { server_.start(); } void EchoServer::onConnection(const muduo::net::TcpConnectionPtr\u0026amp; conn) { LOG_INFO \u0026lt;\u0026lt; \u0026#34;EchoServer - \u0026#34; \u0026lt;\u0026lt; conn-\u0026gt;peerAddress().toIpPort() \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34; \u0026lt;\u0026lt; conn-\u0026gt;localAddress().toIpPort() \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; (conn-\u0026gt;connected() ? \u0026#34;UP\u0026#34; : \u0026#34;DOWN\u0026#34;); } void EchoServer::onMessage(const muduo::net::TcpConnectionPtr\u0026amp; conn, muduo::net::Buffer* buf, muduo::Timestamp time) { // 接收到所有的消息，然后回显 muduo::string msg(buf-\u0026gt;retrieveAllAsString()); LOG_INFO \u0026lt;\u0026lt; conn-\u0026gt;name() \u0026lt;\u0026lt; \u0026#34; echo \u0026#34; \u0026lt;\u0026lt; msg.size() \u0026lt;\u0026lt; \u0026#34; bytes, \u0026#34; \u0026lt;\u0026lt; \u0026#34;data received at \u0026#34; \u0026lt;\u0026lt; time.toString(); conn-\u0026gt;send(msg); } int main() { LOG_INFO \u0026lt;\u0026lt; \u0026#34;pid = \u0026#34; \u0026lt;\u0026lt; getpid(); muduo::net::EventLoop loop; muduo::net::InetAddress listenAddr(8888); EchoServer server(\u0026amp;loop, listenAddr); server.start(); loop.loop(); } ","date":"2023-08-02T16:29:50Z","permalink":"https://li54426.github.io/p/","title":""},{"content":" content {:toc} 百度之星 比赛简述 三场初赛，参赛选手可以参加任意一场或多场, 三场初赛 / 省赛日期依次为 2023 年 8 月 6 日（周日）、8 月 13 日（周日）和 9 月 24 日（周日），均为线上。决赛将在线下举办，时间地点另行通知。14:00-17:00 比赛可以带纸质资料, ：初赛和决赛均为算法设计类题型。每场初赛时长 3 小时、8 道题；决赛时长 5 小时、12 道题。 选手使用程序设计语言包括 C，C++，Python 及 Java 等语言解决挑战性算法问题。程序完成之后提交运行，系统自动判定程序为正确或错误并将运行的结果反馈给参赛者，根据答题准确率和耗时进行排名晋级。( 好像是 实时运行 ) 每场初赛成绩取 300 名（前 200 名大学生，前 70名高中生，前 30 名小星星即初中生或小学生）进决赛，共900 人晋级决赛。 报名相关 参赛选手登录竞赛网站 http://www.matiji.net/astar 完成 报名表里 “所在省份”是 “学校所在省份”。错填为身份证上省份的同学请尽快申请修改。\\ 大赛不收报名费。由第三方 OJ 考试平台收取考试服务 费。标准为：80 元/人/单场竞赛。参赛学生在报名页面，点击“参赛邀请码通道”，输入邀请码。个人缴费，提交报名信息后在线扫码支付。 建议提前一天完成报名并完成自测流程，以确保顺利参赛。 报名完成后如有特殊原因希望更换场次，请将用户名、姓名、手机号、原场次和请求换入的场次发邮件至 xiaomage@matiji.net，一星期内处理完成，以收到回复邮件为准。对于每个用户，该权利仅限行使一次。每场赛前一周内不再接受更换场次需求。 oj相关 本场考试启用双机位监考.第一机位为电脑本机摄像头, 第二机位放置在考生侧后方, 用于监控考试环境. 竞赛时可以使用本地 IDE。建议在本地 IDE 调试好后复制粘贴到竞赛系统提交。 练习赛（模拟考试） 建议所有选手在正式竞赛前登录码蹄集平台参加练习赛（模拟考试），提前测试竞赛系统环境。\n模拟考试流程：点击任意一场竞赛报名页面，下载考试客户端并运行。按照 “自测流程” 说明开始测试（注意模拟考试题目与正式竞赛题目难度、数量等无关）。\n请确保您的电脑、音频、视频和互联网连接处于最佳状态。\n","date":"2023-08-02T14:18:46Z","permalink":"https://li54426.github.io/p/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E8%80%83%E8%AF%95/","title":"百度之星考试"},{"content":" content {:toc} 环境 Linux/操作系统 Wireshark件 Socket 网络编程开发环境 ARP协议 逻辑同网段才能发送ARP ARP请求广播, ARP应答单播 免费 ARP ARP（地址解析协议）是一种用于将 IP 地址映射到 MAC 地址的协议。它在局域网中起作用，允许网络设备通过发送 ARP 请求来查找目标设备的 MAC 地址。\n\u0026ldquo;免费 ARP\u0026rdquo;（Free ARP）是指发送 ARP 请求时不指定目标 IP 地址，而是将目标 IP 地址设置为 0.0.0.0。这种类型的 ARP 请求旨在查询网络中是否存在冲突的 IP 地址。当一个设备收到了一个免费 ARP 请求时，如果发现自己的 IP 地址与请求中的源 IP 地址冲突，它将发送一个 ARP 响应来解决冲突。\n免费 ARP 的主要用途是检测和解决 IP 地址冲突问题，因为每个设备都应该具有唯一的 IP 地址。通过发送免费 ARP 请求，设备可以确定是否有其他设备使用了相同的 IP 地址，以便及时处理冲突。\nNAT 将ip和端口都转换 提高了 端口的利用率, 毕竟那么多端口, 用不完 NAT（Network Address Translation）是网络地址转换的缩写，是一种在计算机网络中用于将私有网络内部的 IP 地址转换为公网可路由的 IP 地址的技术。\n在一个局域网中，通常会使用私有 IP 地址来分配给内部设备，例如以 \u0026ldquo;192.168.x.x\u0026rdquo;、\u0026ldquo;10.x.x.x\u0026rdquo; 或 \u0026ldquo;172.16.x.x\u0026rdquo; 到 \u0026ldquo;172.31.x.x\u0026rdquo; 开头的地址。这些私有 IP 地址在公共互联网上是不可路由的，因此无法直接与外部网络进行通信。\nNAT 技术允许将多个内部设备的私有 IP 地址映射到一个或多个公共 IP 地址上，以实现与外部网络的通信。NAT 通常由一个网络设备（例如路由器或防火墙）提供支持，它拥有至少两个网络接口，一个连接到内部局域网，一个连接到外部公网。\n当内部设备发送数据包到外部网络时，NAT 设备会将源 IP 地址从私有 IP 地址替换为公共 IP 地址，并将该转换信息记录在转换表中。当外部网络返回响应数据包时，NAT 设备会根据转换表将目标 IP 地址从公共 IP 地址转换回原始的私有 IP 地址，并将数据包传递给正确的内部设备。\nNAT 技术有以下几个主要作用：\n节省公共 IP 地址：由于私有 IP 地址在内部网络中可以重复使用，NAT 可以大大减少对公共 IP 地址的需求。 提供网络安全：由于内部设备的私有 IP 地址不直接暴露在公网上，NAT 在一定程度上提供了网络安全保护。 简化网络配置：通过使用 NAT，整个局域网可以共享一个公共 IP 地址，无需为每个内部设备分配公共 IP 地址。 需要注意的是，使用 NAT 技术的网络中的内部设备一般无法直接从外部网络访问，除非适当配置端口转发或设置 DMZ（Demilitarized Zone）。\nTCP HTTP1.1哪些优化?\n长连接 部分传输 HOST 缓存 https的加密过程 HTTPS（Hypertext Transfer Protocol Secure）是在 HTTP 基础上加入了安全套接层（SSL/TLS）的协议，用于在客户端和服务器之间进行安全的数据传输。以下是 HTTPS 的加密过程：\n客户端发起连接请求：客户端向服务器发起连接请求，并请求建立加密连接。 服务器的证书：服务器将自己的数字证书发送给客户端，证书中包含了服务器的公钥和相关信息。 客户端验证证书：客户端收到服务器的证书后，会对证书进行验证。验证包括检查证书的合法性、颁发机构的可信度以及证书是否过期等。如果证书验证失败，客户端会发出警告或终止连接。 客户端生成密钥：如果服务器的证书验证通过，客户端会生成一个随机的对称密钥（session key），用于后续的数据加密和解密。 密钥交换：客户端使用服务器的公钥对生成的对称密钥进行加密，然后将加密后的密钥发送给服务器。 服务器解密密钥：服务器收到客户端发送的加密后的对称密钥后，利用自己的私钥进行解密，得到对称密钥。 数据加密：接下来的通信过程中，客户端和服务器使用对称密钥进行数据加密和解密。客户端和服务器的数据通过对称密钥进行加密后传输，保证了数据的机密性。 数据传输：在建立加密连接后，客户端和服务器可以安全地传输数据。数据在传输过程中使用对称密钥进行加密和解密，确保了数据的机密性和完整性。 通过以上步骤，HTTPS 实现了对通信过程中的数据进行加密保护，防止敏感信息被窃听或篡改。加密过程中，服务器的数字证书起到了验证服务器身份和传递公钥的作用，而对称密钥的使用则提供了高效的加密和解密机制。\n网络提速 网络提速-同运营商访问 网络提速-动态API(播放/评论接口)路径优化(DSA) 故障排查 先止损再排查\n比如推荐算法坏了-\u0026gt; 先不用推荐, 先随机刷刷刷\n客户端排查\n客户端访问其他服务没问题吗? 其他客户端访问目标服务没问题吗? 服务端排查\n服务端监控/指标都正常吗? 手动访问一下正常吗? 分组件排查 中间链路排查\n服务端跟客户端确保都没问题 中间网络设备有没有问题?(交换机/路由器/网关LB) 旁路的DNS有没有问题? 网络故障排查\ndig查询DNS问题 ping/telnet/nmap查询三层/四层连通性 Traceroute排查中间链路 iptables tcpdump 课后作业1 UDP socket 实现ack, 感知丢包重传提示: 1.学会UDP socket编程2.先从简单的ack学习,客户端等待ack再发包 3.什么时候客户端认为是丢包? 4.重传怎么考虑效率? 5.能不能不阻塞只穿丢掉的中间的段?\n课后作业2 三台同网段内的服务器,模拟实现一个路由器\n方法一:Linux操作系统配置法提示: 1.了解Linux的路由配置方式2.确保是同网段直连可达的环境.在三台机器上另外配置IP网段和路由. 3.一台机器做客户端,一台机器做路由器,一台机器做服务端. 4.客户端配置到达服务器的下一跳指向路由器,路由器上配置到达服务端的路由\n方法二:用户态socket编程实现简易route软件提示: 1.收到指定的包后,做转发2.注意是修改报文的MAC.不是修改IP. 3.实现一个对称路由.这样可以实现TCP交互 4.可以通过ping来验证5.可以支持traceroute吗?\n第六次课程 域名系统的问题 内网域名的解析也得出公网去获取,效率低下 外部用户看到内网 ip地址,容易被 hacker攻击 云厂商权威DNS容易出故障,影响用户体验 解决方案, 自建 DNS\n常见的开源DNS:bind、nsd、knot、 coredns\nDNS 解析的一般步骤： 发起解析请求：当用户在浏览器中输入一个域名时，系统首先会检查本地的 DNS 缓存，如果存在对应的解析结果则直接返回。如果本地缓存没有相关记录，系统会发起 DNS 解析请求。 查询本地 DNS 服务器：如果本地缓存没有域名解析记录，系统会向本地 DNS 服务器（通常由 ISP 或企业提供）发送解析请求。 递归查询过程：如果本地 DNS 服务器不知道域名的解析结果，它会向根 DNS 服务器发起递归查询请求。 根 DNS 服务器响应：根 DNS 服务器是整个 DNS 系统的顶级服务器，它并不直接返回域名解析结果，而是告诉本地 DNS 服务器应该向哪个顶级域名服务器（TLD DNS 服务器）发送查询请求。 TLD DNS 服务器响应：本地 DNS 服务器收到根 DNS 服务器返回的 TLD DNS 服务器地址后，向 TLD DNS 服务器发送解析请求。 权威 DNS 服务器响应：TLD DNS 服务器会告诉本地 DNS 服务器要查询的域名的权威 DNS 服务器的地址。 权威 DNS 服务器响应：本地 DNS 服务器向权威 DNS 服务器发起解析请求。 解析结果返回：权威 DNS 服务器将域名的解析结果发送给本地 DNS 服务器。 缓存解析结果：本地 DNS 服务器将解析结果保存在缓存中，并将结果返回给用户的设备。同时，将解析结果缓存在本地，以便下次查询时可以直接返回，提高解析速度。 用户设备使用 IP 地址访问：用户设备收到 IP 地址后，会使用该地址发起与目标服务器之间的通信，实现对域名的访问。 通过以上步骤，DNS 解析过程中的各级 DNS 服务器协同工作，将域名转换为 IP 地址，使用户能够通过域名访问互联网上的各种资源。\n动态加速DCDN 针对POST等非静态请求等不能在用户边缘缓存的业务, 基于智能选路技术, 从众多回源线路中择优选择一条线路进行传输. 请区分下列场景使用的加速类型\n1、用户首次登录抖音,注册用户名手机号等用户信息 动态加速DCDN 2、抖音用户点开某个特定的短视频加载后观看 静态加速CDN 3、用户打开头条官网进行网页浏览 静态加速CDN+动态加速DCDN 4层负载均衡特点 大部分都是通过dpdk技术实现,技术成熟,大厂都在用 纯用户态协议栈,kernel bypass,消除协议栈瓶颈 无缓存,零拷贝,大页内存(减少 cache miss) 仅针对4层数据包转发,小包转发可达到限速,可承受高cps 什么是 nginx Nginx（发音为 \u0026ldquo;engine-x\u0026rdquo;）是一款高性能的开源 Web 服务器软件，也可以用作反向代理服务器、负载均衡器和 HTTP 缓存。它由俄罗斯的程序员 Igor Sysoev 开发，并于 2004 年首次发布。\nNginx 的主要特点包括：\n高性能：Nginx 采用了异步非阻塞的事件驱动架构，能够高效地处理大量并发连接和高流量的请求。 轻量级：Nginx 的内存占用较低，适合于资源受限的环境，并且能够有效利用系统资源。 反向代理：Nginx 可以用作反向代理服务器，接收客户端的请求并将其转发到后端服务器，隐藏后端服务器的真实 IP 地址，提供更好的安全性和负载均衡能力。 负载均衡：Nginx 可以基于不同的算法（如轮询、IP 哈希、最少连接等）将请求分发到多个后端服务器，实现负载均衡，提高系统的可扩展性和稳定性。 静态文件服务：Nginx 能够快速地处理静态文件的请求，通过内置的缓存机制提供高效的静态内容传输。 HTTP 缓存：Nginx 支持反向代理缓存和本地 HTTP 缓存，可以减少后端服务器的负载并加快内容传输速度。 HTTPS 支持：Nginx 能够配置 SSL 证书，提供安全的 HTTPS 连接。 可扩展性：Nginx 具有模块化的架构，可以通过加载不同的模块来扩展其功能。 由于其出色的性能和可靠性，Nginx 被广泛应用于许多大规模的网站、应用程序和服务中，包括一些知名的公司和网站，如 Netflix、GitHub、微博等。\n优点\n模块化设计,较好的扩展性和可靠性 基于master/worker架构设计 支持热部署;可在线升级不停机更新配置文件、更换日志文件、更新服务器二进制 较低的内存消耗:1万个keep-alive连接模式下的非活动连接仅消耗2.5M内存 https://dashboard.ngrok.com/get-started/setup\n","date":"2023-08-01T10:16:54Z","permalink":"https://li54426.github.io/p/go_5_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","title":"Go_5_网络编程"},{"content":" content {:toc} 0 jekyII + github pages 运行博客的问题 我的typora中的图片设置为复制到assets文件夹下，因此github page生成博客的时候会发生图片加载失败的问题。\n这是上传到 gitee 云的 png 文件 加载失败\n这是上传到 gitee 云的 webp 文件 加载成功\n一共有两种解决方案\n图片转换为 webp 文件，上传\n存储到到固定目录下，如果你的图片存在根目录assets中img文件夹下，写相对位置assets/img，例如![图片](assets/img/1.png)\n使用base64编码\n在截屏快捷键截屏后直接复制 base64 编码到 Markdown 编辑器\n3.2 引用图片和其它资源 很多时候，你需要在文章中引用图片、下载或其它数字资源。尽管 Markdown 和 Textile 在链接这些资源时的语法并不一样，但你只需要关心在站点的哪些地方保存这些文件。\n由于 Jekyll 的灵活性，有很多方式可以解决这个问题。一种常用做法是在工程的根目录下创建一个文件夹，命名为　assets 或者 downloads，将图片文件，下载文件或者其它的资源放到这个文件夹下。然后在任何一篇文章中，它们都可以用站点的根目录来进行引用。这和你站点的域名 / 二级域名和目录的设置相关，下面有一些例子（Markdown 格式）来演示怎样利用 site.url 变量来解决这个问题。\n在文章中引用一个图片\n1 2 … 从下面的截图可以看到： ![有帮助的截图]({{ site.url }}/assets/screenshot.jpg) 链接一个读者可下载的 PDF 文件：\n1 … 你可以直接 [下载 PDF]({{ site.url }}/assets/mydoc.pdf). 1 简介 1.1 Jekyll 究竟是什么？ Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如 Markdown）和我们的 Liquid 渲染器转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的。\n站点内容页面，可以使用 markdown 或 html 来编写，但 markdown 编写的 md 文件，在浏览器地址访问的时候依然使用 html 文件后缀。且html优先级更高\n官方文档\n1 2 3 4 5 6 7 8 9 10 11 12 $ jekyll build # =\u0026gt; 当前文件夹中的内容将会生成到 ./_site 文件夹中。 $ jekyll build --destination \u0026lt;destination\u0026gt; # =\u0026gt; 当前文件夹中的内容将会生成到目标文件夹\u0026lt;destination\u0026gt;中。 $ jekyll build --source \u0026lt;source\u0026gt; --destination \u0026lt;destination\u0026gt; # =\u0026gt; 指定源文件夹\u0026lt;source\u0026gt;中的内容将会生成到目标文件夹\u0026lt;destination\u0026gt;中。 $ jekyll build --watch # =\u0026gt; 当前文件夹中的内容将会生成到 ./_site 文件夹中， # 查看改变，并且自动再生成。 1.2 目录结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . ├── _config.yml ├── _drafts | ├── begin-with-the-crazy-ideas.textile | └── on-simplicity-in-technology.markdown ├── _includes | ├── footer.html | └── header.html ├── _layouts | ├── default.html | └── post.html ├── _posts | ├── 2007-10-29-why-every-programmer-should-play-nethack.textile | └── 2009-04-26-barcamp-boston-4-roundup.textile ├── _site ├── .jekyll-metadata └── index.html config.yml 里写有整个站点的主要配置项 _includes 可以在模板中随时包含的文件 _layouts 布局文件，在博客头配置中可以选择 _posts 下的所有目录中的所有博客 注意: .yml 文件中，字段的冒号后面必须有空格！\n2 头部信息(设置信息) 2.1 头信息 变量名称 描述 layout 如果设置的话，会指定使用该模板文件。指定模板文件时候不需要文件扩展名。模板文件必须放在 _layouts 目录下。 permalink 如果你需要让你发布的博客的 URL 地址不同于默认值 /year/month/day/title.html，那你就设置这个变量，然后变量值就会作为最终的 URL 地址。 published 如果你不想在站点生成后展示某篇特定的博文，那么就设置（该博文的）该变量为 false。 date 这里的日期会覆盖文章名字中的日期。这样就可以用来保障文章排序的正确。日期的具体格式为 YYYY-MM-DD HH:MM:SS +/-TTTT；时，分，秒和时区都是可选的。 category 除过将博客文章放在某个文件夹下面外，你还可以指定博客的一个或者多个分类属性。这样当你的站点生成后，这些文章就可以根据这些分类来阅读。categories 可以通过 YAML list，或者以逗号隔开的字符串指定。 tags 类似分类 categories，一篇文章也可以给它增加一个或者多个标签。同样，tags 可以通过 YAML 列表或者以逗号隔开的字符串指定。 2.2 格式 传统的块格式使用连字符 + 空格来开始列表中的新项目。\n1 2 3 4 --- # Favorite movies - Casablanca - North by Northwest - The Man Who Wasn\u0026#39;t There 可选的内联格式由逗号+空格分隔，并括在括号中\n1 2 --- # Shopping list [milk, pumpkin pie, eggs, juice] 2.3 默认值 假设您想添加一个默认的布局给站点中的所有页面和文章。 你要将这添加到你的 _config.yml 文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 defaults: - scope: path: \u0026#34;\u0026#34; type: \u0026#34;posts\u0026#34; values: layout: \u0026#34;my-site\u0026#34; - scope: path: \u0026#34;projects\u0026#34; type: \u0026#34;pages\u0026#34; # 以前的 `page`， 在 Jekyll 2.2 里。 values: layout: \u0026#34;project\u0026#34; # 覆盖之前的默认布局 author: \u0026#34;Mr. Hyde\u0026#34; 2.4 路径的组织方式 总体设置\n1 2 3 4 5 6 7 8 9 #产生路径方式 permalink: pretty permalink: /:categories/:title.html # 可以使用分类的方式 permalink: /:categories/:title.html # 这是默认的方式 permalink: /:year/:month/:day/:title.html https://xxxx.github.io/algorithm/2023/07/30/problem-string/ 单独设置\n1 2 3 --- permalink: /about/ --- Permalink Style URL Template date /:categories/:year/:month/:day/:title:output_ext pretty /:categories/:year/:month/:day/:title/ ordinal /:categories/:year/:y_day/:title:output_ext weekdate4.0 /:categories/:year/W:week/:short_day/:title:output_ext (W will be prefixed to the value of :week) none /:categories/:title:output_ext 3 其他 3.1 github 某些 样式 Jekyll Themes\ncotes2020/jekyll-theme-chirpy：一个用于技术写作的最小、响应迅速且功能丰富的 Jekyll 主题。 (github.com)\n博客模板 1\nartemsheludko/bef: Bef is a responsive jekyll theme https://artemsheludko.github.io/bef/\nleopardpan/leopardpan.github.io: 个人博客，看效果进入\n再用 2023 依旧更新\n","date":"2023-07-31T19:55:34Z","permalink":"https://li54426.github.io/p/jekyll%E8%BF%9B%E9%98%B6%E8%AE%BE%E7%BD%AE/","title":"jekyll进阶设置"},{"content":"[TOC]\nctrl + /打开专注模式\nHTTp 框架 超文本传输协议 请求行/状态行 方法名 URL 协议版本 请求头/响应头 请求体/响应体 1 2 3 4 5 6 POST /sis HTTP/1.1 Who: Alex Content-Type: text/plain Host: 127.0.0.1:8888 Content-Length: 28 Let\u0026#39;s watch a movie together 问题与展望 HTTP1 队头阻塞, 传输效率低, 明文传输不安全 (头部太大) HTTP2 多路复用, 头部压缩, 二进制协议 QUIC 基于 UDP 实现, 解决队头阻塞加, 密减少握手次数, 支持快速启动 盖尔定律 一个切实可行的复杂系统势必是从一个切实可行的简单系统发展而来的。从头开始设计的复杂系统根本不切实可行，无法修修补补让它切实可行。你必须由一个切实可行的简单系统重新开始。\n先 run起来, 再考虑复用, 使用迭代的方式进行\n合理的 API 不要试图在文档中说明,很多用户不看文档, 这也是在说: 代码的自注释性\n可理解性:如ctx.Body(),ctx.GetBody(),不要用ctx. BodyA() 简单性:如ctx.Request. Header.Peek(key) /ctx. GetHeader(key) 冗余性 兼容性 可测性 可见性 什么是框架和中间件 在计算机编程和软件开发中，框架中间件（Framework Middleware）是指位于应用程序和底层框架之间的软件组件或功能模块。它提供了一种可插拔的方式，用于增强、定制或修改框架的行为，以满足特定的需求。\n框架中间件在应用程序和底层框架之间充当了一个抽象层，用于处理和转换请求、响应以及其他相关的操作。它可以介入整个请求 - 响应周期，对数据进行预处理、后处理或者执行其他的附加操作。\n框架中间件的主要作用有：\n路由和请求处理：中间件可以通过路由机制将请求分发给不同的处理程序，并执行相应的操作。它可以处理 URL 解析、参数提取、权限验证等任务。 数据转换和格式化：中间件可以对请求和响应的数据进行转换、验证和格式化。例如，可以将请求数据解析为特定的格式（如 JSON、XML），或者将响应数据转换为适合客户端的格式。 认证和授权：中间件可以处理用户身份认证和访问控制的任务。例如，它可以检查用户凭据、验证权限，决定是否允许用户继续执行操作。 缓存和性能优化：中间件可以在请求到达框架之前或之后，进行数据缓存、结果缓存以及其他的性能优化操作。它可以减少对底层资源的访问，提高应用程序的响应速度和性能。 日志记录和错误处理：中间件可以记录应用程序的运行日志，并处理异常情况和错误。它可以捕获和处理异常，记录错误信息，使得问题排查和故障修复更加方便有效。 框架中间件的设计目标是提供灵活性和可扩展性，以满足不同应用程序的需求。通过使用框架中间件，开发人员可以以模块化的方式定制和增强框架的功能，使得应用程序的开发和维护更加容易和高效。\n洋葱模型 适用场景:\n日志记录 性能统计 安全控制 事务处理 异常处理 什么是 Handler 在计算机编程和软件开发中，Handler（处理器）是指用于处理特定事件或请求的代码块、函数或对象。它充当了一个中间人，接收来自外部系统或其它组件的事件或请求，并对其进行适当的处理和响应。\nHandler 的主要任务是根据接收到的事件或请求的类型，执行相应的逻辑。它可以包括各种操作，如数据处理、错误处理、用户界面更新、网络通信、数据库查询等。\nHandler 可以存在于不同的上下文中。例如，对于图形用户界面（GUI），一个按钮点击事件的处理者就是一个 Handler；在服务端开发中，一个 HTTP 请求的处理者也可以被称为 Handler。它们根据特定的事件或请求类型，执行相应的操作以满足需求。\n在许多框架和库中，一般会有一套明确定义的规则和接口来定义和使用 Handler。这些规则和接口可以使开发人员更方便地定义和注册 Handler，并将其与相应的事件或请求关联起来。\n总之，Handler 是用于处理特定事件或请求的代码块、函数或对象，它负责执行相关的逻辑以满足需求。通过合理的使用和组织 Handler，可以有效地管理和处理系统中的各种事件和请求。\n框架路由实际上就是为URL匹配对应的处理函数(Handlers)\n静态路由:/a/b/c./a/b/d\n参数路 :/a/:id/c(/a/b/c,/a/d/c)./*all\n路由修复:\n如果只注册了 /a/b，但是访问的 URI 是 /a/b/，那可以提供自动重定向到 /a/b 能力；同样，如果只注册了 /a/b/，但是访问的 URI 是 /a/b，那可以提供自动重定向到 /a/b/ 能力 冲突路由以及优先级\n同时注册 /a/b 和 /:id/b，并设定优先级。比如：当请求 URI 为 /a/b 时，优先匹配静态路由 /a/b 匹配HTTP方法\n多处理函数:方便添加中间件\n如何匹配HTTP方法\n开发流程 1.明确需求:考虑清楚要解决什么问题,有哪些需求 2.业界调研:业界都有哪些解决方案可供参考 3.方案权衡:思考不同方案的取舍 4.方案评审:相关同学对不同方案做评审 5.确定开发:确定最合适的方案进行开发 1 2 3 4 5 6 7 8 9 type Server interface{ Serve(c context. Context, conn network.Conn) error } type Conn interface { Read(b []byte)(n int, err error) Write(b []byte)(n int, err error) } 字节内部网络模型\n总结 API设计:可理解性、简单性 中间件设计: 洋葱模型 路由设计:前缀匹配树 协议层设计:抽象出合适的接口 网络层设计: 网络模型 设计点 存下全部Header 减少系统调用次数 能够复用内存 能够多次读 1 2 3 4 5 6 7 8 type Reader interface { // 开始读的位置 Peek(n int)([]byte, error) Discard(n int)(discarded int, err error) Release() error Size() int Read(b []byte)(l int, err error) } 网络库比较 go net 流式友好, 小包性能高 netpoll 中大包性能高, 时延低 针对协议的优化 找到Header Line边界:\\r\\n, 先找到\\n再看它前一个是不是\\r 热点资源池化 针对协议相关的Headers\n1.通过 Header key 首字母快速筛除掉完全不可能的 key 2.解析对应 value到独立字段 3.使用 byte slice 管理对应 header 存储,方便复用请求体中同样处理的Key: User-Agent、 Content-Type、 Content-Length、 Connection、 Transfer-Encoding 开源 json 库\nSIMD技术 SIMD（Single Instruction, Multiple Data）是一种并行计算的技术，它在同一时间执行相同的指令来处理多个数据元素。它是在计算机体系结构中用于向量化操作的一种方式。\n传统的计算机指令集架构（ISA）以标量方式执行指令，即每次执行一个指令处理一个数据元素。而 SIMD 架构通过引入特殊的寄存器和指令集，能够同时处理多个数据元素，加速并行计算。\nSIMD 技术适用于那些可以被划分为多个独立任务的数据，并且这些任务可以并行地进行相同的计算。它可以提高多媒体处理、图形渲染、信号处理、科学计算等应用的性能。\nSIMD 指令集提供了一系列的指令，用于在单个时钟周期内同时对多个数据进行相同的操作。这些指令可以一次性处理多个数据元素，例如同时对四个浮点数执行加法操作。\n常见的 SIMD 指令集包括 Intel 的 SSE（Streaming SIMD Extensions）、AMD 的 3DNow!、ARM 的 NEON 等。这些指令集通常有不同的版本，支持不同的宽度（如 128 位、256 位）和数据类型（如整数、浮点数）。\n使用 SIMD 技术可以显著提高计算性能，但需要合理的程序设计和优化以充分利用 SIMD 指令集的并行计算能力。许多编程语言和编译器提供了对 SIMD 的支持，使得开发者能够方便地利用 SIMD 技术来加速计算。\n性能不是全部 追求性 追求易用, 减少误用 打通内部生态 文档建设、用户群建设, websocket 我们知道 TCP 连接的两端，同一时间里，双方都可以主动向对方发送数据。这就是所谓的全双工。而现在使用最广泛的 HTTP/1.1，也是基于 TCP 协议的，同一时间里，客户端和服务器只能有一方主动发数据，这就是所谓的半双工。\n这是由于 HTTP 协议设计之初，考虑的是看看网页文本的场景，能做到客户端发起请求再由服务器响应，就够了，根本就没考虑网页游戏这种，客户端和服务器之间都要互相主动发大量数据的场景。\n所以，为了更好的支持这样的场景，我们需要另外一个基于 TCP 的新协议。\n于是新的应用层协议 WebSocket 就被设计出来了。\n我们平时刷网页，一般都是在浏览器上刷的，一会刷刷图文，这时候用的是 HTTP 协议，一会打开网页游戏，这时候就得切换成我们新介绍的 WebSocket 协议。\n为了兼容这些使用场景。浏览器在 TCP 三次握手建立连接之后，都统一使用 HTTP 协议先进行一次通信。\n如果此时是普通的 HTTP 请求，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。 如果这时候是想建立 WebSocket 连接，就会在 HTTP 请求里带上一些特殊的 header 头，如下： 1 2 3 Connection: Upgrade Upgrade: WebSocket Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\\r\\n 这些 header 头的意思是，浏览器想升级协议（Connection: Upgrade），并且想升级成 WebSocket 协议（Upgrade: WebSocket）。同时带上一段随机生成的 base64 码（Sec-WebSocket-Key），发给服务器。\n如果服务器正好支持升级成 WebSocket 协议。就会走 WebSocket 握手流程，同时根据客户端生成的 base64 码，用某个公开的算法变成另一段字符串，放在 HTTP 响应的 Sec-WebSocket-Accept 头里，同时带上 101状态码，发回给浏览器。HTTP 的响应如下：\n1 2 3 4 HTTP/1.1 101 Switching Protocols\\r\\n Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\\r\\n Upgrade: WebSocket\\r\\n Connection: Upgrade\\r\\n RPC框架 什么是 RPC RPC（Remote Procedure Call）是一种用于实现分布式系统通信的协议和机制。它允许一个进程（客户端）调用另一个运行在不同地址空间的进程（服务器）中的函数或方法，就像调用本地函数一样。\nRPC 的工作原理如下：\n客户端通过本地调用的方式调用远程服务器的函数或方法。 客户端的 RPC stub（存根）将调用信息打包成网络可传输的消息，并发送给远程服务器。 服务器的 RPC stub 接收到消息后，解包调用信息并调用对应的函数或方法。 函数或方法执行完毕后，将结果打包成响应消息，并发送给客户端。 客户端的 RPC stub 接收到响应消息后，解包结果并返回给本地调用方。 通过 RPC，开发人员可以轻松地在分布式系统中调用远程服务，而无需关心底层的网络通信细节。它隐藏了网络通信的复杂性，使得分布式系统开发更加方便和高效。\nRPC 的优势包括：\n简化分布式系统开发：RPC 提供了一种简单而直观的方法来调用远程服务，使得分布式系统开发更加容易和高效。 高效的网络通信：RPC 可以使用高效的序列化和网络传输协议，以最小的开销在分布式系统间传递数据。 抽象底层细节：RPC 抽象了底层的网络通信细节，使得开发人员可以更专注于业务逻辑的实现，而不用关心底层通信协议和传输细节。 常见的 RPC 框架包括 gRPC、Apache Thrift、Spring Cloud、Dubbo 等。这些框架提供了丰富的功能和工具，使得分布式系统的开发、部署和管理更加便捷和可靠。\n和 HTTP 对比起来\nHTTP 信息非常的冗余, 而 RPC，因为它定制化程度更高，因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。 当然上面说的 HTTP，其实特指的是现在主流使用的 HTTP/1.1，HTTP/2 在前者的基础上做了很多改进，所以性能可能比很多 RPC 协议还要好，甚至连 gRPC 底层都直接用的 HTTP/2。那么问题又来了，为什么既然有了 HTTP/2，还要有 RPC 协议？这个是由于 HTTP/2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了 RPC需要解决的问题\n1 函数映射 2.数据转换成字节流 3.网络传输 RPC 的概念模型：\nUser、 User-Stub、 RPC-Runtime、 Server-Stub、 Server 优缺点 优点\n单一职责,有利于分工协作和运维开发 可扩展性强, 资源使用率更优 故障隔离, 服务的整体可靠性更高 坏处\n1.服务宕机,对方应该如何处理? 2.在调用过程中发生网络异常,如何保证消息的可达性? 3.请求量突增导致服务无法及时处理, 有哪些应对措施? 分层设计 编解码层 包括生成代码\n协议层\n网络层\n语言特定的格式\n许多编程语言都内建了将内存对象编码为字节序列的支持,例如Java有java.io.Serializable 文本格式JSON、XML、CSV等文本格式,具有人类可读性\n二进制编码, 具备跨语言和高性能等优点,常见有Thrift的 BinaryProtocol, Protobuf\nTLV编码\nTag:标签,可以理解为类型 Lenght:长度 Value:值,Value也可以是个TLV结构 增加了冗余信息\n编码层如何选 兼容性, 支持自动增加新的字段,而不影响老的服务,这将提高系统的灵活度 通用性支持跨平台、跨语言 性能从空间和时间两个维度来考虑,也就是编码后数据大小和编码耗费时长 微服务 微服务架构是当前大多数互联网公司的标准架构.\n软件架构定义 ​ 软件架构是构建应用系统所需要的一组结构，包括软件元素、元素之间的关系以及两者的属性。其中如何分解软件元素以及这些元素之间的关系，变得非常重要。一个好的软件架构具备两个特点:\n合理调配生产关系与生产力，让具备不同专业知识与技术栈的的人士都参与到软件系统开发中来， 高效地协同工作； 能让各个软件元素有清晰的定义与职责，并有一套良好、高效的交互机制. 为什么系统架构需要演进?\n互联网的爆炸性发展 硬件设施的快速发展 需求复杂性的多样化开发人员的急剧增加 计算机理论及技术的发展 单体模式 all in one process\n优势\n1.性能最高 2冗余小 劣势:\n1.debug 2.模块相互影响 3.模块分工、开发流程\n分布式架构 抽出业务无关的公共模块, 服务层\n优势: 1.业务无关的独立服务\n劣势:\n1.服务模块bug可导致全站瘫痪 2.调用关系复杂 3.不同服务冗余 微服务架构 在讲述微服务架构之前一定要讲下经典的扩展立方体理论，扩展立方体定义了三种不同的扩展应用程序的方法：\nX 轴扩展在多个相同实例之间实现请求的负载均衡；\nY 轴扩展根据功能将应用程序拆分为服务；\nZ 轴扩展根据请求的属性路由请求.\nX扩展,称为水平复制,通过克隆实例的方式发展\nY轴扩展,又称为功能性分解,通过不同\nZ轴扩展,又称为数据分区,通过类似客户ID的方式,把相同的数据分区进行扩展\n微服务架构其实可以理解为” 模块化设计 \u0026ldquo;的扩展延伸，只是这些\u0026rdquo; 功能模块 \u0026quot; 以单独的部署包的方式运行在各自的进程中。这样每个服务之间都是相互独立的，并且有自己的私有数据库，两者之间仅能通过 API 的方式进行通信。\n从单体架构到微服务架构的演进也带来了以下好处:\n从代码管理来看，每个服务较小，大部分由于十几个接口或服务方法组成，非常容易维护； 从运维管理来看，每个服务都可以独立部署，非常易于扩展； 从团队管理来看，可以更好地划分职责范围； 从软件开发总体来看，可以使软件系统可持续性交付部署. 彻底的服务化优势:\n1.开发效率 2.业务独立设计 3.自下而上 4.故障隔离 劣势:\n1.治理、运维难度 2.观测挑战 3.安全性 4.分布式系统 微服务架构概览\n网关 服务配置和治理 链路追踪和监控 微服务架构的三大要素 服务治理（本课程内容）\n服务注册 服务发现 负载均衡 扩缩容 流量治理 稳定性治理 可观测性\n日志采集 日志分析 监控打点 监控大盘 异常报警 链路追踪 安全\n身份验证 认证授权 访问令牌 审计 传输加密 黑产攻击 服务service\n一组具有相同逻辑 (同一份代码) 的运行实体. 实例与进程的关系\n实例与进程之间没有必然对应关系,可以一个实例可以对应一个或多个进程(反之不常见). 常见的实例承载形式\n进程、VM、k8spod… 有状态/无状态服务\n服务的实例是否存储了可持久化的数据(例如磁盘文件). 服务间通信\n对于单体服务,不同模块通信只是简单的函数调用 对于微服务,服务间通信意味着网络传输 使用微服务架构的应用程序是分布式系统，进程间通信是重要组成部分，有以下几种通信模式:\n通信风格：使用哪一种的进程间通信机制； 服务发现：客户端如何获得具体实例的真实 IP 地址； 可靠性：在服务不可用的情况下，如何确保服务之间的可靠通信； 事务性消息：如何将消息发送、事件发布、更新业务数据的数据库事务集成； 外部 API: 应用客户端如何与服务通信. 问题\n在代码层面,如何指定调用一个目标服务的地址(ip:port)\n地址会变 有多个地址 使用 DNS 解决\n本地DNS存在缓存,导致延时. 负载均衡问题. 大部分会只访问第一个 不支持服务实例的探活检查. 域名无法配置端口. 必须约定端口 解决思路:新增一个统一的服务注册中心, 用于存储服务名到服务实例的映射.\n服务发布 问题\n服务不可用 服务抖动 服务回滚 方法\n蓝绿部署\u0026mdash;简单,稳定但需要两倍资源 灰度发布\u0026mdash;一点一点替换, 回滚操作比较难 防止链路重试链路层面的防重试风暴的核心是限制每层都发生重试,理想情况下只有最下一层发生重试. 可以返回特殊的status表明\u0026quot;请求失败,但别重试\u0026quot;.\n","date":"2023-07-31T11:02:06Z","permalink":"https://li54426.github.io/p/go_4_http_rpc_/","title":"Go_4_HTTP_RPC_"},{"content":" content {:toc} 二. 进阶_容器使用 自然有序的容器, 可以直接使用 a.find(), 例如\nset multiset map /multimap unordered_set/unordered_multiset unordered_map/unordered_multimap 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O (1) 无序 可重复 支持随机访问 vector 数组 随机读改、尾部插入、尾部删除 O (1) 头部插入、头部删除 O (n) 无序 可重复 支持随机访问 deque 双端队列 头尾插入、头尾删除 O (1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问 forward_list 单向链表 插入、删除 O (1) 无序 可重复 不支持随机访问 list 双向链表 插入、删除 O (1) 无序 可重复 不支持随机访问 stack deque / list 顶部插入、顶部删除 O (1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O (1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector + max-heap 插入、删除 O (log2n) 有序 可重复 vector 容器 + heap 处理规则 set 红黑树 插入、删除、查找 O (log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O (log2n) 有序 可重复 map 红黑树 插入、删除、查找 O (log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O (log2n) 有序 可重复 unordered_set 哈希表 插入、删除、查找 O (1) 最差 O (n) 无序 不可重复 unordered_multiset 哈希表 插入、删除、查找 O (1) 最差 O (n) 无序 可重复 unordered_map 哈希表 插入、删除、查找 O (1) 最差 O (n) 无序 不可重复 unordered_multimap 哈希表 插入、删除、查找 O (1) 最差 O (n) 无序 可重复 1 迭代器 iterator 1.1 常用迭代器操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 迭代器在容器内部 vector\u0026lt;int\u0026gt; :: iterator it; // 可以使用解引用操作符*，来访问迭代器指向的元素。 *it; // 常用的操作有： ++ -- == != // 只有顺序容器才可以适应it + n, \u0026lt;=,\u0026gt;= // 左闭右开的好处, 判断相等 first == last 代表空。 // 访问元素 it-\u0026gt; mem; // 对两个迭代器进行相减操作，会计算它们之间的距离， auto distance = it2 - it1; // 如果迭代器所指向的容器不支持随机访问，例如 list 或 set，则不能使用迭代器相减操作, 可以考虑使用distance // 位于 \u0026lt;iterator\u0026gt; 头文件中 #include\u0026lt;iterator\u0026gt; typename std::iterator_traits\u0026lt;InputIt\u0026gt;::difference_type distance( InputIt first, InputIt last ); // 如果在调用 std::distance 函数时，第一个迭代器的位置在第二个迭代器的后面，则返回的结果为负数 auto d = std::distance(it1+3, it1); // 在计算迭代器之间的距离时，要确保这两个迭代器都指向同一个容器中的元素或者它们都是指向同一块可寻址内存空间的合法指针。否则，std::distance() 函数的行为是未定义的。 // 找到最大值所在的元素的迭代器, 注意, it1 \u0026lt;= it2 #include\u0026lt;algorithm\u0026gt; max_element(it1, it2); min_element(it1, it2); 获取迭代器的地址 1 2 3 for (auto it = v.begin(); it != v.end(); ++it) { std::cout \u0026lt;\u0026lt; \u0026amp;(*it) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 2 序列式容器 2.1 string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 //四种基本的初始化，顺序容器的初始化，默认，复制，范围，n个值 string s1; string s1(s2); string s3(\u0026#34;sdf\u0026#34;); string s4(n, \u0026#39;c\u0026#39;); // 输入 string string s4; cin \u0026gt;\u0026gt; s4; // 从开始位置复制到最后 string s5(s1, pos); string s6(s1, pos, len); // operator+= s1+= s2; s1+= \u0026#39;c\u0026#39;; // 清空 s.clear(); // 用迭代器内元素替换 s.assign(it1, it2); s.assign(n, value); // 也可以直接使用下标进行修改 s[i] = \u0026#39;0\u0026#39;; // // 也没有 iterator 的形式 // 查找的类型, 开始位置 size_t find (char c, size_t pos = 0) const; size_t find (const string\u0026amp; str, size_t pos = 0) const; size_t find (const char* s, size_t pos = 0) const; // 开始位置, 结束位置 size_t find (const char* s, size_t pos, size_t n) const; // 截取子串, 只有使用下标的形式 // 若超出字符串长度，则默认从 pos 到字符串末尾提取所有字符。 string substr (size_t pos = 0, size_t len = npos) const; // 临时将string对象转换为C风格字符串。不能直接用于修改字符串内容。 const char* string::c_str(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //---------------------插入删除-------------- // 插入字符串, 字符串的子串 string\u0026amp; insert (size_t pos, const string\u0026amp; str);\tstring\u0026amp; insert (size_t pos, const string\u0026amp; str, size_t subpos, size_t sublen); string\u0026amp; insert (size_t pos, const char* s); string\u0026amp; insert (size_t pos, const char* s, size_t n); // 插入char 类型必须要有数量参数 string\u0026amp; insert (size_t pos, size_t n, char c); void insert (iterator p, size_t n, char c); iterator insert (iterator p, char c); // 删除, 默认是全部删除, 单点删除只支持迭代器 string\u0026amp; erase (size_t pos = 0, size_t len = npos); iterator erase (iterator p); iterator erase (iterator first, iterator last); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // ----------------string与 数值类型--------- // 在头文件 string 中 // string =\u0026gt; int int stoi (const string\u0026amp; str, size_t* idx = 0, int base = 10); // string =\u0026gt; double double stod(const string\u0026amp; str, size_t* idx = 0); // 转换为 string // int/ double float =\u0026gt; double string s1 = to_string(123); string s2 = to_string(4.5); //字符处理\u0026lt;cctype\u0026gt; #include \u0026lt;cctype\u0026gt; // 判断一个字符是否为字母或数字 isalnum(char); isalpha(char); isdigit(char); islower(); isupper(); toupper(c); tolower(c); // 判断是否是字母等 isalpha 字⺟母（包括⼤大写、⼩小写） isalnum（字⺟母⼤大写⼩小写+数字） isblank（space和\\t） isspace（space、\\t、\\r、\\n） 输入输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 输入到 string string str; cout \u0026lt;\u0026lt; \u0026#34;请输入一个字符串：\u0026#34;; cin \u0026gt;\u0026gt; str; // 用户输入 \u0026#34;Hello, World!\u0026#34;，则 str 的值为 \u0026#34;Hello,\u0026#34; // 当cin遇到空白字符时就停止，最标准的方法是调用getline(cin,str)函数。 string line; getline(cin, line); // 用户输入 \u0026#34;This is a sentence.\u0026#34;，则 line 的值为 \u0026#34;This is a sentence.\u0026#34; // 从文件输入 ifstream fin(\u0026#34;file.txt\u0026#34;); string str; fin \u0026gt;\u0026gt; str; 2.2 vector the link with capacity\n如果两个vector相比较, 返回第一个不相同元素的 \u0026lt; 比较结果， 内部以连续的方式存放, 当没有空间存放时, 会重新分配空间, 原来的迭代器会失效( 因为地址发生了改变), 插入会使该容器所有的迭代器失效 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //初始化 vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2(v1); //复制v1 vector\u0026lt;int\u0026gt; v3(n, value); //n个值为value的元素 vector\u0026lt;int\u0026gt; v3(n); //n个初始元素的副本。 vector\u0026lt;int\u0026gt; v4(a+1, a+3) //使用数组进行初始化，不包括最后一个地址的元素。 //a的大小 a.size() ; //判断是否为空 v.empty() ; //在容器的最后添加一个值为t的数据，容器的size变大。 v.push_back(t); //删除容器的末尾元素，仅仅删除，没有返回。 a.pop_back() ; //第一个元素，最后一个元素的引用（值）。 v.back(); v.front(); //----------------------大小有关的操作--------------------- //清空 v.clear(); //调整大小。 v.resize(n, t); v.resize(n); //删除，返回删除元素的下一个位置，也是左闭右开。 v.erase(it); v.erase(it1, it2); //插入it 前面, 代表 成为它 , 原来序号是3, 插入的新值序号也是3 //同时返回新元素的迭代器 //第一个版本, 插入一个新的值 v.insert(it, value); //第二个版本, 插入n个新的值 v.insert(it, n, value); //插入it前面，从it1 到it2 的元素 v.insert(it , it1, it2); //第一个元素的地址, 要把vector 和数组区分开。 \u0026amp;v[0]; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // ----------------------多维vector---------- // 多维vector 只能添加 vector\u0026lt;int\u0026gt; // 若想定义A = [[0,1,2],[3,4]]，有两种方法。 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; A; vector\u0026lt;int\u0026gt; B = {0,1,2}; vector\u0026lt;int\u0026gt; C = {3, 4}; A.push_back(B); A.push_back(C); for(int i = 0; i \u0026lt; 2; ++i) { A.push_back(vector\u0026lt;int\u0026gt;()); } A[0].push_back(0); // vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;A中的vector元素的个数 len = A.size(); // vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;A中第i个vector元素的长度 len = A[i].size(); 避免因为插入导致的迭代器失效\n1 2 3 4 5 6 //一个容器中, 读取完元素后, 再插入一个值 auto first = a.begin(), last = a.end() while(first != a.end()){ first = a.insert(++first, 666); ++first; } 关系运算符 \u0026mdash;\u0026mdash;- 容器的比较是基于容器内元素的比较\n当长度相同且元素相等, 则相等 比较的结果 取决于 第一个不相等的元素 当 vector\u0026lt;vector\u0026gt;进行比较时, 空的 vector 被放到前面 2.3 list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 因为是双向链表, 所以 it 可以++, -- list\u0026lt;int\u0026gt; l{1, 2, 3, 4}; // 多个元素的值 list\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; l; // 获取元素的值 l.front(); l.back(); // 头尾均可插入删除 l.push_front(); l.pop_front(); l.push_back(); l.pop_back(); // 插入 l.insert(it, val); l.insert(it, n, val); //n 个 value l.insert(it, it_first, it_last); // delete l.erase(it); l.erase(it_first, it_last); // 拼接 // 整个l2 拼接到 it1的位置 l1.splice(it1, l2) // 将 l2 的 l2_pos 指向元素（节点）切除，拼接到 l1 的 l1_pos 处（l1 和 l2 可相同） l1.splice (iterator l1_pos, list\u0026lt;T,Allocator\u0026gt;\u0026amp; l2, iterator l2_pos ); l1.splice(head, l1, it_2); //将容器lt6的指定迭代器区间内的数据拼接到容器lt5的开头 lt5.splice(lt5.begin(), lt6, lt6.begin(), lt6.end()); // 删除重复元素 l.unique(); // 删除满足条件的元素 bool fun() lt.remove_if(fun); 2.4 deque 1 2 3 4 5 // 初始化 deque\u0026lt;int\u0026gt; de(10, 666); de.push_back(1); de.push_front(1); 2.5 stack 1 2 3 4 5 6 7 8 9 10 11 12 13 stack\u0026lt;int\u0026gt; st; // 判断是否为空 st.empty(); // 入栈 st.push(1); // 返回栈顶元素 st.top() // 出栈 st.pop(); 2.6 queue 1 2 3 4 5 6 7 8 9 10 queue\u0026lt;int\u0026gt; qu; // 进入队列 qu.push(a); // 返回队头元素 qu.front(); // 队头的元素 出队 qu.pop(); 2.7 priority_queue 实质: 堆\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // template \u0026lt;class T, class Container = vector\u0026lt;T\u0026gt;, class Compare = less\u0026lt;typename Container::value_type\u0026gt; \u0026gt; // class priority_queue; // 默认是按小于 (less) 的方式比较，这种比较方式创建出来的就是 大顶堆。 // 就当作 比较的时候 先输入 子节点, 然后输入 父节点 priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, compare\u0026gt; heap; // 初始化方式, 使用迭代器初始化 (it1, it2); // 和 stack 很像 // 添加元素 heap.push(); // 获得堆顶元素 heap.top() // 删除元素 heap.pop(); 2.8 bitset 位运算 与（AND）、或（OR）和异或（XOR）是逻辑运算符，在计算机编程中有一些特殊性：\n与和或 亦或 运算都是可结合的和可交换的，即表达式中多个操作数的顺序不影响最终结果。 异或（XOR）的特殊性：相同为假, 不同为真\n异或运算可以用于检测两个值是否不同，如果两个值不同，则结果为真。\n在编程中，异或运算常用于交换两个值的变量，而无需引入第三个中间变量。\n1的特殊性: 二进制形式如 000000001, 只有末尾一个1\n编程时，请注意运算符的优先级。例如 == 在某些语言中优先级更高, 位运算需要加括号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 将x左移 n位, 补零 x \u0026lt;\u0026lt; n; // 判断 第 d 位是否为 1 // 1 的特殊性, 只有最低位是 1 bit = 0b11001; // 右移也是补 0 bit \u0026gt;\u0026gt;d \u0026amp;1 ; // 按位与操作符的返回值是一个新的二进制数 // 每一位都是两个操作数相应位执行**逻辑操作**的结果 // 一个有 n 位数字的集合如何表示全集 (1\u0026lt;\u0026lt;n)-1 ; // 遍历集合 for (int i = 0; i \u0026lt; n; i++) { if ((s \u0026gt;\u0026gt; i) \u0026amp; 1) { // i 在 s 中 // 处理 i 的逻辑 } } // 枚举 从空集到 全集 for (int s = 0; s \u0026lt; (1 \u0026lt;\u0026lt; n); s++) { // 处理 s 的逻辑 } // 设集合为 s，从大到小枚举 s 的所有非空子集 sub // 暴力做法是从 s 出发，不断减一直到 0，但这样中途会遇到很多并不是s 的子集的情况。 for (int sub = s; sub; sub = (sub - 1) \u0026amp; s) { // 处理 sub 的逻辑 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026#34;biset\u0026#34; // 和一般的容器不一样, \u0026lt;\u0026gt;中间是多少个二进制位数, 5表示5个⼆二进位 // 默认在高位补零, 下面就是 \u0026#34;00011\u0026#34; bitset\u0026lt;5\u0026gt; b(\u0026#34;11\u0026#34;); // 如果用较大的整数向较小的 bitset 对象赋值，也会发生同样的截断错误，不会产生警告或异常, 并且会将高位丢弃 bitset\u0026lt;3\u0026gt; (16) ; // 从整数创建 std::bitset\u0026lt;8\u0026gt; b(n); // 高位置截断 string str = bs.to_string().substr(bs.to_string().find(\u0026#39;1\u0026#39;)); bitset\u0026lt;5\u0026gt; b; 都为0 bitset\u0026lt;5\u0026gt; b(u); u为unsigned int，如果u = 1,则被初始化为10000 bitset\u0026lt;5\u0026gt; b(s); // s为字符串串，如\u0026#34;1101\u0026#34; -\u0026gt; \u0026#34;10110\u0026#34; bitset\u0026lt;5\u0026gt; b(s, pos, n); // 从字符串串的s[pos]开始，n位⻓长度 // 使用下标, 注意, 重要区别 // b[0] 访问的是 b 的最右边的一位，即二进制数的最低位 // 访问 std::bitset 对象的元素时，如果所访问的元素的值为 0，则索引操作符返回 false；如果所访问的元素的值为 1，则索引操作符返回 true。 // 可以直接输出 cout \u0026lt;\u0026lt; bitset\u0026lt;8\u0026gt;(15); // b中⼆二进制位的个数 b.size(); // 统计1的位数 int count = b.count(); // 0 1操作 //把b的下标为4处置1 b.set(4); //所有位归零 b.reset(); b.reset(3); //b的下标3处归零 // 操作符, 必须位数相同才能操作 std::bitset\u0026lt;8\u0026gt; b3 = b1 \u0026amp; b2; // 位与 std::bitset\u0026lt;8\u0026gt; b4 = b1 | b2; // 位或 std::bitset\u0026lt;8\u0026gt; b5 = b1 ^ b2; // 位异或 std::bitset\u0026lt;8\u0026gt; b6 = b1 \u0026lt;\u0026lt; 2; // 左移 2 位 std::bitset\u0026lt;8\u0026gt; b7 = b1 \u0026gt;\u0026gt; 2; // 右移 2 位 // 所有位都为真 cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; b.any(); //b中是否存在1的⼆二进制位 // 所有位都为假 cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; b.none(); //b中不不存在1吗？ cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; b.count(); //b中1的⼆二进制位的个数 cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; b.test(2); //测试下标为2处是否⼆二进制位为1 b.flip(); //b的所有⼆二进制位逐位取反 unsigned long a = b.to_ulong(); //b转换为unsigned long类型 3 关联式容器 3.1 pair 1 2 3 4 5 6 7 8 9 10 11 12 13 typedef pair\u0026lt;int, int\u0026gt; mypair; // map 中 key 类型是 const 类型 map\u0026lt;int, int\u0026gt; mp; for(auto \u0026amp; node: mp){ // 实际要写成 pair\u0026lt;const int, int\u0026gt; node: } pair\u0026lt;int, int\u0026gt; p; // 只有两个成员, 注意不是成员 函数 p.first; p.second; 3.2 map map/multimap属于 关联式 容器，底层结构是用 二叉树( 红黑树 ) 实现, 时间复杂度为O(logn)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a.size(); //返回容器中元素的数目 a.empty(); //判断容器是否为空 swap(st); //交换两个集合容器 a.count(key); //统计key的元素个数 // 清除元素 void erase (iterator position); size_type erase (const key_type\u0026amp; k); void erase (iterator first, iterator last); void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m){ for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++){ cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } 3.1 unordered_map 基于哈希表, 空间大, 时间复杂度不稳定,平均为常数级O(c), 取决于哈希函数,极端情况下为O(n)\nunordered_map\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt; mp会报错, 因为没有给pair做 Hash 函数 map 里面是通过操作符 \u0026lt; 来比较大小，而 pair 是可以比较大小的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 注意：C++11才开始支持括号初始化 unordered_map\u0026lt;int, string\u0026gt; mp={ { 1, \u0026#34;张三\u0026#34; },{ 2, \u0026#34;李四\u0026#34; } }; // 使用[ ]进行单个插入，若已存在键值，则赋值修改，若无则 插入。 mp[2] = \u0026#34;李四\u0026#34;; //不会插入 // 使用键值 删除 size_type erase ( const key_type\u0026amp; k ); // 使用insert和pair插入, 麻烦 mp.insert(pair\u0026lt;int, string\u0026gt;(3, \u0026#34;王二\u0026#34;)); //遍历输出+迭代器的使用 auto iter = mp.begin();//auto自动识别为迭代器类型unordered_map\u0026lt;int,string\u0026gt;::iterator while (iter!= myMap.end()){ cout \u0026lt;\u0026lt; iter-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; iter-\u0026gt;second \u0026lt;\u0026lt; endl; ++iter; } unordered_map\u0026lt;Key,T\u0026gt;::iterator it; it-\u0026gt;first; // same as (*it).first (the key value) it-\u0026gt;second; // same as (*it).second (the mapped value) 3.3 set 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 定义⼀一个空集合s set\u0026lt;int\u0026gt; s; // 增 s.insert(1); // 删除集合s中的1这个元素 s.erase(1); // 查 s.count(1); // s.find() 返回迭代器 // 根据 STL 前毕后开的特点 如果结果等于s.end()表示未找到 s.find(2) != s.end()) \u0026lt;\u0026lt; endl; 3.4 multiset 1 2 3 multiset\u0026lt;int\u0026gt; set; // 使用键值删除会全部删除 st.erase (40); // [10 30 40 40 50 60] -\u0026gt; [10 30 50 60] 4 算法库 \u0026amp; 常用库 4.1 sort 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # include \u0026lt;algorithm\u0026gt; // 默认，v从⼩小到⼤大排列, 并且是前闭后开 sort(v.begin(), v.end()); //cmp函数返回的值是bool类型 bool cmp(int a, int b) { return a \u0026gt; b; // 从⼤大到⼩小排列列 } // 有时候这种简单的if-else语句句我喜欢直接⽤用⼀一个C语⾔言⾥里里⾯面的三⽬目运算符表示～ bool cmp(stu a, stu b) { return a.score != b.score ? a.score \u0026gt; b.score : a.number \u0026lt; b.number; } // 也可以使用 lambda 表达式 sort(envelopes.begin(), envelopes.end(), [](const auto\u0026amp; e1, const auto\u0026amp; e2) { return e1[0] \u0026lt; e2[0] || (e1[0] == e2[0] \u0026amp;\u0026amp; e1[1] \u0026gt; e2[1]); }); 4.2 max \u0026amp; min \u0026amp; max_element() \u0026amp; min_element 1 2 3 4 5 6 // max min 四 个版本 template \u0026lt;class T\u0026gt; const T\u0026amp; max (const T\u0026amp; a, const T\u0026amp; b); template \u0026lt;class T, class Compare\u0026gt; const T\u0026amp; max (const T\u0026amp; a, const T\u0026amp; b, Compare comp); template \u0026lt;class T\u0026gt; T max (initializer_list\u0026lt;T\u0026gt; il); max({3, 4, 5}); template \u0026lt;class T, class Compare\u0026gt; T max (initializer_list\u0026lt;T\u0026gt; il, Compare comp); 1 2 3 4 // 找最大最小值, 返回的是 **迭代器** template \u0026lt;class ForwardIterator\u0026gt; ForwardIterator max_element (ForwardIterator first, ForwardIterator last); template \u0026lt;class ForwardIterator, class Compare\u0026gt; ForwardIterator max_element (ForwardIterator first, ForwardIterator last, Compare comp); 4.5 lower_bound() 1 2 3 4 5 // 二分查找最低位 It lower_bound(ForwardIt first, ForwardIt last, const T\u0026amp; value); // 重载形式 ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T\u0026amp; value, Compare comp); 4.3 累加accumulate 使用时注意初值 accumulate(nums2.begin(), nums2.end(), 0LL) 中的 0LL 表示将初始值设为 long long 类型的 0 值，而 accumulate(nums2.begin(), nums2.end(), 0) 中的 0 表示将初始值设为 int 类型的 0 值。会有溢出风险 1 2 3 4 5 6 7 8 9 // 默认相加的操作, 最后一个参数为初始值, 必须有初始值 accumulate(it1, it2, init_value); // 自定义运算 std::string str1 = \u0026#34;hello\u0026#34;; std::string str2 = \u0026#34;world\u0026#34;; int sum = std::accumulate(str1.begin(), str1.end(), 0, [=](int acc, char c) {return acc + c + str2[c - \u0026#39;a\u0026#39;];}); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;class InputIt, class T\u0026gt; T accumulate(InputIt first, InputIt last, T init) { for(; first != last; ++first) { init = init + *first; } return init; } // template\u0026lt;class InputIt, class T, class BinaryOp\u0026gt; T accumulate(InputIt first, InputIt last, T init, BinaryOp op) { for(; first != last; ++first) { init = op(init, *first); } return init; } unique 让区间内的元素唯一 使用之前先排序 只能移除相邻的重复元素，并将重复元素移动到区间的末尾，然后返回指向新的区间尾部 1 2 // 返回最后一个唯一元素 it unique(nums.begin(), nums.end()); 4.2 常用算法_find fill for_each 1 2 3 4 5 6 7 8 9 10 //查找元素, find返回迭代器, 如果没找到, 返回it2, 因此, 检查返回值和it2 是否相等可以看出是否找到. find(it1, it2 , value); //将value的副本写入指定的范围, 只对输入范围内部的元素进行写入操作 fill(it1, it2, value); //对于每一个元素都执行的操作 for_each(it1, it2, func) for_each(a.begin(), a.end(),[\u0026amp;](int x){cout\u0026lt;\u0026lt; x\u0026lt;\u0026lt; endl;}); 4.4 copy() 1 2 3 4 5 6 7 8 // copy() 函数定义在 algorithm 头文件中。 template \u0026lt;typename InputIt, typename OutputIt\u0026gt; OutputIt copy(InputIt first, InputIt last, OutputIt dest) { while (first != last) { *dest++ = *first++; } return dest; } ","date":"2023-07-31T09:43:37Z","permalink":"https://li54426.github.io/p/basic_2_%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/","title":"basic_2_容器使用"},{"content":" content {:toc} 三. 进阶_ 算法模板 1 数值处理 1.1 数值处理\u0026mdash;\u0026ndash;反转数字 1 2 3 4 5 6 7 8 for(int num : nums){ int re =0; while(num){ re = re*10 + num% 10; num/=10; } cout\u0026lt;\u0026lt; re\u0026lt;\u0026lt; endl; } 1.2 数值处理\u0026mdash;\u0026mdash;最大公因子 1 2 3 4 5 6 7 8 9 10 11 // 在algorithm中, 有__gcd()函数 int gcd(int a, int b){ // 默认 b 为较小的 int r; while (b) { r = a % b; a = b; b = r; } return a; } 位运算 位运算符（也称为按位运算符）是用来操作操作数的二进制位的。\n按位与（\u0026amp;）：将两个操作数的每一位进行比较，如果两个操作数在同一位上都是 1，则结果为 1，否则为 0。 按位或（|）：将两个操作数的每一位进行比较，如果两个操作数在同一位上都是 0，则结果为 0，否则为 1。 按位异或（^）：将两个操作数的每一位进行比较，如果两个操作数在同一位上相同，则结果为 0，否则为 1。 按位取反（~）：将操作数的每一位都取反（0 变成 1, 1 变成 0）。 左移（\u0026laquo;）：将左侧操作数的所有二进制位向左移动指定的位数，右侧的空位用 0 补充。 右移（\u0026raquo;）：将左侧操作数的所有二进制位向右移动指定的位数，左侧的空位用符号位（对于有符号类型）或 0（对于无符号类型）补充。 按位亦或\n一个数和 0 做 XOR 运算等于本身：a^0 = a 一个数和其本身做 XOR 运算等于 0：a^a = 0 XOR 运算满足交换律和结合律：a^b^a = (a^a)^b = 0^b = b 1.3 数值处理\u0026mdash;\u0026mdash;求幂 分为奇数和偶数\n1.4 数值处理\u0026mdash;\u0026mdash;求模运算 自然数取余定义分为两种：\n定义 1：如果 a 和 d 是两个自然数，d 非零，可以证明存在两个唯一的整数 q 和 r，满足 a=qd+r且0 ≤ r \u0026lt; d（其中 q 为商，r 为余数）。 定义 1 一般作为数学中的取余法则，即两个数取余，余数总是为正数。 1 2 3 4 5 6 7 8 9 10 11 12 13 // C++中 负数 % n 并不做处理 // 在 C++ 中，对于负数 a 和正整数 n 进行模运算（求余数），其结果的符号与被除数 a 的符号相同。具体地说，当 a \u0026lt;0 时，a % n 的结果为负数，当 a\u0026gt;= 0 时，a % n 的结果为非负数（即自然数） // 在 C++ 中，对于除数为负数的情况，取模运算结果未定义。因此，应该避免除数为负数的情况。 cout\u0026lt;\u0026lt; (-1) %3\u0026lt;\u0026lt;endl; // -1 // 两数相加再取模 (m + n) % p = (m%p + n%p) %p // 两数相乘再取模 (m * n) % p = (m%p) * (n%p) %p // 两数相减再取模 (m - n) % p = ((m%p - n%p) + p) %p 1.5 数值处理\u0026mdash;\u0026mdash;-模幂运算 1 2 // 先对 a^b % c // 其中, b是数组 例如[1,2] 代表 12 字符串数值处理 数位 dp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 找到所有 小于该数值的字符串表示 unordered_map\u0026lt;int, int\u0026gt; mp; function\u0026lt;int(int, bool )\u0026gt;func = [](int start, bool islimit)-\u0026gt; int{ // wrong case if(start == len)// base case // 当前的唯一状态表示, 要有 start等信息 int cur; if(!islimit \u0026amp;\u0026amp; mp.count(cur)){ return mp[cur]; } int up = islimit? s[start]-\u0026#39;0\u0026#39;: 9; int res = 0; for(int i = 0; i\u0026lt;= up; ++i){ // 只有当前位置有限制, 且等于 up 时, 才会 有限制 res += func(start, islimit \u0026amp;\u0026amp; i == up) } mp[cur] = res; return res; } 排序技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 添加元素所对应的坐标, 然后进行自己的排序 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; nums; for(int i = 0; i \u0026lt; m; i++) nums[i].push_back(i); sort(nums.begin(), nums.end(), cmp); // 两个 vector 排序 // 用来比较两个序列中从前往后逐个元素进行比较，直到出现不同为止。 // 如果全部元素都相等，则比较两个序列长度，长度较短的序列小于长度较长的序列。 vector\u0026lt;int\u0026gt; v1 = {1, 2, 3,}; vector\u0026lt;int\u0026gt; v2 = {1, 2, 3, 5}; // v1 \u0026lt;v2 // vector\u0026lt;pair\u0026lt;\u0026gt;\u0026gt; 排序 // 默认按照 pair::first的大小 2 回溯 = (先根)DFS + 剪枝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 res = [] # can是选择列表 def backtrack(res, track, can): if 满⾜结束条件: res.add(track) return # 时间复杂度O(n^n) for i in can: if(满足剪枝条件): #判断是否需要剪枝, 也就是将不符合题意的循环删除 continue #在递归之前做出选择，在递归之后撤销刚才的选择 track.push_back(i) backtrack(res, track, can) track.pop_back(i) BFS 重点在如何表示状态, 以及状态的转变 状态的组成必须唯一, 不能有状态是相同的 状态的组成必须完备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // encode the state typedef \u0026lt;\u0026gt; State queue\u0026lt;State\u0026gt; qu; // 防止走回头路, 可以使用 unordered_set / set/ vector / 数组 unordered_set\u0026lt;State\u0026gt; visit; qu.push(start); visit.insert(start); int step = 0; while(qu.size()){ int len = qu.size(); for(int i =0; i\u0026lt;len; ++i){ State cur = qu.front(); qu.pop(); // 处理, 进行每一步的操作 if(finished){ return step; } // k 是一共有多少种下一步的操作 for(int j =0; j\u0026lt;k; ++j){ State next ; qu.push(next); visit.insert(next); } } step++; } 3 单调栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // ------------------从后向前计算------------------ // 找到该元素 右边 第一个 比自己大的元素 len = nums.size(); vector\u0026lt;int\u0026gt; ans(len, -1); stack\u0026lt;int\u0026gt; st; //从后向前遍历, 小(等于) 当前元素的出去 for(int i =len - 1; i\u0026gt; -1; --i){ while(!st.empty() \u0026amp;\u0026amp; nums[i] \u0026gt;= st.top()){ st.pop(); } ans[i] = !st.empty()? st.top() : -1; st.push(nums[i]); } // -------------------从前往后计算----------------- // 找到该元素 右边 第一个 比自己大的元素 stack\u0026lt;int\u0026gt; st; // 递增栈(从栈头到栈底的顺序) vector\u0026lt;int\u0026gt; result(nums.size(), 0); for (int i = 0; i \u0026lt; nums.size(); i++) { while (st.size() \u0026amp;\u0026amp; nums[i] \u0026gt; nums[st.top()]) { // 注意栈不能为空 // 当前元素 是 已遍历元素的 解 result[st.top()] = i; st.pop(); } st.push(i); } 双指针 滑动窗口的右端点一定会到达答案的右端点，这时候左端点就会收缩到答案的左端点了\n图论 4.1 图的遍历( 使用邻接矩阵 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 图遍历框架 // 图的遍历和一般 回溯 框架还是有所不同的, 因为传到traverse 函数中的点还没有进行过遍历, 所以衍生出了两种方法: // - 丢进函数之前 对其进行处理 // - 在for循环之前进行处理, for循环中不进行处理( 更一般 ) void traverse(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;graph, int s) { if (visited[s]) return; // 经过节点 s visited[s] = true; for (TreeNode neighbor : graph.neighbors(s)) traverse(neighbor); // 离开节点 s visited[s] = false; } 图遍历过程中, 有些节点被访问了两次( 遍历时, visit[i] == 1 )的情况:\n图中有环 某节点 的 入度 大于等于 2 要 注意 区分这两种情况\n4.2 二分图 定义\n二分图的顶点集可分割为两个互不相交的子集，图中每条边依附的两个顶点都分属于这两个子集，且两个子集内的顶点不相邻。\n二分图不是 \u0026ldquo;回溯\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //遍历一遍图，并且一边遍历一遍染色，看看能不能用两种颜色给所有节点染色，且相邻节点的颜色都 不相同。 bool isBipartite(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph) { // the number of nodes int len = graph.size(); vector\u0026lt;int\u0026gt; visit(len, 0); vector\u0026lt;int\u0026gt; color(len, 0); int res = 1; // 防止有单独的子图 for(int i=0; i\u0026lt;len; ++i){ if(visit[i] == 0) //深度遍历, 进行染色, start染c, 与start相连的点染 -c dfs(graph, i, visit, color, res, 1); } return res; } void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;g, int start, vector\u0026lt;int\u0026gt; \u0026amp;visit, vector\u0026lt;int\u0026gt; \u0026amp;color, int \u0026amp;res , int c){ if(!res) return; // if(visit[v] == 1) return; // 没有遍历过(染色) if(visit[start] == 0){ visit[start] = 1; color[start] = c; cout\u0026lt;\u0026lt; \u0026#34;node \u0026#34;\u0026lt;\u0026lt; start\u0026lt;\u0026lt; \u0026#34;=\\t \u0026#34;\u0026lt;\u0026lt; c\u0026lt;\u0026lt; endl; for(int nextnode : g[start]){ dfs(g, nextnode, visit, color, res, -c); } } else if(color[start] == c) return; else { res = 0; //cout\u0026lt;\u0026lt; \u0026#34;node\u0026#34;\u0026lt;\u0026lt; start\u0026lt;\u0026lt; \u0026#34;\\t is unsuccessful\u0026#34;\u0026lt;\u0026lt; endl; } } 4.3 判断是否有环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 bool hascycle(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; g) { // 检测是不是拓扑序列 也就是 检查 是否有环 // 使用回溯法, 如果访问的节点在path中, 那么就是有环 // 为什么不使用 visited, 因为visited是全局的, int len = g.size(); int res = 1; vector\u0026lt;int\u0026gt; visited(n, 0), path(n, 0); for(int i = 0; i\u0026lt;n; ++i){ dfs(res, g, visited, path, i); if(!res) return false; } return true; } void dfs(int \u0026amp;res, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;g, vector\u0026lt;int\u0026gt; \u0026amp;visited, vector\u0026lt;int\u0026gt; path, int start){ if(!res) return; // [----------------------bug is here--------------------] // 注意这两者的顺序, 先判断是否 在路径上, 因为在路径上一定浏览过, if(path[start] ==1 ) res = 0; if(visited[start]) return; path[start] =1; visited[start] = 1; for(int next : g[start]){ dfs(res, g, visited, path, next); } path[start] = 0; } 4.4 拓扑排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 vector\u0026lt;int\u0026gt; findOrder(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g ) { // 返回 拓扑排序 // 结论 将后序遍历的结果进⾏反转（逆后序遍历顺序），就是拓扑排序的结果。 int len = g.size(); // 假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 u 入栈 vector\u0026lt;int\u0026gt; res, trace, path(numCourses, 0), visited(numCourses, 0); int flag = 1; for(int i =0; i\u0026lt; numCourses; ++i){ // start 是要处理的点 // cout\u0026lt;\u0026lt; start\u0026lt;\u0026lt; if(!visited[i]) dfs(flag, trace, g, visited, path, i); if(!flag) return {}; } // 最后反转一下 reverse(trace.begin(), trace.end()); return trace; } void dfs(int \u0026amp;flag, vector\u0026lt;int\u0026gt; \u0026amp;trace, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;g, vector\u0026lt;int\u0026gt; \u0026amp;visited, vector\u0026lt;int\u0026gt; \u0026amp;path, int start){ if(!flag) {return;} if(path[start]) { flag = 0; return; } if(visited[start]) return; path[start]=1; visited[start] = 1; for(int next: g[start]){ dfs(flag, trace, g, visited, path, next); } // 到了尽头才添加, 后序遍历 trace.push_back(start); path[start] =0; } 5.1 双指针\u0026mdash;\u0026mdash;二分查找 1 2 3 4 5 6 7 8 9 10 11 int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left =0, right = nums.size()-1; while(left \u0026lt;= right){ int mid = left+ (right - left )/2; // 相等的时候向左收缩边界, 也就是修改 r if(nums[mid] \u0026gt;= target) right=mid-1; else if(nums[mid] \u0026lt; target) left =mid+1; } return left; } 5 双指针\u0026mdash;\u0026mdash;滑动窗口 O(n) 时间内解决 子串, 子数组问题\n窗口其实就是 [left, right), 窗口大小是 right - left right 向右寻找可行解，left 向右寻找最优解 right 表示待处理的节点 等价于枚举左端点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #-----------------V1---------------- while right \u0026lt; s.size(): # 处理s[right] ++right; while( shirink \u0026amp;\u0026amp; l\u0026lt;r ): # 满足 题目 条件的在这里更新 updata res # 处理left ++left #-----------------V2---------------- while right \u0026lt; s.size(): # 处理s[right] ++right; while(!shirink \u0026amp;\u0026amp; l\u0026lt;r ): # 处理left ++left #不满足条件的在这里更新 updata res 高级数据结构 前缀和 与 差分 我们可以通过如下方式构造其前缀和数组 s：s[1] = a[1]，s[i] = s[i-1] + a[i] (2 ≤ i ≤ n)\n我们可以通过如下方式构造其差分数组 d：d[1] = a[1]，d[i] = a[i] - a[i-1] (2 ≤ i ≤ n),\n原始数组a[i]= $\\sum(d_i)$, 所以差分是前缀和的逆运算\n如果想对原数组[l, r]内的元素加 c, 只需要对差分数组以下操作\nd[l]+=c 以及d[r+1] -= c 开辟数组的时候, 要多开辟一位 ","date":"2023-07-31T09:43:04Z","permalink":"https://li54426.github.io/p/basic_3_%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","title":"basic_3_算法模板"},{"content":" content {:toc} 字符串相关的算法题目\nleetCode 344 反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n示例 1：\n输入：s = [\u0026ldquo;h\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;o\u0026rdquo;] 输出：[\u0026ldquo;o\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;h\u0026rdquo;] 示例 2：\n输入：s = [\u0026ldquo;H\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;h\u0026rdquo;] 输出：[\u0026ldquo;h\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;H\u0026rdquo;]\n提示：\n1 \u0026lt;= s.length \u0026lt;= 10^5 s[i] 都是 ASCII 码表中的可打印字符\n思路 遍历一半的长度，并前后互换位置\n解法 1 2 3 4 5 6 7 8 9 /** * @param {character[]} s * @return {void} Do not return anything, modify s in-place instead. */ var reverseString = function(s) { for (let i = 0; i \u0026lt; s.length / 2; i++) { [s[i], s[s.length - 1 - i]] = [s[s.length - 1 - i], s[i]] } }; 1 2 3 4 Accepted 477/477 cases passed (88 ms) Your runtime beats 62.86 % of javascript submissions Your memory usage beats 99.2 % of javascript submissions (47.5 MB) leetCode 541 反转字符串 II 思路 将字符串拆分为数组，分组，各项反转，再重新组合。\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * @param {string} s * @param {number} k * @return {string} */ var reverseStr = function (s, k) { const arr = s.split(\u0026#39;\u0026#39;) let count = 0 // 数组分组 const arrRes = [] for (let i = 0; i \u0026lt; arr.length; i += k) { const temp = [] for (let j = i; j \u0026lt; k + i; j++) { if (s[j]) { if (count % 2 === 0) { temp.unshift(s[j]) // 反向存入 } else { temp.push(s[j]) } } } count++ arrRes.push(...temp) } // 还原字符串 return arrRes.join(\u0026#39;\u0026#39;) } 1 2 3 4 Accepted 60/60 cases passed (72 ms) Your runtime beats 29.7 % of javascript submissions Your memory usage beats 5.05 % of javascript submissions (47.7 MB) 剑指Offer 05 替换空格 请实现一个函数，把字符串 s 中的每个空格替换成\u0026quot;%20\u0026quot;。\n示例 1：\n输入：s = \u0026ldquo;We are happy.\u0026rdquo; 输出：\u0026ldquo;We%20are%20happy.\u0026rdquo;\n限制：\n0 \u0026lt;= s 的长度 \u0026lt;= 10000\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * @param {string} s * @return {string} */ var replaceSpace = function(s) { const arr = s.split(\u0026#39;\u0026#39;) for(let i = 0; i \u0026lt; arr.length; i++) { if(arr[i] === \u0026#39; \u0026#39;) { arr[i] = \u0026#39;%20\u0026#39; } } return arr.join(\u0026#39;\u0026#39;) }; 1 2 3 4 5 6 执行用时： 64 ms, 在所有 JavaScript 提交中击败了33.48%的用户 内存消耗： 40.7 MB, 在所有 JavaScript 提交中击败了91.35%的用户 通过测试用例： 27 / 27 leetCode 151 反转字符串中的单词 给你一个字符串 s ，请你反转字符串中 单词 的顺序。\n单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n示例 1：\n输入：s = \u0026ldquo;the sky is blue\u0026rdquo; 输出：\u0026ldquo;blue is sky the\u0026rdquo; 示例 2：\n输入：s = \u0026quot; hello world \u0026quot; 输出：\u0026ldquo;world hello\u0026rdquo; 解释：反转后的字符串中不能存在前导空格和尾随空格。 示例 3：\n输入：s = \u0026ldquo;a good example\u0026rdquo; 输出：\u0026ldquo;example good a\u0026rdquo; 解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n提示：\n1 \u0026lt;= s.length \u0026lt;= 104 s 包含英文大小写字母、数字和空格 \u0026rsquo; ' s 中 至少存在一个 单词\n解法 1 2 3 4 5 6 7 8 /** * @param {string} s * @return {string} */ var reverseWords = function(s) { const arr = s.trim().split(/[\u0026#39; \u0026#39;]+/) return arr.reverse().join(\u0026#39; \u0026#39;) }; 1 2 3 4 Accepted 58/58 cases passed (60 ms) Your runtime beats 84.18 % of javascript submissions Your memory usage beats 92.99 % of javascript submissions (42.8 MB) 剑指Offer58-II.左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\u0026quot;abcdefg\u0026quot;和数字2，该函数将返回左旋转两位得到的结果\u0026quot;cdefgab\u0026quot;。\n示例 1：\n输入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 输出: \u0026ldquo;cdefgab\u0026rdquo; 示例 2：\n输入: s = \u0026ldquo;lrloseumgh\u0026rdquo;, k = 6 输出: \u0026ldquo;umghlrlose\u0026rdquo;\n限制：\n1 \u0026lt;= k \u0026lt; s.length \u0026lt;= 10000\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解法 1 2 3 4 5 6 7 8 9 /** * @param {string} s * @param {number} n * @return {string} */ var reverseLeftWords = function(s, n) { const left = s.substring(0, n) return s.substring(n, s.length) + left }; 1 2 3 4 5 6 执行用时： 64 ms, 在所有 JavaScript 提交中击败了60.49%的用户 内存消耗： 42.6 MB, 在所有 JavaScript 提交中击败了86.36%的用户 通过测试用例： 34 / 34 leetCode 459 重复的子字符串 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。\n示例 1:\n输入: s = \u0026ldquo;abab\u0026rdquo; 输出: true 解释: 可由子串 \u0026ldquo;ab\u0026rdquo; 重复两次构成。 示例 2:\n输入: s = \u0026ldquo;aba\u0026rdquo; 输出: false 示例 3:\n输入: s = \u0026ldquo;abcabcabcabc\u0026rdquo; 输出: true 解释: 可由子串 \u0026ldquo;abc\u0026rdquo; 重复四次构成。 (或子串 \u0026ldquo;abcabc\u0026rdquo; 重复两次构成。)\n提示：\n1 \u0026lt;= s.length \u0026lt;= 104 s 由小写英文字母组成\n思路 我们将两个 ss 连在一起，并移除第一个和最后一个字符。如果 ss 是该字符串的子串，那么 ss 就满足题目要求\n需要先进行较为复杂的数学证明\n解法 1 2 3 4 5 6 7 8 /** * @param {string} s * @return {boolean} */ var repeatedSubstringPattern = function(s) { const double = (s + s).substring(1, s.length * 2 - 1) return double.indexOf(s) !== -1 }; 1 2 3 4 Accepted 129/129 cases passed (64 ms) Your runtime beats 86.86 % of javascript submissions Your memory usage beats 82.62 % of javascript submissions (43.4 MB) ","date":"2023-07-30T22:09:51Z","permalink":"https://li54426.github.io/p/%E4%B8%80%E4%BA%9B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%97%AE%E9%A2%98/","title":"一些字符串的问题"},{"content":" content {:toc} 数组是存放在连续内存空间上的相同类型数据的集合。需要两点注意的是\n数组下标都是从 0 开始的 数组内存空间的地址是连续的 正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。数组的元素是不能删的，只能覆盖。\n二分查找 leetCode 704 二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:\n1 2 3 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2:\n1 2 3 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 思路 最简单的方案，一行代码搞定\n1 2 3 var search = function (nums, target) { return nums.indexOf(target) } 1 2 3 4 Accepted 47/47 cases passed (64 ms) Your runtime beats 63.35 % of javascript submissions Your memory usage beats 54.75 % of javascript submissions (43.9 MB) 但我们还是学习一下二分查找的思路。\n注意这道题目的前提是数组是有序数组，这也是使用二分查找的基础条件。\n定义一个区间 [left, right]，其中 right 为数组的最后一项下标 判断如果 left \u0026lt;= right 时，获取一次 left 到 right 的中间值 middle，这里要注意 middle 要使用 Math.floor 取整数。 判断如果下标为 middle 的数值 \u0026lt; target，则 target 在 middle 的右边，将 left 赋值为 middle + 1 判断如果下标为 middle 的数值 \u0026gt; target，则 target 在 middle 的左边，将 right 赋值为 middle - 1 否则如果 middle === target，直接返回 middle 循环 2-5 步骤 否则返回 -1 解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * @param {number[]} nums * @param {number} target * @return {number} */ var search = function (nums, target) { let left = 0 let right = nums.length - 1 while (left \u0026lt;= right) { const middle = Math.floor((left + right) / 2) if (nums[middle] \u0026gt; target) { right = middle - 1 } else if (nums[middle] \u0026lt; target) { left = middle + 1 } else { return middle } } return -1 } 1 2 3 4 Accepted 47/47 cases passed (56 ms) Your runtime beats 92.97 % of javascript submissions Your memory usage beats 89.92 % of javascript submissions (43.8 MB) 举一反三\nleetCode 35 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。\n示例 1:\n输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2:\n输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3:\n输入: nums = [1,3,5,6], target = 7 输出: 4\n提示:\n1 \u0026lt;= nums.length \u0026lt;= 10e4 -10e4 \u0026lt;= nums[i] \u0026lt;= 10e4 nums 为 无重复元素 的 升序 排列数组 -10e4 \u0026lt;= target \u0026lt;= 10e4 思路 注意这道题目的前提是数组是有序数组，可以考虑使用二分法。\n二分法使用完成后，要注意这 4 种情况\n目标值在数组所有元素之前 目标值等于数组中某一个元素 目标值插入数组中的位置 目标值在数组所有元素之后的情况 其中 目标值等于数组中某一个元素 和上一题完全相同\n我们只需要考虑另外 3 种情况\n目标值在数组所有元素之前，循环跑完后，left 为 0，right 为 -1 目标值插入数组中的位置，循环跑完后，left 为 mid + 1，right 为 mid 目标值在数组所有元素之后的情况，循环跑完后，left 为 nums.length，right 为 nums.length - 1 所以 return right + 1\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * @param {number[]} nums * @param {number} target * @return {number} */ var searchInsert = function (nums, target) { // 定义开闭区间 [left, right] let left = 0 let right = nums.length - 1 let mid = 0 while (left \u0026lt;= right) { // 定义二分中间值 mid = Math.floor(left + (right - left) / 2) if (target \u0026lt; nums[mid]) { right = mid - 1 } else if (target \u0026gt; nums[mid]) { left = mid + 1 } else { return mid } } return right + 1 } 1 2 3 4 Accepted 64/64 cases passed (60 ms) Your runtime beats 67.55 % of javascript submissions Your memory usage beats 36.2 % of javascript submissions (41.2 MB) leetCode 34 在排序数组中查找元素的第一个和最后一个位置 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n示例 1：\n输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2：\n输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3：\n输入：nums = [], target = 0 输出：[-1,-1]\n提示：\n0 \u0026lt;= nums.length \u0026lt;= 10e5 -10e9 \u0026lt;= nums[i] \u0026lt;= 10e9 nums 是一个非递减数组 -10e9 \u0026lt;= target \u0026lt;= 10e9 思路 首先使用二分法得到 target 的位置 寻找 target 左右两边是否有相等的值 解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var searchRange = function (nums, target) { // 二分法 let left = 0 let right = nums.length - 1 while (left \u0026lt;= right) { const middle = Math.floor(left + (right - left) / 2) if (target \u0026gt; nums[middle]) { left = middle + 1 } else if (target \u0026lt; nums[middle]) { right = middle - 1 } else { // 最后再寻找左右边界 let leftMove = 1 while (nums[middle] === nums[middle - leftMove]) { leftMove++ } let rightMove = 1 while (nums[middle] === nums[middle + rightMove]) { rightMove++ } return [middle - leftMove + 1, middle + rightMove - 1] } } return [-1, -1] } 1 2 3 4 Accepted 88/88 cases passed (48 ms) Your runtime beats 98.98 % of javascript submissions Your memory usage beats 79.4 % of javascript submissions (41.5 MB) leetCode 69 x 的平方根 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例 1：\n输入：x = 4 输出：2 示例 2：\n输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842\u0026hellip;, 由于返回类型是整数，小数部分将被舍去。\n提示：\n0 \u0026lt;= x \u0026lt;= 2^31 - 1\n思路 我们知道大于1的数字的平方根大于这个数的一半，所以我们在定义二分法区间的时候将 right 定义为 x / 2，当然这里定义为 x 也是可以的，仅仅多一次循环而已\n每次循环取 left 到 right 的中间值 mid，计算出 mid 的平方\n如果 mid 的平方 大于 x，则 mid 过大，可以将边界 right 赋值为 mid - 1\n如果 mid 的平方 小于 x，则 mid 过小，可以将边界 left 赋值为 mid + 1\n最后返回 left - 1 的值，因为如果没有完全平方的话，最后一次循环会将 left + 1 再退出 while，所以这里 - 1\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * @param {number} x * @return {number} */ var mySqrt = function (x) { if (x === 1) { return 1 } let left = 0 // 大于1的数字的平方根大于这个数的一半 // 所以我们在定义二分法区间的时候将 right 定义为 x / 2 // 当然这里定义为 x 也是可以的，仅仅多一次循环而已 let right = x / 2 while (left \u0026lt;= right) { const mid = Math.floor(left + (right - left) / 2) const r = mid * mid if (r \u0026gt; x) { // 过大 right = mid - 1 } else if (r \u0026lt; x) { // 过小 left = mid + 1 } else { return mid } } return left - 1 } 1 2 3 4 Accepted 1017/1017 cases passed (64 ms) Your runtime beats 89.63 % of javascript submissions Your memory usage beats 29.38 % of javascript submissions (42.6 MB) leetCode 367 有效的完全平方数 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。\n进阶：不要 使用任何内置的库函数，如 sqrt 。\n示例 1：\n输入：num = 16 输出：true 示例 2：\n输入：num = 14 输出：false\n提示：\n1 \u0026lt;= num \u0026lt;= 2^31 - 1\n思路 做过上一题，这一题就简单多了，直接二分法。\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * @param {number} num * @return {boolean} */ var isPerfectSquare = function (num) { if (num === 1) { return true } let left = 0 let right = num / 2 while (left \u0026lt;= right) { const mid = Math.floor(left + (right - left) / 2) const r = mid * mid if (r \u0026gt; num) { right = mid - 1 } else if (r \u0026lt; num) { left = mid + 1 } else { return true } } return false } 1 2 3 4 Accepted 70/70 cases passed (56 ms) Your runtime beats 84.94 % of javascript submissions Your memory usage beats 69.41 % of javascript submissions (40.8 MB) 移除元素（双指针法） leetCode 27 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n1 2 3 4 5 6 7 8 // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例 1：\n1 2 3 输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2：\n1 2 3 输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示：\n0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100\n思路 数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。\n双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // @lc code=start /** * @param {number[]} nums * @param {number} val * @return {number} */ var removeElement = function(nums, val) { let slow = 0 // 慢指针 for (let fast = 0; fast \u0026lt; nums.length; fast++) { // 快指针遍历 if (nums[fast] !== val) { // 非移除元素 nums[slow] = nums[fast] // 赋值给慢指针的索引值 slow++ // 慢指针右移 } } return slow // 返回慢指针，移除元素后的数组长度 }; 1 2 3 4 Accepted 113/113 cases passed (60 ms) Your runtime beats 71.31 % of javascript submissions Your memory usage beats 86.34 % of javascript submissions (41 MB) leetCode 283 移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\n输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 示例 2:\n输入: nums = [0] 输出: [0]\n提示:\n1 \u0026lt;= nums.length \u0026lt;= 10^4 -2^31 \u0026lt;= nums[i] \u0026lt;= 2^31 - 1\n思路 方法一，使用快慢指针，快指针遇到非0元素时，将元素的值赋给慢指针，慢指针 + 1，最后再对末尾的0进行操作\n方法二，使用快慢指针，快指针遇到非0元素时，直接进行交换，慢指针 + 1，这样就将0直接交换到了最后，一次循环搞定\n解法 方法一\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var moveZeroes = function (nums) { let slow = 0 for (let fast = 0; fast \u0026lt; nums.length; fast++) { if (nums[fast] !== 0) { nums[slow] = nums[fast] slow++ } } for (let i = slow; i \u0026lt; nums.length; i++) { nums[i] = 0 } } 1 2 3 4 Accepted 74/74 cases passed (72 ms) Your runtime beats 98.08 % of javascript submissions Your memory usage beats 59.63 % of javascript submissions (45.8 MB) 方法二\n也可以优化为，直接交换元素，这里用了 es2015 里的解构语法\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var moveZeroes = function (nums) { let slow = 0 for (let fast = 0; fast \u0026lt; nums.length; fast++) { if (nums[fast] !== 0) { [nums[fast], nums[slow]] = [nums[slow], nums[fast]] slow++ } } } 1 2 3 4 Accepted 74/74 cases passed (64 ms) Your runtime beats 99.88 % of javascript submissions Your memory usage beats 38.6 % of javascript submissions (45.9 MB) leetCode 844 比较含退格的字符串 给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n注意：如果对空文本输入退格字符，文本继续为空。\n示例 1：\n输入：s = \u0026ldquo;ab#c\u0026rdquo;, t = \u0026ldquo;ad#c\u0026rdquo; 输出：true 解释：s 和 t 都会变成 \u0026ldquo;ac\u0026rdquo;。 示例 2：\n输入：s = \u0026ldquo;ab##\u0026rdquo;, t = \u0026ldquo;c#d#\u0026rdquo; 输出：true 解释：s 和 t 都会变成 \u0026ldquo;\u0026quot;。 示例 3：\n输入：s = \u0026ldquo;a#c\u0026rdquo;, t = \u0026ldquo;b\u0026rdquo; 输出：false 解释：s 会变成 \u0026ldquo;c\u0026rdquo;，但 t 仍然是 \u0026ldquo;b\u0026rdquo;。\n提示：\n1 \u0026lt;= s.length, t.length \u0026lt;= 200 s 和 t 只含有小写字母以及字符 \u0026lsquo;#\u0026rsquo;\n思路 使用双指针，快指针遍历，慢指针生成最后的数组。\n快指针遇到退格符号后，慢指针回退一次\n需要注意不能直接操作字符串，需要将字符串先 split 为数组后操作\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * @param {string} s * @param {string} t * @return {boolean} */ var backspaceCompare = function (s, t) { if (processStr(s) === processStr(t)) { return true } return false } function processStr(str) { const strArr = str.split(\u0026#39;\u0026#39;) let slow = 0 for (let fast = 0; fast \u0026lt; strArr.length; fast++) { if (strArr[fast] !== \u0026#39;#\u0026#39;) { strArr[slow] = strArr[fast] slow++ } else { if (slow !== 0) { slow-- } } } return strArr.slice(0, slow).join(\u0026#39;\u0026#39;) } 1 2 3 4 Accepted 114/114 cases passed (60 ms) Your runtime beats 80.48 % of javascript submissions Your memory usage beats 86.45 % of javascript submissions (41.2 MB) leetCode 977 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1：\n输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] 示例 2：\n输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^4 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 nums 已按 非递减顺序 排序\n思路 取原数组两端，作为2个指针\n使用 while 判断 left \u0026lt;= right 时\n对比 left 和 right 大小，取大数的平方，存入一个新数组\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * @param {number[]} nums * @return {number[]} */ var sortedSquares = function(nums) { // 高级 api // return nums.map((item) =\u0026gt; item * item).sort((a, b) =\u0026gt; a - b) // 双指针 let left = 0 let right = nums.length - 1 const result = [] while (left \u0026lt;= right) { if (Math.abs(nums[left]) \u0026lt; Math.abs(nums[right])) { result.unshift(nums[right] * nums[right]) right-- } else { result.unshift(nums[left] * nums[left]) left++ } } return result }; 1 2 3 4 Accepted 137/137 cases passed (152 ms) Your runtime beats 15.69 % of javascript submissions Your memory usage beats 35.91 % of javascript submissions (47.5 MB) 滑动区间（双指针） leetCode 209 长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, \u0026hellip;, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n示例 1：\n输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2：\n输入：target = 4, nums = [1,4,4] 输出：1 示例 3：\n输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0\n提示：\n1 \u0026lt;= target \u0026lt;= 10^9 1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^5\n思路 使用双指针，滑动窗口的思路\n快指针正常遍历 累加快指针的值 判断累加值是否大于等于 target，获取子串的长度 累加值减去慢指针的值 慢指针 + 1 循环 3-5 循环 1-6 解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * @param {number} target * @param {number[]} nums * @return {number} */ var minSubArrayLen = function (target, nums) { // 双指针滑动区间 let slow = 0 // 滑动窗口的起始位置 let sum = 0 // 滑动窗口数值之和 let subLength = 0 // 滑动窗口的长度 let result = nums.length + 1 // 最终结果 for (let fast = 0; fast \u0026lt; nums.length; fast++) { // fast 为滑动窗口的终点位置 sum += nums[fast] while (sum \u0026gt;= target) { // 如果满足条件，寻找最小的子序列 subLength = fast - slow + 1 result = Math.min(result, subLength) sum -= nums[slow] slow += 1 } } return result === nums.length + 1 ? 0 : result } 1 2 3 4 Accepted 20/20 cases passed (68 ms) Your runtime beats 64.23 % of javascript submissions Your memory usage beats 77.99 % of javascript submissions (45.1 MB) leetCode 904 水果成篮 你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例 1：\n输入：fruits = [1,2,1] 输出：3 解释：可以采摘全部 3 棵树。 示例 2：\n输入：fruits = [0,1,2,2] 输出：3 解释：可以采摘 [1,2,2] 这三棵树。 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3：\n输入：fruits = [1,2,3,2,2] 输出：4 解释：可以采摘 [2,3,2,2] 这四棵树。 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4：\n输入：fruits = [3,3,3,1,2,1,1,2,3,3,4] 输出：5 解释：可以采摘 [1,2,1,1,2] 这五棵树。\n提示：\n1 \u0026lt;= fruits.length \u0026lt;= 10^5 0 \u0026lt;= fruits[i] \u0026lt; fruits.length\n思路 我们可以使用滑动窗口解决本题，left 和 right 分别表示满足要求的窗口的左右边界，同时我们使用哈希表存储这个窗口内的数以及出现的次数。\n我们每次将 right 移动一个位置，并将 fruits[right] 加入哈希表。如果此时哈希表不满足要求（即哈希表中出现超过两个键值对），那么我们需要不断移动 left，并将 fruits[left] 从哈希表中移除，直到哈希表满足要求为止。\n需要注意的是，将 fruits[left] 从哈希表中移除的时候，如果 fruits[left] 在哈希表中的出现次数减少为 0，需要将对应的键值对从哈希表中移除。\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * @param {number[]} fruits * @return {number} */ var totalFruit = function(fruits) { // 我们可以使用滑动窗口解决本题，left 和 right 分别表示满足要求的窗口的左右边界，同时我们使用哈希表存储这个窗口内的数以及出现的次数。 // 我们每次将 right 移动一个位置，并将 fruits[right] 加入哈希表。如果此时哈希表不满足要求（即哈希表中出现超过两个键值对），那么我们需要不断移动 left，并将 fruits[left] 从哈希表中移除，直到哈希表满足要求为止。 // 需要注意的是，将 fruits[left] 从哈希表中移除的时候，如果 fruits[left] 在哈希表中的出现次数减少为 0，需要将对应的键值对从哈希表中移除。 let res = 0 let left = 0 const cateObj = {} for (let right = 0; right \u0026lt; fruits.length; right++) { cateObj[fruits[right]] = (cateObj[fruits[right]] || 0) + 1 while (Object.keys(cateObj).length \u0026gt; 2) { cateObj[fruits[left]] -= 1 if (cateObj[fruits[left]] === 0) { delete cateObj[fruits[left]] } left++ } res = Math.max(res, right - left + 1) } return res }; 1 2 3 4 Accepted 91/91 cases passed (396 ms) Your runtime beats 8.35 % of javascript submissions Your memory usage beats 5.85 % of javascript submissions (56.7 MB) 螺旋矩阵 leetCode 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n示例 1：\n输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2：\n输入：n = 1 输出：[[1]]\n提示：\n1 \u0026lt;= n \u0026lt;= 20\n思路 最外层用 while 进行圈数循环，然后沿着各个边进行循环，填写相应的值\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /** * @param {number} n * @return {number[][]} */ var generateMatrix = function (n) { let loop = 0 let startX = 0 let startY = 0 let offset = 1 let count = 1 let i = 0 let j = 0 // 初始化二位数组 const res = [] for (let i = 0; i \u0026lt; n; i++) { const temp = [] for (let j = 0; j \u0026lt; n; j++) { temp.push(0) } res.push(temp) } // 旋转的圈数 while (loop \u0026lt; n / 2) { // 四条边进行循环 for (j = startY; j \u0026lt; n - offset; j += 1) { res[startX][j] = count count += 1 } for (i = startX; i \u0026lt; n - offset; i += 1) { res[i][j] = count count += 1 } for (; j \u0026gt; startY; j -= 1) { res[i][j] = count count += 1 } for (; i \u0026gt; startX; i -= 1) { res[i][j] = count count += 1 } startX += 1 startY += 1 offset += 1 loop += 1 } // 奇数有个中心值 if (n % 2 === 1) { res[i][j] = count } return res } 1 2 3 4 Accepted 20/20 cases passed (52 ms) Your runtime beats 95.38 % of javascript submissions Your memory usage beats 89.85 % of javascript submissions (41 MB) ","date":"2023-07-30T22:08:29Z","permalink":"https://li54426.github.io/p/%E7%BB%8F%E5%85%B8%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E9%A2%98%E7%9B%AE/","title":"经典的数组的题目"},{"content":" content {:toc} 滑动窗口 O(n) 时间内解决 子串, 子数组问题\nright 表示待处理的节点 窗口其实就是 [left, right), 窗口大小是 left- right right 向右寻找可行解，left 向右寻找最优解 等价于枚举左端点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #-----------------V1---------------- while right \u0026lt; s.size(): # 处理s[right] ++right; while( shirink \u0026amp;\u0026amp; l\u0026lt;r ): # 满足 题目 条件的在这里更新 updata res # 处理left ++left #-----------------V2---------------- while right \u0026lt; s.size(): # 处理s[right] ++right; while(!shirink \u0026amp;\u0026amp; l\u0026lt;r ): # 处理left ++left #不满足条件的在这里更新 updata res 满足不满足条件的意思是:\n随着 r++, 你所想要的目标(求和, 求积) 是怎么进行变化, 是向着你想要的目标走还是怎样 满足题目条件\u0026mdash;循环内更新 209. 长度最小的子数组\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。如果不存在符合条件的子数组，返回 0 。\n1 2 3 输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int minSubArrayLen(int target, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(); int l =0, r=0; int sum = 0; int minlen = INT_MAX; while(r\u0026lt; len){ sum+= nums[r++]; while(sum \u0026gt;= target){ minlen = min(minlen, r-l); sum -= nums[l++]; } } return minlen == INT_MAX ? 0: minlen; } 在本题中, 随着 r++, 目标和越来越大, 是向着你想要的目标走, 因此用的是 V1, 在循环内更新 结果 不满足题目条件\u0026mdash;循环外更新 713. 乘积小于 K 的子数组\n给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。\n1 2 3 4 输入：nums = [10,5,2,6], k = 100 输出：8 解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。 需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int numSubarrayProductLessThanK(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // 返回子数组的数目 int res = 0; int l =0, r= 0; int sum =1; int len = nums.size(); while(r\u0026lt;len){ sum *= nums[r]; ++r; while(sum \u0026gt;= k \u0026amp;\u0026amp; l\u0026lt;r){ sum /= nums[l]; l++; } // [l, r) 内, 且右边断点为 r 的子数组共 (r-l)个 res += (r-l); } return res; } }; 在本题中, 随着 r++, 目标积 越来越大, 题目要求是要我们 小于 k , 因此用的是 V2, 在循环外更新 结果 3. 无重复字符的最长子串( DP )\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n1 2 3 输入: s = \u0026#34;abcabcbb\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // -----------------------------V2.0---------------------------------- int lengthOfLongestSubstring(string s) { unordered_map\u0026lt;char, int\u0026gt; mp; int l =0, r=0; int len = s.size(); int res = 1; // 处理特殊情况 if(!len) { return 0; } while(r\u0026lt;len){ char c = s[r]; r++; mp[c]++; while((r-l) \u0026gt; mp.size()){ c = s[l++]; mp[c]--; if(0==mp[c]){ mp.erase(c); } } res = max(res, r-l); } return res; } ","date":"2023-07-30T22:05:22Z","permalink":"https://li54426.github.io/p/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/","title":"滑动窗口算法"},{"content":" content {:toc} 1 映射的定义 ​\t两个非空集合A与B间存在着对应关系 f，而且对于A中的每一个元素 a，B中总有唯一的一个元素 b 与它对应，就这种对应为从 A 到 B 的映射，记作 f : A -\u0026gt; B。\n​\t其中，b称为元素a在映射f下的像，记作：b=f（a）。a称为b关于映射的原像。集合A中所有元泰的像的集合称为映射的值域，记作fA）。\n2 数组 数组在 物理实现 上是一块连续的存储空间\n但是在逻辑上 是一个映射 f 从 i -\u0026gt; nums[i], 只不过这个 i 的集合是有限制的, 每个元素都是实数\n3 折半( 二分 )查找 可以在 某些映射上进行 折半查找的条件 :\n数组有序 映射可以二分查找的条件:\n映射的函数是单调的 保证二分时, mid = (left + right)/2 有映射, ","date":"2023-07-30T22:05:22Z","permalink":"https://li54426.github.io/p/%E6%95%B0%E7%BB%84%E5%92%8C%E6%98%A0%E5%B0%84/","title":"数组和映射"},{"content":" content {:toc} 规范 1 2 3 4 5 \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;body\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;footer\u0026gt; type: 必填 commit 类型，有业内常用的字段，也可以根据需要自己定义 feat 增加新功能 fix 修复问题 / BUG style 代码风格相关无影响运行结果的 perf 优化 / 性能提升 refactor 重构 revert 撤销修改 test 测试相关 docs 文档 / 注释 chore 依赖更新 / 脚手架配置修改等 workflow 工作流改进 ci 持续集成 types 类型定义文件更改 wip 开发中 undef 不确定的分类 scope: commit 影响的范围，比如某某组件、某某页面 subject: 必填 简短的概述提交的代码，建议符合 50/72 formatting body: commit 具体修改内容，可以分为多行，建议符合 50/72 formatting footer: 其他备注，包括 breaking changes 和 issues 两部分 ","date":"2023-07-30T19:08:53Z","permalink":"https://li54426.github.io/p/commit-%E8%A7%84%E8%8C%83/","title":"commit 规范"},{"content":" content {:toc} 0 代码风格 C++ 风格指南 Cpplint 是一个 Python 脚本，作为一款开源免费的代码静态检测工具，Google 也使用它作为自己的 C++ 代码检测工具，也就是说，只要你想代码遵从 Google C++ 代码规范，那么 Cpplint 将会提供很好的代码静态检测支持。 1. 命名规则 文件名要全部小写, 可以包含下划线 (_) 或连字符 (-), 依照项目的约定. 如果没有约定, 那么“_”更好. 内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中. 类名称的每个单词首字母均大写, 不包含下划线: 形如MyExcitingClass, MyExcitingEnum. 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 常量 声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以“k”开头, 大小写混合.const int kDaysInAWeek = 7; 函数名的每个单词首字母大写 (即“驼峰变量名”或“帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 StartRpc() 而非 StartRPC()). 较好的起名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int price_count_reader; // 用于读取价格计数器 int num_errors; // 错误数量 int num_dns_connections; // DNS 连接数量 int count; // 计数器 int error_count; // 错误数量 int num_completed_connections; // 完成的连接数量 int web_gateway_connections; // Web 网关连接数量 int page_cache_reader; // 用于读取页面缓存 int customer_id; // 客户 ID // 类内变量名的规范 string table_name; // 好 - 用下划线. string tablename; // 好 - 全小写. string tableName; // 差 - 混合大小写 // 常量命名规范 const int kDaysInAWeek = 7; 2 注释风格 下面的规则描述了如何注释以及在哪儿注释\n三层的注释\n文件注释\n类注释\n函数注释\n变量注释/ 实现注释\n使用 // 或 /* */, 统一就好.\n文件注释描述了该文件的内容. 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释\n我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.\n1 2 3 4 5 6 7 8 9 ReturnType LongClassName::ReallyReallyReallyLongFunctionName( Type par_name1, // 4 space indent Type par_name2, Type par_name3) { DoSomething(); // 2 space indent ... } ","date":"2023-07-30T18:47:50Z","permalink":"https://li54426.github.io/p/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/","title":"代码风格"},{"content":" content {:toc} 0 需要的文件 问题文件 question.txt 题库文件 diction.xlsx 输出为查询结果.xlsx 1 读取查询列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ##########-读取查询列-######### # 文本预处理 filepath = \u0026#34;./auto/question.txt\u0026#34; with open(filepath, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: text = f.read() text_new = text.replace(\u0026#39;（\u0026#39;, \u0026#39;(\u0026#39;) text_new = text_new.replace(\u0026#39;）\u0026#39;, \u0026#39;)\u0026#39;) with open(filepath, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(text_new) # 打开txt文件并读取内容 with open(\u0026#34;./auto/question.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: content = file.read() # print(\u0026#34;contect=\u0026#34;, content) # 把题目导出来 pattern = r\u0026#39;(\\d+\\.+)(.+?)(?=(\\(|\\。|\\n|$))\u0026#39; matches = re.findall(pattern, content, flags=re.DOTALL) # [(\u0026#39;1. \u0026#39;, \u0026#39;质量流量计不能够直接测出的参数是（ ）\u0026#39;),.....] 2 读取题库 1 2 3 4 5 6 7 8 ######### 读取题库 ############## dic = [] # 读取单选题 df= pd.read_excel(\u0026#34;./auto/diction.xlsx\u0026#34;, sheet_name=\u0026#34;one\u0026#34;, usecols=[0,1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values #print(df) dic1= [(question, ans) for question, ans in value_array] dic.extend(dic1) 3 进行查题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ########### 进行查询 ############### res= [] num = 0 for match in matches: # 查询id, 查询题目 id = match[0] qu = match[1] # 题目过短, 自己进行处理 if(len(qu)\u0026lt;=5): res.append((id, \u0026#34;没有答案\u0026#34;)) continue flag = 0 # 开始从题库中查询 for allqu, ans in dic: if qu in allqu: res.append((id, ans)) flag =1 num+=1 break if(flag ==0): res.append((id, \u0026#34;没有答案\u0026#34;)) # print(\u0026#34;res=\u0026#34;, res) print(\u0026#34;共查询到\u0026#34;, num , \u0026#34;/\u0026#34;, len(res),\u0026#34;个结果\u0026#34;) # 输出为 execl, 一共两列 data = { \u0026#39;题号\u0026#39;: [item[0] for item in res], \u0026#39;答案\u0026#39;: [item[1] for item in res] } df=pd.DataFrame(data) df.to_excel(\u0026#34;./auto/查询结果.xlsx\u0026#34;,sheet_name=\u0026#34;Sheet1\u0026#34;, header=None, index=False) ############ 如果没有搜索到答案 ########### print(\u0026#34;下面请输入没有搜索到答案的问题\u0026#34;) for i in range(100): s = input(\u0026#34;请输入问题：(右键即黏贴)\\n\u0026#34;) for ques, ans in dic: if s in ques: print(ans,\u0026#34;\\n\\n\\n\u0026#34;) 4 总体代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 import re import pandas as pd ##########-读取查询列-######### # 文本预处理 filepath = \u0026#34;./auto/question.txt\u0026#34; with open(filepath, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: text = f.read() text_new = text.replace(\u0026#39;（\u0026#39;, \u0026#39;(\u0026#39;) text_new = text_new.replace(\u0026#39;）\u0026#39;, \u0026#39;)\u0026#39;) with open(filepath, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(text_new) # 打开txt文件并读取内容 with open(\u0026#34;./auto/question.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: content = file.read() # print(\u0026#34;contect=\u0026#34;, content) # 把题目导出来 pattern = r\u0026#39;(\\d+\\.+)(.+?)(?=(\\(|\\。|\\n|$))\u0026#39; matches = re.findall(pattern, content, flags=re.DOTALL) # [(\u0026#39;1. \u0026#39;, \u0026#39;质量流量计不能够直接测出的参数是（ ）\u0026#39;),.....] # print(\u0026#34;maches=\u0026#34;, matches) matches = [(ma[0], ma[1] ) for ma in matches] print(\u0026#34;maches=\u0026#34;, matches) # 将数据转换成 DataFrame 格式 # 将数据转换成 DataFrame 格式, 并修改列名为 \u0026#34;序号\u0026#34; 和 \u0026#34;答案\u0026#34; df = pd.DataFrame(matches, columns=[\u0026#39;序号\u0026#39;, \u0026#39;问题\u0026#39;]) # 使用 slice() 方法将 content 列的字符串长度截断为 20 df[\u0026#39;问题\u0026#39;] = df[\u0026#39;问题\u0026#39;]#.str.slice(20) # print(\u0026#34;df=\u0026#34;, df) # 将数据保存到 Excel 文件中 df.to_excel(\u0026#39;./auto/问题列表.xlsx\u0026#39;, index=False) ######### 读取题库 ############## dic = [] # 读取单选题 df= pd.read_excel(\u0026#34;./auto/diction.xlsx\u0026#34;, sheet_name=\u0026#34;one\u0026#34;, usecols=[0,1]) value_array = df[[\u0026#34;题目\u0026#34;, \u0026#34;答案\u0026#34;]].values #print(df) dic1= [(question, ans) for question, ans in value_array] dic.extend(dic1) # dic = [(\u0026#39;修改后的《安全生产法》由习近平主席于2014年签署第十三号令予以公布，自2014年（）起施行。\u0026#39;, \u0026#39;C\u0026#39;),(),,,,] # print(\u0026#34;\\n\\n\\ndic=\u0026#34;, dic) ########### 进行查询 ############### res= [] num = 0 for match in matches: # 查询id, 查询题目 id = match[0] qu = match[1] # 题目过短, 自己进行处理 if(len(qu)\u0026lt;=5): res.append((id, \u0026#34;没有答案\u0026#34;)) continue flag = 0 # 开始从题库中查询 for allqu, ans in dic: if qu in allqu: res.append((id, ans)) flag =1 num+=1 break if(flag ==0): res.append((id, \u0026#34;没有答案\u0026#34;)) # print(\u0026#34;res=\u0026#34;, res) print(\u0026#34;共查询到\u0026#34;, num , \u0026#34;/\u0026#34;, len(res),\u0026#34;个结果\u0026#34;) # 输出为 execl, 一共两列 data = { \u0026#39;题号\u0026#39;: [item[0] for item in res], \u0026#39;答案\u0026#39;: [item[1] for item in res] } df=pd.DataFrame(data) df.to_excel(\u0026#34;./auto/查询结果.xlsx\u0026#34;,sheet_name=\u0026#34;Sheet1\u0026#34;, header=None, index=False) ############ 如果没有搜索到答案 ########### print(\u0026#34;下面请输入没有搜索到答案的问题\u0026#34;) for i in range(100): s = input(\u0026#34;请输入问题：(右键即黏贴)\\n\u0026#34;) for ques, ans in dic: if s in ques: print(ans,\u0026#34;\\n\\n\\n\u0026#34;) ","date":"2023-07-30T17:55:31Z","permalink":"https://li54426.github.io/p/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9F%A5%E9%A2%98/","title":"自动化查题"},{"content":" content {:toc} Cmake cmake 教程 编写 CMakeLists.txt 文件。 创建一个 build 目录，用来存放 cmake 生成的文件。（这一步非必须） cd 进入 build 目录下，执行 cmake .. 命令，将 CMakeLists.txt 文件转化为 make 所需的 makefile 文件，其中路径 .. 表示 CMakeLists.txt 所在目录（路径可以根据自己 CMakeLists.txt 所在目录更改）。 在 build 目录下，执行 make 命令，生成目标可执行文件。（注意：make 命令要在 cmake 生成的 makefile 文件所在目录下执行， 我这里生成的 makefile 文件在 build 目录下。）\n1 2 3 4 # src 下 有 CMakeLists.txt # 需要进入 /src cmake src/.. make GDB gdb官方文档 GDB Documentation (sourceware.org)\ngdb 调试过程 要使用 g++ 和 GDB 进行调试，请按照以下步骤操作：\n编译代码：首先，使用 g++ 命令来编译你的代码，并添加 -g 选项以生成带有调试符号的可执行文件。例如：\n1 2 3 4 5 g++ -g your_code.cpp -o your_program // 如果是使用cmake, 在 makelists.txt 加上这两句话 set(CMAKE_BUILD_TYPE DEBUG) add_definitions(-g) 启动 GDB：在终端中输入 gdb 命令，然后在 GDB 提示符下启动你的程序，如下所示：\n1 gdb your_program 设置断点：在 GDB 中，你可以使用 break 命令设置断点。例如，要在主函数的第 10 行设置断点，可以键入：\n1 break main.cpp:10 运行程序：输入 run 命令来运行程序。当程序达到断点时，它会停止执行。\n1 run 执行调试命令：一旦程序停止在断点处，你可以使用各种 GDB 命令来检查变量的值、单步执行代码等。\n使用 next 命令（简写为 n）逐行执行代码，而不进入函数调用。 使用 step 命令（简写为 s）进入函数调用并逐行执行函数内部的代码。( 常用 ) 使用 print 命令（简写为 p）打印变量的值。 使用 continue 命令（简写为 c）继续执行程序直到下一个断点。 你还可以使用其他的 GDB 命令进行更高级的调试操作。\n退出 GDB：要退出 GDB，可以使用 quit 命令或按下 Ctrl + D。\n以上是使用 g++ 和 GDB 进行调试的基本步骤。你可以根据具体需求和调试情况来使用其他 GDB 命令。\n常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 r：run，执行程序 n：next，下一步，不进入函数 s：step，下一步，会进入函数 b：breakponit，设置断点 l：list，查看源码 c：continue，继续执行到下一断点 bt：backtrace，查看当前调用栈 p：print，打印查看变量 print (variable) q：quit，退出 GDB whatis：查看对象类型 info threads：查看线程 info breakpoints (info b)：查看所有的断点 info locals：查看局部变量 info args：查看函数的参数值及要返回的变量值 info frame：堆栈帧信息 (1) 查看可切换调试的线程：info threads (2) 切换调试的线程：thread 线程 id (3) 只运行当前线程：set scheduler-locking on (4) 运行全部的线程：set scheduler-locking off (5) 指定某线程执行某 gdb 命令：thread apply 线程 id gdb_cmd (6) 全部的线程执行某 gdb 命令：thread apply all gdb_cmd ","date":"2023-07-30T16:52:28Z","permalink":"https://li54426.github.io/p/cmake-gdb%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","title":"cmake \u0026\u0026 GDB的使用方法"},{"content":" content {:toc} 修改 从原作者项目地址进行 clone 原作者项目地址在这里 进行修改 上传 设置说明 修改_config.yml 的 links 为您的菜单 修改_config.yml 的 paginate 为您的按照多少页分页 修改自己的网图标\\style\\favicons\\favicon.ico 修改自己的网标志\\style\\favicons\\logo-liberxue.png 在_layouts\\blog.html中, 将 本文由 \u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;liberxue\u0026lt;/a\u0026gt; 创作 改为您的github名字 修改\\about.md中的内容, 它对应着文章中的关于这一页 在_layouts\\default.html中, 将 本文由 \u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;liberxue\u0026lt;/a\u0026gt; 创作 改为您的github名字 使用说明 打开\\_posts 文件夹是博客文章所在的位置，文件夹中的内容就是你的博客, 博客格式为 markdown 文件名格式为2015-06-11-xxxx.md, 不能有中文, 因为文件名会成为这篇博文的链接 当天的blog不会上传 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 layout: blog book: true title: \u0026#34;《美丽新世界》之幸福和自由思考\u0026#34; background: green background-image: http://ot1cc1u9t.bkt.clouddn.com/17-7-15/78939382.jpg date: 2017-07-03 23:13:54 category: 书籍 tags: - 美丽新世界 可选项目 // 设置颜色 background: green background: blue background: purple // 设置路径 redirect_from: - /about/ 颜色说明 蓝色: 软件/ API/ 提升效率 绿色: 语言相关 紫色: 算法/ 周赛 ","date":"2023-07-30T16:28:49Z","permalink":"https://li54426.github.io/p/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Egithub%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/","title":"如何基于github快速建立博客站点"},{"content":" content {:toc} 6900. 统计完全子数组的数目 - 力扣（LeetCode） 给你一个由 正 整数组成的数组 nums 。\n如果数组中的某个子数组满足下述条件，则称之为 完全子数组 ：\n子数组中 不同 元素的数目等于整个数组不同元素的数目。 返回数组中 完全子数组 的数目。\n子数组 是数组中的一个连续非空序列。\n1 2 3 输入：nums = [1,3,1,2,2] 输出：4 解释：完全子数组有：[1,3,1,2]、[1,3,1,2,2]、[3,1,2] 和 [3,1,2,2] 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: int countCompleteSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 子数组问题 int len = nums.size(); unordered_map\u0026lt;int, int\u0026gt; mp, rem; for(auto n: nums){ rem[n]++; } // auto rem = mp; int r = 0, l = 0; int res = 0; while(r\u0026lt; len){ int n = nums[r++]; mp[n]++; while(mp.size() == rem.size() \u0026amp;\u0026amp; l\u0026lt; r){ // 在左端点的情况下 // 枚举右端点 res += (len - r +1); int n = nums[l++]; mp[n]--; if(mp[n] == 0){ mp.erase(n); } } } return res; } } 2801. 统计范围内的步进数字数目 - 力扣（LeetCode） 给你两个正整数 low 和 high ，都用字符串表示，请你统计闭区间 [low, high] 内的 步进数字 数目。\n如果一个整数相邻数位之间差的绝对值都 恰好 是 1 ，那么这个数字被称为 步进数字 。\n请你返回一个整数，表示闭区间 [low, high] 之间步进数字的数目。\n由于答案可能很大，请你将它对 109 + 7 取余 后返回。\n**注意：**步进数字不能有前导 0 。\n1 2 3 输入：low = \u0026#34;1\u0026#34;, high = \u0026#34;11\u0026#34; 输出：10 解释：区间 [1,11] 内的步进数字为 1 ，2 ，3 ，4 ，5 ，6 ，7 ，8 ，9 和 10 。总共有 10 个步进数字。所以输出为 10 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // 这一版代码好一点了, 虽然逻辑还是有点重复 class Solution { bool isper(string s){ int len = s.size(); for(int i =1; i\u0026lt;len; ++i){ if(abs(s[i] - s[i-1] ) != 1){ return false; } } return true; } public: int countSteppingNumbers(string low, string high) { // 一个整数相邻数位之间差的绝对值都 恰好 是 1 ，那么这个数字被称为 步进数字 。 // s.len \u0026lt;= 100 int k = 1e9+7; // cur是 第几位数字, j 是 // limit 是该位置受不受限制 unordered_map\u0026lt;int, int\u0026gt; mp; function\u0026lt;int (int, int, bool, string \u0026amp;)\u0026gt; dfs = [\u0026amp;](int cur, int lastnum, bool islimit, string \u0026amp;s)-\u0026gt; int{ // lastnum == -1 时代表着没有数字 if(cur == s.size() ){ return 1; } // cout\u0026lt;\u0026lt; \u0026#34;cur=\u0026#34;\u0026lt;\u0026lt; cur\u0026lt;\u0026lt; \u0026#34;\\tlastnum = \u0026#34;\u0026lt;\u0026lt; lastnum\u0026lt;\u0026lt; \u0026#34;\\tislimit\u0026#34;\u0026lt;\u0026lt; islimit\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;\u0026lt;\u0026lt; s\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int res = 0; // 都是前导零 if(lastnum \u0026lt;0){ res += dfs(cur+1, -1, false, s); res %= k; int up = islimit? s[cur] - \u0026#39;0\u0026#39;: 9 ; for(int i = 1; i\u0026lt;= up; i++){ res += dfs(cur+1, i, islimit \u0026amp;\u0026amp; i ==up , s ); res %= k; } } else{ int flag = 1000 * lastnum + cur; if(!islimit \u0026amp;\u0026amp; mp.count(flag)){ return mp[flag]; } int up = islimit? s[cur] - \u0026#39;0\u0026#39;: 9 ; for(int i = lastnum \u0026lt;0? 1: 0; i\u0026lt;= up; ++i){ if(abs(i - lastnum) == 1){ res += dfs(cur+1, i, islimit\u0026amp;\u0026amp; i == up, s); res %= k; } } if(!islimit){ mp[flag] = res; } } return res; }; int max = dfs(0, -1, true, high ); mp.clear(); return (max - dfs(0, -1, true, low ) + isper(low) + k)%k; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 // 极度让人恶心的代码 // 发现逻辑很多重复了 class Solution { bool isper(string s){ int len = s.size(); for(int i =1; i\u0026lt;len; ++i){ if(abs(s[i] - s[i-1] ) != 1){ return false; } } return true; } public: int countSteppingNumbers(string low, string high) { // 一个整数相邻数位之间差的绝对值都 恰好 是 1 ，那么这个数字被称为 步进数字 。 // s.len \u0026lt;= 100 int k = 1e9+7; // cur是 第几位数字, j 是 // limit 是该位置受不受限制 unordered_map\u0026lt;int, int\u0026gt; mp; function\u0026lt;int (int, int, bool, string \u0026amp;)\u0026gt; dfs = [\u0026amp;](int cur, int lastnum, bool islimit, string \u0026amp;s)-\u0026gt; int{ // lastnum == -1 时代表着没有数字 if(cur == s.size() ){ return 1; } // cout\u0026lt;\u0026lt; \u0026#34;cur=\u0026#34;\u0026lt;\u0026lt; cur\u0026lt;\u0026lt; \u0026#34;\\tlastnum = \u0026#34;\u0026lt;\u0026lt; lastnum\u0026lt;\u0026lt; \u0026#34;\\tislimit\u0026#34;\u0026lt;\u0026lt; islimit\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;\u0026lt;\u0026lt; s\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int res = 0; if(islimit ){ if(lastnum \u0026lt;0){ int up = s[cur] - \u0026#39;0\u0026#39;; res += dfs(cur+1, -1, false, s); res %= k; for(int i = 1; i\u0026lt;= up; i++){ res += dfs(cur+1, i, islimit \u0026amp;\u0026amp; i ==up , s ); res %= k; } } else{ // lastnum \u0026gt;= 0 int up = s[cur] - \u0026#39;0\u0026#39;; for(int i = 0; i\u0026lt;= up; ++i){ if(abs(i - lastnum) == 1){ res += dfs(cur+1, i, islimit\u0026amp;\u0026amp; i == up, s); res %= k; } } } } else{// !islimit int flag = cur + 1000 * lastnum; if(mp.count(flag)){ return mp[flag]; } if(lastnum \u0026lt;0 ){ res += dfs(cur+1, -1, false, s); res %=k; for(int i = 1; i\u0026lt;= 9; i++){ res += dfs(cur+1, i, false , s ); res %= k; } } else{// lastnum \u0026gt;=0 if(lastnum +1 \u0026lt;=9) res += dfs(cur+1, lastnum +1, false, s); res%= k; if(lastnum-1 \u0026gt;=0) res += dfs(cur+1, lastnum -1, false, s); res %= k; } mp[flag] = res; } return res; }; int max = dfs(0, -1, true, high ); mp.clear(); return (max - dfs(0, -1, true, low ) + isper(low) + k)%k; } }; 2800. 包含三个字符串的最短字符串 - 力扣（LeetCode） 给你三个字符串 a ，b 和 c ， 你的任务是找到长度 最短 的字符串，且这三个字符串都是它的 子字符串 。\n如果有多个这样的字符串，请你返回 字典序最小 的一个。\n请你返回满足题目要求的字符串。\n注意：\n两个长度相同的字符串 a 和 b ，如果在第一个不相同的字符处，a 的字母在字母表中比 b 的字母 靠前 ，那么字符串 a 比字符串 b 字典序小 。 子字符串 是一个字符串中一段连续的字符序列。 1 2 3 输入：a = \u0026#34;abc\u0026#34;, b = \u0026#34;bca\u0026#34;, c = \u0026#34;aaa\u0026#34; 输出：\u0026#34;aaabca\u0026#34; 解释：字符串 \u0026#34;aaabca\u0026#34; 包含所有三个字符串：a = ans[2...4] ，b = ans[3..5] ，c = ans[0..2] 。结果字符串的长度至少为 6 ，且\u0026#34;aaabca\u0026#34; 是字典序最小的一个。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { string merge(const string \u0026amp;a, const string \u0026amp;b){ // return a+ b // 注意是不等于 -1, 因为可能是 0 // 不要写 if(a.find(b) ) if(a.find(b) != -1){ return a; } if(b.find(a) != -1){ return b; } for(int i = min(a.size(), b.size()); i\u0026gt;-1; --i){ if(a.substr(a.size( ) -i ) == b.substr(0, i) ){ // cout\u0026lt;\u0026lt; a+ b.substr(i)\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return a+ b.substr(i); } } return \u0026#34;\u0026#34;; } public: string minimumString(string a, string b, string c) { string arr[] = {a, b, c}; string ans = \u0026#34;\u0026#34;; // 枚举 arr 的全排列 int perm[][3] = { {0, 1, 2}, {0, 2, 1}, {1, 0, 2}, {1, 2, 0}, {2, 0, 1}, {2, 1, 0}}; for (const auto\u0026amp; p : perm) { string s = merge(merge(arr[p[0]], arr[p[1]]), arr[p[2]]); if (ans.empty() || s.length() \u0026lt; ans.length() || (s.length() == ans.length() \u0026amp;\u0026amp; s \u0026lt; ans)) { ans = s; } } return ans; } }; ","date":"2023-07-30T16:04:01Z","permalink":"https://li54426.github.io/p/%E7%AC%AC356%E5%9C%BA%E5%91%A8%E8%B5%9B/","title":"第356场周赛"},{"content":" content {:toc} 1 algorithm_DynamicProgram_1_01背包问题 题目链接: 2. 01背包问题 - AcWing题库\n有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。\n第 i 件物品的重量是 w[i]，价值是 v[i]。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。\n动态规划的三个步骤: 确立dp数组的意义 确立递推公式 确定遍历顺序( 多维 ) 处理边界情况 三个 tips: 当递推式包含min时，可以把初值设置的尽可能大，毕竟是求最小。 当递推式需要比较很多项时，min(dp[i] , dp[i-j]);也就是两两比较 注意处理边界条件。 有 N 件物品和一个容量是 W的背包。每件物品只能使用一次。\n第 i 件物品的重量是 w[i]，价值是 v[i]。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。\n输入格式 第一行两个整数，N，V用空格隔开，分别表示物品数量和背包容积。\n接下来有 N 行，每行两个整数 vi,wi用空格隔开，分别表示第 i 件物品的体积和价值。\n输出格式 输出一个整数，表示最大价值。\n数据范围 0\u0026lt;N,V≤10000\u0026lt;N,V≤1000 0\u0026lt;vi,wi≤1000\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main(){ // the number of things, and the volume of bags int N,V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt;V; vector\u0026lt;int\u0026gt; w(N,0), v(N, 0), dp(V+1, 0); for(int i =0; i\u0026lt;N; ++i){ cin\u0026gt;\u0026gt; w[i] \u0026gt;\u0026gt;v[i]; } //init for(int i =w[0];i\u0026lt;= V; ++i){ dp[i] = v[0]; } for(int i =1;i\u0026lt; N; ++i){ for(int j = V; j\u0026gt;= w[i]; --j){ dp[j] = max(dp[j- w[i]] + v[i], dp[j]); } } cout\u0026lt;\u0026lt; dp[V]\u0026lt;\u0026lt; endl; return 0; } ","date":"2023-07-30T13:38:49Z","permalink":"https://li54426.github.io/p/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_01%E8%83%8C%E5%8C%85/","title":"动态规划_01背包"},{"content":" content {:toc} 随机数 需要设计随机数种子 一般使用 时间戳 来设置 在线词典 词典地址\n右键\u0026mdash;检查\u0026mdash;-开发者工具 输入一个单词 开发者工具中找到 Network, 右键点击左边的菜单``dict`\u0026mdash;\u0026mdash;- 复制为 curl (bash) 1 2 3 4 5 6 7 https://api.interpreter.caiyunai.com/v1/dict 代码生成的网址 curlconverter.com oktools.net/json2go 代理服务器 Socket 5（Socks5）是一种网络协议，用于在客户端和服务器之间进行代理连接。Socks5 协议定义了客户端如何与代理服务器进行通信，以便在使用代理时提供安全、可靠的连接。\nSocks5 协议的主要特点包括：\n鉴权机制：Socks5 支持多种鉴权方式，包括无需鉴权、用户名密码鉴权等。客户端在连接代理服务器时需要提供合适的鉴权信息。 支持 TCP 和 UDP：除了常见的 TCP 连接之外，Socks5 还支持对 UDP 数据包的代理转发。 IPv6 和域名解析：Socks5 可以处理 IPv4、IPv6 和域名类型的地址，并通过特定的协议交换以实现地址解析和转发。 多重代理链：Socks5 支持多级代理，可以在客户端和目标服务器之间建立多个代理层级，增加灵活性和安全性。 通过使用 Socks5 协议，客户端可以将网络请求发送到代理服务器，由代理服务器负责与目标服务器建立连接并传递数据。这使得客户端能够通过代理服务器进行匿名访问、避免网络封锁或限制，或者在需要代理突破防火墙限制时使用。\n需要注意的是，Socks5 是一种通用的代理协议，并非仅限于特定的应用。它可以被各种网络应用和工具使用，包括网络浏览器、FTP 客户端、邮件客户端等，以提供代理功能和网络连通性。\n携程\u0026mdash;\u0026mdash;\u0026ndash;处理上万并发 协程:用户态,轻量级线程,栈KB级别. 线程:内核态,线程跑多个协程,栈MB级别. 1 2 3 4 5 6 7 8 9 10 func hello(i int) { println(\u0026#34;hello goroutine : \u0026#34; + fmt.Sprint(i)) } func HelloGoRoutine() { for i:= 0; i\u0026lt; 5; i++ { go func(j int) { hello(j) }(i) time.Sleep(time.Second) } 通信\n提倡通过通信共享内存而不是通过共享内存而实现通信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func CalSquare(){ src := make(chan int) dest := make(chan int, 3) go func() { defer close(src) A for i := 0; i \u0026lt; 10; i++ { src ← i }() go func() { defer close(dest) for i := range src B dest ← i * i }() for i := range dest { /复杂操作println(i) ","date":"2023-07-30T13:34:18Z","permalink":"https://li54426.github.io/p/go_2_%E5%B0%8Fdemo/","title":"Go_2_小DEMO"},{"content":" content {:toc} 基础应用 1 相关概念与快速开始 Git的安装与使用教程（超详细！！！）_9.冄2.7.號的博客-CSDN博客_git安装教程\n版本控制是什么?\n一种记录一个或若干文件内容变化,以便将来查阅特定版本修订情况的系统 为什么需要版本控制?\n更好的关注变更,了解到每个版本的改动是什么,方便对改动的代码进行检查,预防事故发生也能够随时切换到不同的版本,回滚误删误改的问题代码; 什么是 git\nGit 是一款免费、开源的分布式版本控制系统，他是著名的 Linux 发明者 Linus Torvalds 开发的 GitHub 主要提供基于 git 的版本托管服务。也就是说现在 GitHub 上托管的所有项目代码都是基于 Git 来进行版本控制的，所以 Git 只是 GitHub 上用来管理项目的一个工具而已，GitHub 的功能可远不止于此！ 1.1 GitHub 基本概念 Repository\n仓库的意思，即你的项目，你想在 GitHub 上开源一个项目，那就必须要新建一个 Repository，如果你开源的项目多了，你就拥有了多个 Repositories 。 Issue\n问题的意思，举个例子，就是你开源了一个项目，别人发现你的项目中有bug，或者哪些地方 做的不够好，他就可以给你提个 Issue ，即问题，提的问题多了，也就是 Issues ，然后你看 到了这些问题就可以去逐个修复，修复ok了就可以一个个的 Close 掉。 Star\n这个好理解，就是给项目点赞，但是在 GitHub 上的点赞远比微博、知乎点赞难的多，如果你有一个项目获得100个star都算很不容易了！ Fork\n这个不好翻译，如果实在要翻译我把他翻译成分叉，什么意思呢？你开源了一个项目，别人 想在你这个项目的基础上做些改进，然后应用到自己的项目中，这个时候他就可以 Fork 你的 项目，这个时候他的 GitHub 主页上就多了一个项目，只不过这个项目是基于你的项目基础 （本质上是在原有项目的基础上新建了一个分支，分支的概念后面会在讲解Git的时候说 到），他就可以随心所欲的去改进，但是丝毫不会影响原有项目的代码与结构。 Pull Request\n发起请求，这个其实是基于 Fork 的，还是上面那个例子，如果别人在你基础上做了改进，后 来觉得改进的很不错，应该要把这些改进让更多的人收益，于是就想把自己的改进合并到原 有项目里，这个时候他就可以发起一个 Pull Request（简称PR） ，原有项目创建人就可以收 到这个请求，这个时候他会仔细review你的代码，并且测试觉得OK了，就会接受你的PR，这 个时候你做的改进原有项目就会拥有了。 Watch\n这个也好理解就是观察，如果你 Watch 了某个项目，那么以后只要这个项目有任何更新，你 都会第一时间收到关于这个项目的通知提醒。 Gist\n有些时候你没有项目可以开源，只是单纯的想分享一些代码片段，那这个时候 Gist 就派上用 场了！ 1.2 git 目录结构 Git 的本质是一个文件系统，工作目录中的所有文件的历史版本以及提交记录（commit）都是以文件对象的方式保存在 .git 目录中的。 git下的版本库只位于工作区根目录下的 git目录 , 仅此一处 目前的Key的类型四种,分别是dsa、rsa、ecdsa、ed25519, 默认使用的是rsa, 由于一些安全问题,现在已经不推荐使用dsa和rsa了,优先推荐使用ed25519 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ├─hooks ├─info ├─logs │ └─refs │ ├─heads │ └─remotes │ └─origin ├─objects # 保存 git 对象的目录, 包括三类对象, commit,tree, blob │ ├─info │ └─pack └─refs # 保存branch和tag对应的commit ├─heads # branch 对应的 commit ├─remotes │ └─origin └─tags # tag 对应的 commit objects：这里是真正保存 Git 对象的目录，包括三类对象 commit，tree 和 blob Blob存储文件的内容 Tree存储文件的目录信息 Commit存储提交信息,一个Commit可以对应唯一版本的代码 refs 内容就是对应 Commit ID因此把ref当做指针, 指向对应的Commit来表示当前Ref对应的版本. Branch git checkout -b可以创建一个新分支, 分支一般用于开发阶段,是可以不断添加 Commit 进行迭代的 Tag标签一般表示的是一个稳定版本, 指向的Commit一般不会变更 refs/head 下保存 分支信息 1.3 密钥生成/ 设置用户名/ 缩写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 生成本地密钥 # ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 密钥默认存在 ~/.ssh/id_ed25519.pub ssh ssh-keygen -t rsa // linux 下ssh-keygen -t rsa //根据日志信息里面的 SSH KEY 存储路径找到 .ssh/id_rsa.pub 文件 //打开 git 网站，右上角用户头像，点击 settings，左侧菜单 SSH KEYS，将文件内容复制到 key 里 添加就可以了 //设置名称和邮箱 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; # 设置简写 git config --global alias.psm \u0026#39;push origin main\u0026#39; git config --global alias.plm \u0026#39;pull origin main\u0026#39; git config --global alias.st \u0026#39;status\u0026#39; git config --global alias.ci \u0026#39;commit\u0026#39; git config --global alias.br \u0026#39;branch\u0026#39; 1.3.pull \u0026amp;push/ 快速开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //推过去所需要的步骤 # 1 添加 git add . # 2 提交改变 git commit -m \u0026#34;描述\u0026#34; # 3 将本地的 main 分支的提交推送到名为 origin 的远程仓库的 main 分支。 git push origin main # 拉过来 git pull origin main git remote add origin 仓库名 1,5 git 的三种状态 Git 有三种状态，你的文件可能处于其中之一： 已提交（committed）、已修改（modified） 和 已暂存（staged）。\n已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交表示数据已经安全地保存在本地数据库中。 1.6 objects 如何将三个信息串联在一起\n通过commit找到 tree的信息, 每个 commit 都存储对应的 tree id 通过 tree 存储的信息, 获取对应的目录树结构 从 tree中 获取blob的id, 通过blob id获取对应的文件内容 2 远端仓库/ remote 2.1 http 和 git 协议有什么区别 第一组使用 HTTPS 协议，第二组使用 SSH 协议。具体选择哪种协议取决于你的需求和配置。 使用 HTTPS 协议需要提供用户名和密码，而使用 SSH 协议则需要设置密钥对。 1 2 3 4 5 6 7 # 用于查看当前项目中配置的所有远程仓库的详细信息。 git remote -v origin https://github.com/*****/tinywebserver (fetch) origin https://github.com/*****/tinywebserver (push) origin git@github.com:*****/simple-douyin.git (fetch) origin git@github.com:*****/simple-douyin.git (push) 其中\nfetch：git fetch 命令用于从远程仓库获取最新的代码和提交历史，但不会自动合并或更新你的本地分支。它将远程仓库的内容下载到你的本地仓库，使你能够查看和比较远程分支与本地分支之间的差异。fetch 操作不会修改你的本地分支，只会更新你的本地仓库。 push：git push 命令用于将你的本地分支的提交推送到远程仓库。它将你的本地分支的提交上传到远程仓库，并将远程仓库的相应分支更新为你的提交。push 操作会修改远程仓库的内容。 2.2 链接远程仓库 1 2 3 4 5 # 链接远程仓库，使通过网络与远程仓库进行交互。 git remote add \u0026lt;remote_name\u0026gt; \u0026lt;remote_url\u0026gt; # 设置fetch 和 push 为不同的仓库 git remote set-url --add --push origin git@github. com: my_repo/git.git 1.4 我当前在 dev分支, 运行 git push main会发生什么 如果你当前在 dev 分支，并且运行 git push main 命令，Git 会尝试将当前分支的提交推送到名为 main 的远程分支。\n然而，由于你当前在 dev 分支，而不是 main 分支，这个命令可能会失败。因为默认情况下，git push 命令会将当前分支的提交推送到与当前分支同名的远程分支。\n如果你想要将 dev 分支的提交推送到远程的 main 分支，你可以使用以下命令：\n1 git push origin dev:main 这个命令将会将本地的 dev 分支的提交推送到名为 origin 的远程仓库的 main 分支。\ngit fetch origin dev:main是什么意思 git fetch origin dev:main 命令的含义是从名为 origin 的远程仓库获取 dev 分支的最新提交，并将其存储为本地的 main 分支。\n这个命令的具体含义如下：\ngit fetch：从远程仓库获取最新的提交和分支信息。 origin：远程仓库的名称，通常是你克隆或者关联的远程仓库的默认名称。 dev：远程仓库的分支名称，你希望获取其最新提交。 main：本地分支的名称，用于存储从远程仓库获取的 dev 分支的提交。 通过运行这个命令，Git 会从 origin 远程仓库获取 dev 分支的最新提交，并将其存储为本地的 main 分支。这样，你就可以在本地的 main 分支上查看和操作从远程仓库的 dev 分支获取的提交。\n需要注意的是，这个命令会将远程 dev 分支的提交直接应用到本地的 main 分支，而不会创建新的合并提交。这种操作可能会覆盖本地 main 分支上的提交，所以请确保在运行这个命令之前，你的本地 main 分支没有重要的未提交的更改。\n查看文件内容 git cat-file 是一个用于查看 Git 对象内容的命令。Git 中的对象是存储在仓库中的基本数据单元，包括提交（commit）、树（tree）、标签（tag）和文件内容（blob）等。\n使用 git cat-file 命令，你可以通过指定对象的哈希值或引用来查看对象的内容。它的基本语法如下：\n1 cat-file -t \u0026lt;对象引用\u0026gt; 这个命令将会返回指定对象的类型。例如，git cat-file -t abc123 将会返回对象 abc123 的类型，比如 commit、tree、tag 或 blob。\n1 cat-file -p \u0026lt;对象引用\u0026gt; 这个命令将会返回指定对象的内容。例如，git cat-file -p abc123 将会返回对象 abc123 的内容，比如提交信息、文件内容等。\n通过使用 git cat-file 命令，你可以查看 Git 仓库中的对象的详细信息，这对于调试和了解仓库的内部结构非常有用。\n希望这个解释对你有帮助。如果你还有其他问题，请随时告诉我！\n3 分支操作 3.1 本地操作分支 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 查看本地分支列表 git branch # 查看远程分支列表 git branch -r # 新建一个叫 develop 的分支 git branch develop # 创建一个名为 \u0026#34;test\u0026#34; 的新分支，并从 \u0026#34;master\u0026#34; 分支进行分叉。 git branch test master # 切换 到 dev 分支 git checkout dev # 新建并且自动切换到 develop 分支 git checkout -b dev # 删除本地分支 git branch -d develop # 生成分支 git tag v1.0 # 用来切换tag git checkout v1.0 git checkout ffd9f2dd68f1eb21d36cee50dbdd504e95d9c8f7 # 后面的一长串是commit_id，是每次com mit的SHA1值，可以根据 git log 看到。 # tag\u0026lt;=\u0026gt; 稳定版本 git tag v0.0.1 3.2 想拉取远程仓库的 dev 分支怎么做 要拉取远程仓库的 dev 分支，可以按照以下步骤进行操作：\n1 git fetch origin dev 使用 git fetch origin dev 命令从远程仓库拉取 dev 分支的最新代码。这将会将远程仓库的 dev 分支代码下载到你本地仓库，不会自动合并到你当前的分支。 使用 git checkout dev 命令切换到 dev 分支。如果本地还没有 dev 分支，可以使用 git checkout -b dev origin/dev 命令创建并切换到 dev 分支。 现在你已经成功拉取了远程仓库的 dev 分支，可以开始在本地与该分支进行开发和修改。记得在操作前先保存好本地的修改，以免冲突。\n3.3 远程分支 远程分支没有新建指令, 直接 push 就好 1 2 3 4 5 6 7 8 9 10 # 删除远程分支 git push origin --delete publish # 通过将 \u0026lt;source\u0026gt; 设置为空，就表示没有要推送的本地分支，而只是请求删除远程分支 git push origin :develop # 如果你远程的分支想取名叫 develop2 ，那执行以下代码： git push origin develop:develop2 # 把 develop 分支推送到远程仓库 git push origin develop 当我们使用git clone 时, 克隆下了远端的仓库的哪个分支\n当你使用 git clone 命令克隆远程仓库时，默认情况下会克隆远程仓库的主分支（通常是 master 分支或者 main 分支）。 如果你想要克隆远程仓库的特定分支，可以使用 --branch 参数指定分支名称。例如，要克隆远程仓库的 develop 分支，可以运行以下命令：\n1 git clone --branch develop \u0026lt;remote_repository_url\u0026gt; 拉取远端其他分支\n1 2 # 在本地创建一个名为 dev 的分支, 并拉取远端分支 git fetch origin dev:dev 3.4 合并分支 Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 快照 。在进行提交操作时，Git 会保存一个提交对象（commit object）。 Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 1 2 3 4 5 6 7 # 我们在一个 featureA 分支开发完了一个功能，这个时候需要合并到主分支 master 上去 git checkout master git merge featureA # 也可以这么写 git checkout master git rebase featureA 区别\nrebase 跟 merge 的区别你们可以理解成有两个书架，你需要把两个书架的书整理到一起去， 第一种做法是 merge ，比较粗鲁暴力，就直接腾出一块地方把另一个书架的书全部放进去，虽然暴力，但是这种做法你可以知道哪些书是来自另一个书架的； 第二种做法就是rebase ，他会把两个书架的书先进行比较，按照购书的时间来给他重新排序，然后重新放置好，这样做的好处就是合并之后的书架看起来很有逻辑，但是你很难清晰的知道哪些书来自哪个书架的。 3.5 遇到冲突时的分支合并 有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 现在在 master分支, 想要合并 dev 的内容 $ git merge dev Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. $ git status On branch master You have unmerged paths. (fix conflicts and run \u0026#34;git commit\u0026#34;) Unmerged paths: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to mark resolution) both modified: index.html no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) 任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突 解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看 起来像下面这个样子：\n1 2 3 4 5 6 7 8 9 # HEAD 所指向的版本 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD:index.html \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt;contact : email.support@github.com\u0026lt;/div\u0026gt; ======= # 合并所指向的版本 \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt; please contact us at support@github.com \u0026lt;/div\u0026gt; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; iss53:index.html 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内 容。同时 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; , ======= , 和 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 这些行被完全删除了。\n3.6 多人合作冲突 远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移 动它们以精确反映远程仓库的状态。它们以\u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt; 的形式命名。\n假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。Git 也会给你一个与 origin 的master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\n隔离性\n如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。 如果要与给定的远程仓库同步数据，运行 git fetch \u0026lt;remote\u0026gt; 命令 4 常见开发场景 1、本地仓库有文件，远程服务器上面是新建的仓库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1 初始化仓库 git init test # 2 在仓库中新建文件编辑内容（例如test.txt） # 3 添加到暂存区 git add test.txt # 提交修改 git commit test.txt -m \u0026#39;提交test.txt\u0026#39; # 关联远程仓库, origin也是默认仓库的名字，也可以命名为其它的名字 git remote add origin git@gitee.com:blueses/test.git # 把本地仓库的master分支与远程仓库的master分支关联起来 # 把本地仓库的master分支的文件推送到远程仓库的master分支中 git push -u origin master 2、远程服务器上面有很多代码，要拉取到本地开始开发 1 2 3 4 # 直接克隆 git clone git@gitee.com:blueses/test.git # add、commit、pull、push 三步走 5 其他操作 / igonre ignore .gitignore 文件用于告诉 Git 哪些文件或目录应该被忽略，不纳入版本控制。当你在项目中创建一个 .gitignore 文件并列出要忽略的文件或模式时，Git 将不会跟踪或记录这些文件的更改。\n.gitignore 文件的作用有以下几个方面：\n忽略生成的文件：在开发过程中，你可能会生成一些临时文件、日志文件、编译输出文件等。通过在 .gitignore 文件中列出这些文件的模式，你可以告诉 Git 忽略它们，避免将它们纳入版本控制。 忽略敏感信息：有时，你可能会在项目中包含一些敏感信息，如密码、API 密钥等。通过将这些敏感文件的路径添加到 .gitignore 文件中，你可以确保它们不会被意外地提交到版本库中。 忽略操作系统和编辑器生成的文件：不同的操作系统和编辑器可能会生成一些特定的文件，如临时文件、缓存文件、配置文件等。通过 .gitignore 文件，你可以告诉 Git 忽略这些与特定环境相关的文件。 .gitignore 文件使用简单的模式匹配规则来指定要忽略的文件或目录。你可以使用通配符、路径模式和其他规则来匹配文件名或路径。\n需要注意的是，.gitignore 文件只对尚未被 Git 跟踪的文件起作用。如果某个文件已经被 Git 跟踪并提交到版本库中，那么即使将其添加到 .gitignore 文件中，Git 仍然会继续跟踪该文件。\n工作说明\n.gitignore 是一个文本文件，其中的每一行代表一个模式，表示匹配规则，开发人员需要忽略的模式相关的模式都应该放到.gitignore 文件中\n.gitignore 一般放在代码库的根目录下，这是官方推荐的做法。但是你也可以把它放置在代码库里边的任意目录下，代码库可以有多个.gitignore 文件，其中的匹配模式的路径是相对当前.gitignore 所在目录的。\ngit add . 会追踪 gitignore的对象么 git add . 命令会将当前目录下的所有文件和文件夹添加到 Git 的暂存区，但它不会追踪 .gitignore 文件中指定的被忽略的对象。\n.gitignore 文件的作用是告诉 Git 忽略某些文件或目录，不将它们纳入版本控制。当你运行 git add . 命令时，Git 会将所有未被忽略的文件添加到暂存区，但被 .gitignore 文件指定的被忽略的文件不会被添加到暂存区。\n这意味着，.gitignore 文件中指定的被忽略的文件或目录不会被 git add . 命令追踪或添加到暂存区。它们将保持未被跟踪的状态，不会被包含在提交中。\n如果你想要确保被 .gitignore 文件指定的被忽略的文件不会被 git add . 命令添加到暂存区，你可以使用 git add --ignore-errors . 命令。这个命令会忽略被忽略的文件，并继续添加其他未被忽略的文件到暂存区。\n需要注意的是，一旦某个文件被添加到暂存区并提交到版本库中，.gitignore 文件对该文件将不再起作用。如果你想要从版本库中移除已经提交的文件，你需要使用 git rm --cached \u0026lt;file\u0026gt; 命令。\n希望这解答了你的问题！如果还有其他问题，请随时问我。我会尽力帮助你！\n提交操作 1 2 3 4 5 6 7 8 9 # 修改最近一个的 commit 信息, 修改之后, commit id 会改变 # 老的 不会删除 git commit --amend # 对最近三个commit的修改, 合并commit, 修改具体的 commit message, 删除某个commit git rebase -i HEAD~3 # 该命令可以指定删除所有提交中的某个文件或者全局修改邮箱地址等操作 filter --branch 日志操作 1 2 git reflog expire --expire=now --all git gc --prune=now 拉取操作概念辨析 Clone拉取完整的仓库到本地目录,可以指定分支,深度. Fetch将远端某些分支最新代码拉取到本地,不会执行merge操作,会修改refs/remote内的分支信息,如果需要和本地代码合并需要手动操作. Pull拉取远端某分支,并和本地代码进行合并,操作等同于 git fetch + git merge,也可以通过 git pull \u0026ndash;rebase 完成 git fetch + git rebase 操作. 可能存在冲突,需要解决冲突. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 初始化一个新的 Git 仓库： git init # git remote add origin 远程仓库URL git remote add origin git@github.com:username/repo.git # 将远程仓库内容下载到本地： git pull origin 主分支名称 # 首次拉取代码时一定会存在当前分支与远程分支不同步的问题，我们可以指定使用 rebase 策略将你的更改应用到远程更改之上： git pull --rebase origin main # 如何查看我有没有 ssh 权限修改 github 的内容 ssh -T git@github.com # # 如果你想要将本地分支与远程仓库的同名分支进行关联， git push -u origin \u0026lt;本地分支名称\u0026gt; # 可以使用 git push / git pull # 将会将本地的 main 分支推送到远程仓库 origin 的 master 分支。 git push origin main:master 高级应用 6 github action Github Action 官方文档：https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#name\n是 Github 推出的持续集成工具\n持续集成是什么？ 简单说就是自动化的打包程序 —— 如果是前端程序员，这样解释比较顺畅：\n每次提交代码到 Github 的仓库后，Github 都会自动创建一个虚拟机（Mac / Windows / Linux 任我们选），来执行一段或多段指令（由我们定），例如：\nnpm install npm run build Yaml 是什么？ 我们集成 Github Action 的做法，就是在我们仓库的根目录下，创建一个 .github 文件夹，里面放一个 *.yaml 文件 —— 这个 Yaml 文件就是我们配置 Github Action 所用的文件。\n它是一个非常容易地脚本语言，如果我们不会的话，也没啥大事继续往下看就成了。\n参考文档：五分钟学习 YAML\nGithub Action 的使用限制 每个 Workflow 中的 job 最多可以执行 6 个小时 每个 Workflow 最多可以执行 72 小时 每个 Workflow 中的 job 最多可以排队 24 小时 在一个存储库的所有 Action 中，一个小时最多可以执行 1000 个 API 请求 并发工作数：Linux：20，Mac：5（专业版可以最多提高到 180 / 50） 什么是 Workflow？ Workflow 是由一个或多个 job 组成的可配置的自动化过程。我们通过创建 YAML 文件来创建 Workflow 配置。\n一、如何定义 Workflow 的名字？ name\nWorkflow 的名称，Github 在存储库的 Action 页面上显示 Workflow 的名称。\n如果我们省略 name，则 Github 会将其设置为相对于存储库根目录的工作流文件路径。\n1 name: Greeting from Mona on: push 二、如何定义 Workflow 的触发器？ on\n触发 Workflow 执行的 event 名称，比如：每当我提交代码到 Github 上的时候，或者是每当我打 TAG 的时候。\n1 // 单个事件 on: push // 多个事件 on: [push,pull_request] 事件大全：https://docs.github.com/en/actions/reference/events-that-trigger-workflows#about-workflow-events\n三、Workflow 的 job 是什么？ 答：一个 Workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。\n1、如何定义一个 job？ 1 jobs: my_first_job: name: My first job my_second_job: name: My second job 答：通过 job 的 id 定义。\n每个 job 必须具有一个 id 与之关联。\n上面的 my_first_job 和 my_second_job 就是 job_id。\n2、如何定义 job 的名称？ jobs.\u0026lt;job_id\u0026gt;.name\nname 会显示在 Github 上\n3、如何定义 job 的依赖？job 是否可以依赖于别的 job 的输出结果？ jobs.\u0026lt;job_id\u0026gt;.needs\n答：needs 可以标识 job 是否依赖于别的 job—— 如果 job 失败，则会跳过所有需要该 job 的 job。\n1 jobs: job1: job2: needs: job1 job3: needs: [job1, job2] jobs.\u0026lt;jobs_id\u0026gt;.outputs：用于和 need 打配合，outputs 输出 =》need 输入\njobs 的输出，用于和 needs 打配合：可以看到 ouput\n1 jobs: job1: runs-on: ubuntu-latest # Map a step output to a job output outputs: output1: ${{ steps.step1.outputs.test }} output2: ${{ steps.step2.outputs.test }} steps: - id: step1 run: echo \u0026#34;::set-output name=test::hello\u0026#34; - id: step2 run: echo \u0026#34;::set-output name=test::world\u0026#34; job2: runs-on: ubuntu-latest needs: job1 steps: - run: echo ${{needs.job1.outputs.output1}} ${{needs.job1.outputs.output2}} 4、如何定义 job 的运行环境？ jobs.\u0026lt;job_id\u0026gt;.runs-on\n指定运行 job 的运行环境，Github 上可用的运行器为：\nwindows-2019 ubuntu-20.04 ubuntu-18.04 ubuntu-16.04 macos-10.15 1 jobs: job1: runs-on: macos-10.15 job2: runs-on: windows-2019 5、如何给 job 定义环境变量？ jobs.\u0026lt;jobs_id\u0026gt;.env\n1 jobs: job1: env: FIRST_NAME: Mona 6、如何使用 job 的条件控制语句？ jobs.\u0026lt;job_id\u0026gt;.if\n我们可以使用 if 条件语句来组织 job 运行\n四、Step 属性是什么？ 答：每个 job 由多个 step 构成，它会从上至下依次执行。\nstep 运行的是什么？ step 可以运行：\ncommands：命令行命令 setup tasks：环境配置命令（比如安装个 Node 环境、安装个 Python 环境） action（in your repository, in public repository, in Docker registry）：一段 action（Action 是什么我们后面再说） 每个 step 都在自己的运行器环境中运行，并且可以访问工作空间和文件系统。\n因为每个 step 都在运行器环境中独立运行，所以 step 之间不会保留对环境变量的更改。\n1 # 定义 Workflow 的名字 name: Greeting from Mona # 定义 Workflow 的触发器 on: push # 定义 Workflow 的 job jobs: # 定义 job 的 id my-job: # 定义 job 的 name name: My Job # 定义 job 的运行环境 runs-on: ubuntu-latest # 定义 job 的运行步骤 steps: # 定义 step 的名称 - name: Print a greeting # 定义 step 的环境变量 env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat # 运行指令：输出环境变量 run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 五、Action 是什么？ 我们可以直接打开下面的 Action 市场来看看：\nAction 其实就是命令，比如 Github 官方给了我们一些默认的命令：\n比如最常用的，check-out 代码到 Workflow 工作区：\n1、我们应该如何使用 Action？ jobs.\u0026lt;job_id\u0026gt;.steps.uses\n比如我们可以 check-out 仓库中最新的代码到 Workflow 的工作区：\n1 steps: - uses: actions/checkout@v2 当然，我们还可以给它添加个名字：\n1 steps: - name: Check out Git repository uses: actions/checkout@v2 再比如说，我们如果是 node 项目，我们可以安装 Node.js 与 NPM：\n1 steps: - uses: actions/checkout@v2 - uses: actions/setup-node@v2-beta with: node-version: \u0026#39;12\u0026#39; 2、上面我们为什么要用：@v2 和 @v2-beta 呢？ 答：首先，正如大家所想，这个 @v2 和 @v2-beta 的意思都是 Action 的版本。\n我们如果不带版本号的话，其实就是默认使用最新版本的了。\n但是 Github 官方强烈要求我们带上版本号 —— 这样子的话，我们就不会出现：写好一个 Workflow，但是由于某个 Action 的作者一更新，我们的 Workflow 就崩了的问题。\n3、上面的 with 参数是什么意思？ 答：有的 Action 可能会需要我们传入一些特定的值：比如上面的 node 版本啊之类的，这些需要我们传入的参数由 with 关键字来引入。\n具体的 Action 需要传入哪些参数，还请去 Github Action Market 中 Action 的页面中查看。\n具体库的使用和参数，我们可以去官方的 Action 市场查看：\n六、我们如何运行命令行命令？ 上文说到，steps 可以运行：action 和 command-line programs。\n我们现在已经知道可以使用 uses 来运行 action 了，那么我们该如何运行 command-line programs 呢？\n答案是：run\nrun 命令在默认状态下会启动一个没有登录的 shell 来作为命令输入器。\n1、如何运行多行命令？ 每个 run 命令都会启动一个新的 shell，所以我们执行多行连续命令的时候需要写在同一个 run 下：\n单行命令 1 - name: Install Dependencies run: npm install 多行命令 1 - name: Clean install dependencies and build run： | npm ci npm run build 2、如何指定 command 运行的位置？ 使用 working-directory 关键字，我们可以指定 command 的运行位置：\n1 - name: Clean temp directory run: rm -rf * working-directory: ./temp 3、如何指定 shell 的类型？（使用 cmd or powershell or python？？） 使用 shell 关键字，来指定特定的 shell：\n1 steps: - name: Display the path run: echo $PATH shell: bash 下面是各个系统支持的 shell 类型：\n七、什么是矩阵？ 答：就是有时候，我们的代码可能编译环境有多个。比如 electron 的程序，我们需要在 macos 上编译 dmg 压缩包，在 windows 上编译 exe 可执行文件。\n这种时候，我们使用矩阵就可以啦～\n比如下面的代码，我们使用了矩阵指定了：2 个操作系统，3 个 node 版本。\n这时候下面这段代码就会执行 6 次 —— 2 x 3 = 6！！！\n1 runs-on: ${{ matrix.os }} strategy: matrix: os: [ubuntu-16.04, ubuntu-18.04] node: [6, 8, 10] steps: - uses: actions/setup-node@v1 with: node-version: ${{ matrix.node }} 下一篇文章：《实战：electron 通过 Github Action 自动打包，并上传到 Github 的 release 中》 敬请期待！！！！！\n2 github 妙用 1.3 建立图片存储仓库 建立 public 仓库\n设置 -\u0026gt; 开发者设置 -\u0026gt; 个人访问令牌-\u0026gt; 生成新令牌-\u0026gt; 设置有效期\n申请的Token只会显示一次，当你第二次在打开该页面时就无法看到该Token了。如果忘记了Token，唯一的办法就是重新生成一个\n注意如果上传的文件和仓库里的文件重名，会上传失败\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //注意: \u0026#34;repo\u0026#34;: \u0026#34;Github用户名/仓库名称\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;之前你申请的Token\u0026#34;, { \u0026#34;picBed\u0026#34;: { \u0026#34;current\u0026#34;: \u0026#34;github\u0026#34;, \u0026#34;github\u0026#34;: { \u0026#34;repo\u0026#34;: \u0026#34;xxx/xxx\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;xxxxxxxxx\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;images/\u0026#34;, \u0026#34;customUrl\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;picgoPlugins\u0026#34;: {} } 工作流 分支管理工作流 特点特点特点 Git Flow 分支类型丰富,规范严格 Github Flow 只有主干分支和开发分支,规则简单 Gitlab Flow 在主干分支和开发分支之上构建环境分支,版本分支,满足不同发布or环境的需要 1. git flow 包含五种类型的分支\nMaster: 主干分支\nDevelop: 开发分支\nFeature: 特性分支\nRelease: 发布分支\nHotfix: 热修复分支\n优点\n如果能按照定义的标准严格执行代码会很清晰,并且很难出现混乱. 缺点\n流程过于复杂,上线的节奏会比较慢. 由于太复杂,研发容易不按照标准执行从而导致代码出现混乱. github flow Github 的工作流,只有一个主干分支,基于 Pull Request 往主干分支中提交代码.\n选择团队合作的方式 ( 两种 )\nowner创建好仓库后, 其他用户通过 Fork的方式来创建自己的仓库, 并在 fork的仓库上进行开发 owner 创建好仓库后, 统一给团队内成员分配权限, 直接在同一个仓库内进行开发 gitlab flow Gitlab推荐的工作流是在GitFlow和 Github Flow上做出优化,既保持了单一主分支的简便,又可以适应不同的开发环境 原则:\nupstream first 上游优先 只有在上游分支采纳的代码才可以进入到下游分支,一般上游分支就是 master 代码合并 Fast-Forward\n不会产生一个merge节点,合并后保持一个线性历史,如果target分支有了更新,则需要通过 rebase操作更新 source branch 后才可以入.\nThree-Way Merge\n三方合并,会产生一个新的 merge节点\n如何选择合适的工作流 选择原则: 没有最好的,只有最合适的\n针对小型团队合作, 推荐使用Github工作流即可\n1.尽量保证少量多次,最好不要一次性提交上千行代码 提交 Pull Request 后最少需要保证有 CR 后再合入 主干分支尽量保持整洁,使用 fast-forward 合入方式,合入前进行rebase 一次混乱的开发流程 昨天看了下分支，好像大家拉的比较乱，\ndev是完成 dao 层以后的， user是 dev 加了用户登录， token 是 dev 加了 token功能 feed是 user 加了 feed 功能， publish是在user上改的 ","date":"2023-07-29T15:17:12Z","permalink":"https://li54426.github.io/p/github%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Github使用指南"},{"content":" content {:toc} 论文技巧Latex使用简介: latex摘要\u0026mdash;-快速入门 中文使用cjkutf8\n使用 % 进行注释 段与段之间要空一行 0 安装 网址 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n推荐miktex + texstudio\n安装推荐:miktix和texstudio\nmiktex console -\u0026gt; 更新 -\u0026gt;选择一个源\n###1. 公式\n####1.1 基本使用\n使用$$表示行内公式 如果需要直接使用不带编号的行间公式，则将公式用命令 \\ [ 和 \\ ] 包裹 使用带编号的公式 使用 \\begin{equation} 和 \\end{equation}\n​ 还可以用 \\tag 命令手动修改公式的编号，或者用 \\notag 命令取消为公式编号 ​ 数学模式有如下特点: 1 2 3 1 空格忽略, 2 不允许有空行, 3 所有字母当作变量处理 ####1.2 数学符号\n省略号 代码 $\\div$ \\div $\\times$ \\times 空格 \\quad 省略号$\\dots$ \\dots 上标 ^{} 下标 _{} 根号$\\sqrt[n]{}$ \\sqrt[n]{} 分数 $\\frac{}{}$ \\frac{}{} 或者 $$ \\parallel 无穷大 $\\infty $ \\infty 求和 $\\sum $ \\sum 求和有上下 \\sum \\limits^{}_{} 不等号 $\\ne $ \\ne 大于等于 $\\ge$ \\ge 小于等于 $\\le $ \\le 约等于 $\\approx $ \\approx 等价 $\\equiv $ \\equiv 范数(双竖杠) $\\Vert $ \\Vert 罗马数字 $$ \\uppercase\\expandafter{\\romannumeral2} 希腊字母 Latex代码 $\\alpha$ \\alpha $\\beta$ \\beta $\\delta$ \\delta $\\Delta$ \\delta $\\Pi$ \\Pi 1.3 公式引用 1 2 3 4 5 6 7 8 \\begin{equation} \\label{key} \\end{equation} %当引用时, 没有括号 例如 6 \\ref{key} %当引用时, 需要括号 例如 6 (\\ref{key}) 1.4 特殊的公式\u0026mdash;-规划 1 2 3 4 5 6 7 8 9 10 11 \\begin{align} % 规划的形式 % 最后一行没有 \\\\ \\min \\quad \u0026amp; 目标函数 \\\\ \\text{s.t.} \\quad \u0026amp; 约束1 \\label {cons1}\\\\ \u0026amp; 约束2 \\label {cons2}\\\\ \u0026amp; 约束3 \\label {cons3}\\\\ \u0026amp; 约束4\t\\label {cons4} \\end{align} 1 2 3 4 5 6 7 8 %分段函数 \\begin{equation} f(x)= \\begin{cases} 0 \u0026amp; \\text{x=0}\\\\ 1 \u0026amp; \\text{x!=0} \\end{cases} \\end{equation} 1.5 多行公式 公式编号在中间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 % 如果要折行的话，习惯上优先在等号之前折行，其次在加号、减号之前，再次在乘号、除号之前。其它位置应当避免折行。 目前最常用的是 align 环境，它将公式用 \u0026amp; 隔为两部分并对齐。分隔符通常放在等号左边 % 用 \\notag 去掉某行的编号 \\begin{equation} \\begin{aligned} a \u0026amp;= b + c \\\\ d \u0026amp;= e + f + g \\\\ h + i \u0026amp;= j + k \\\\ l + m \u0026amp;= n \\end{aligned} \\end{equation} %如果因为加的元素太多, 一行放不开 建议, \\begin{equation} \\begin{aligned} a =\u0026amp; b + c \\\\ + \u0026amp; e + f + g \\\\ + \u0026amp; j + k \\\\ + \u0026amp; n \\end{aligned} \\end{equation} %如果因为加的元素太多, 一行放不开 建议 \\begin{equation} \\begin{aligned} \\text{min} \\quad \u0026amp; b + c \\\\ \\text{s.t.} \\quad \u0026amp; e + f + g \\\\ \u0026amp; j + k \\\\ \u0026amp; n \\end{aligned} \\end{equation} ###2. 图片\n2.1 单个标题 \\includegraphics[⟨options⟩]{⟨fi lename ⟩}， 文件名可能需要用相对路径或绝对路径表示, 图片文件的扩展名一般可不写\n1 2 3 \\include{chapters/file} % 相对路径 \\include{/home/Bob/file} % *nix（包含 Linux、macOS）绝对路径 \\include{D:/file} % Windows 绝对路径，用正斜线 ``` %导包 usepackage{graphics} %导入图片, 当模板为两列, 但是想让图片占据着两列时, 使用\\begin{figure*}[t] %图片 \\begin{figure}[htbp] %居中 \\centering %\\includegraphics[width=2.5in]{Autoencoder1} %占据0.8宽度 \\includegraphics[width=0.40\\textwidth]{time.png} %图片名称 \\caption{Experimental running time} \\label{time} \\end{figure} \\[htbp\\] 为调整图片排版位置选项，说明如下：\n\\[h\\]当前位置。将图形放置在正文文本中给出该图形环境的地方。如果本页所剩的页面不够，这一参数将不起作用。\n\\[t\\]顶部。将图形放置在页面的顶部。\n\\[b\\]底部。将图形放置在页面的底部。\n\\[p\\]浮动页。将图形放置在一只允许有浮动对象的页面上。\n2. 并排插入多张图片并公用一个caption 有时候我们希望同时插入一组图片，共用一个大标题且为每张子图设小标题，效果如下：\n方法：同时引入 \\usepackage{graphicx} 和 \\usepackage{subfigure} 宏包，如下代码实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \\begin{figure}[htbp] \\centering \\subfigure[Fig1]{ \\includegraphics[scale=0.25]{Fig1.png} \\label{1} } \\quad \\subfigure[Fig2]{ \\includegraphics[scale=0.25]{Fig2.png} \\label{2} } \\quad \\subfigure[Fig3]{ \\includegraphics[scale=0.25]{Fig3.png}\\label{3} } \\quad \\subfigure[Fig4]{ \\includegraphics[scale=0.25]{Fig4.png}\\label{4} } \\caption{Experimental results of the authors} \\end{figure} 代码说明：\n\\subfigure\n\\[Fig1\\] 为子图的标题；\n\\caption{Experimental results of the authors} 为总标题。\n3.引用 (参考文献) Bib 参考文献一键复制 设置方法\n谷歌学术-\u0026gt; 设置 -\u0026gt; 选中显示导入 bibtex的链接 3.1 IEEE模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 % IEEE官网的latex模板，无法调用cite包。与下面第一节调用的biblatex包冲突（模板里自带的，开始没注意到，相当于我调用了两个参考文献的包），然后我改成网上一样的biblatex调用声明还是不行，因为新版必须用bibtex编译，且要在[ ]中声明，很多博客用的是biber，并且默认也是biber！即调用biblatex包必须要声明是用bibtex编译！ %导包, 在文章开始之前也就是 \\begin{document} \\usepackage[backend=bibtex,sorting=none]{biblatex} \\addbibresource{ref.bib} %sorting=none表示按照参考文献在论文中出现的先后顺序排序。 hyperref=true和backref=true表示为各个参考文献的引用处、及定理、定义、例子等的引用处都添加上超链接； % 显示参考文献, 在\\end{document}之前 \\printbibliography %引用格式: \\cite{key} 3.2 其他模板 1 2 3 4 5 6 7 8 9 %引用, FCN是我们在bibtex文件中自定义的名字 以一篇古老的分子动力学文章作为参考\\cite{yu2013toward} %如果不想用方括号, 可以使用 \\usepackage[superscript]{cite} %参考文献, 在 \\end{document}之前写 \\bibliographystyle{IEEEtran} \\bibliography{ref.bib} ####3.2引用网址\n1 2 3 4 5 6 7 8 9 10 11 12 %正文前引用 usepackagefurl} %bib文件中加入: @Misc{cite变量名, howpublished = {\\url{网页地址}}, note = {Accessed进入网页的具体日期}, title = {网页名称}, author = {作者} } 1911正文中具体使用为 1\\cite{cite变量名） 4.表格 网址 : tablegenerator.com\n1 2 3 4 5 6 \\begin{tabular}{cc}%一个c表示有一列，格式为居中显示(center) %\\begin{tabular}{|c|c|}通过添加 | 来表示是否需要绘制竖线 (1,1)\u0026amp;(1,2)\\\\%第一行第一列和第二列 中间用\u0026amp;连接 (2,1)\u0026amp;(2,2)\\\\%第二行第一列和第二列 中间用\u0026amp;连接 \\end{tabular} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 %经典三线表格 table的目的就是把表格给图片化 \\begin{table}[] \\centering \\caption{Notations in This Paper} \\begin{tabular}{|c|c|} \\hline 标题1 \u0026amp; 标题2 \\\\ \\hline $P$\t\u0026amp; the provider \\\\ $M_{it}$ \u0026amp; the \\\\ \\hline \\end{tabular} \\end{table} 5 算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 %算法宏包 \\usepackage[linesnumbered,ruled,vlined]{algorithm2e} \\usepackage{setspace} \\begin{algorithm}[t] %设置算法编号 %\\renewcommand{\\thealgocf}{3-1} \\SetAlgoLined %显示end \\caption{Genetic Algorithm}%算法名字 \\label{} \\KwIn{input parameters $T, $}%输入参数 \\KwOut{$ $}%输出 % \u0026#39;\\;\u0026#39; 用于换行 some description\\; \\For{condition}{ \\If{condition}{ 1\\; } } return \\end{algorithm} 6 字体大小 1 2 3 4 5 6 %学院名称太长, 导致作者变成了两行, 可以把学院名称的字体调小 \\tiny Hello Latex. \\scriptsize Hello Latex. \\footnotesize Hello Latex. \\small Hello Latex. \\normalsize Hello Latex. ","date":"2023-07-29T14:26:19Z","permalink":"https://li54426.github.io/p/latex%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"latex使用指南"},{"content":" content {:toc} 简介 1 特性 标准库就考虑性能, 但却是编译型语言 跨平台 类C, 强类型 带垃圾回收 Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。( 果然, 新语言就是没有历史包袱, 想怎么设计就怎么设计, ) 2 用 Go 的公司 腾讯 美团 滴滴 3 why go 最初使用的Python由于性能问题换成了Go C++不太适合在线Web业务早期 内部RPC和HTTP框架的推广 如果你要创建系统程序，或者基于网络的程序，Go语言是很不错的选择。 携程等并发模型 go 有多简单 1 2 3 4 5 6 7 package main import ( \u0026#34;net/http\u0026#34; ) func main() { http. Handle(\u0026#34;/\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) http. ListenAndServe(\u0026#34;: 8080\u0026#34;, nil) } OOP 与 Go Go 语言在设计上不是一种典型的面向对象编程语言，而是一种以并发和简洁为主要目标的编程语言。尽管如此，Go 语言仍然支持面向对象编程的一些概念和特性。\nGo 语言通过结构体（struct）和方法（method）来实现对面向对象编程的支持。结构体可以用于封装数据和行为，并且可以定义方法来操作结构体实例。这样就能够实现面向对象编程中的封装、继承和多态等概念。\n尽管 Go 语言没有经典面向对象语言中的类（class）的概念，但可以使用结构体和方法组合来模拟类的行为。通过在结构体上定义方法，可以实现对结构体的操作和行为的封装。\n除了结构体和方法，Go 语言还提供了接口（interface）的概念，它定义了一组行为规范。通过实现接口，可以实现多态的效果，使不同类型的对象可以根据接口进行统一的处理。\n需要注意的是，Go 语言更强调简洁和可读性，相比于传统的面向对象编程语言，Go 语言更加注重可组合性和函数式编程的思想。因此，在使用 Go 语言进行开发时，可以灵活地选择使用面向对象编程的特性来组织代码结构，或者使用其他更适合的编程范式。\n1 2 3 4 5 // c 风格 api s = append(s, \u0026#34;d\u0026#34;) s = append(s, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;) // 对象式 学习平台 go的example\n网络运行平台\n短链接:https://hi-hi.cn/gitpod\ngitpod 这个效果还挺好看\n如何组织代码 Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）类推==\u0026gt;STL或者模块（modules）python。一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。每个源文件都以一条package声明语句开始，这个例子里就是package main，表示该文件属于哪个包，紧跟着一系列导入（import）(python)的包，之后是存储在这个文件里的程序语句。 类似于pythonGo语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响Go代码的正确解析（译注：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字break、continue、fallthrough或return中的一个、运算符和分隔符++、--、)、]或}中的一个） Go语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式, ctrl + s以后自动格式化, 妙蛙 包导入顺序并不重要；gofmt工具格式化时按照字母顺序对包名排序。(我看不懂, 大为震撼) 1 2 3 4 5 6 7 // 多个包 import{ \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; } func hellow world 1 2 3 4 5 6 7 8 9 package main import( \u0026#34;fmt\u0026#34; ) func main(){ fmt.Println(\u0026#34;hellow world\u0026#34;) } 编译与运行 单文件\n1 2 3 4 5 # 运行 go run helloworld.go # 编译 go build helloworld.go 语法 参考资料\n前言 · Go语言圣经 (studygolang.com)\n循环没有括号 没有 ; 变量类型后置 支持返回多个值 1 2 3 4 5 6 7 package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, 世界\u0026#34;) } 类型与变量 类型不需要导入 可以使用 const修饰 短变量声明是一种简洁的变量声明方式，用于同时声明和初始化变量。 1 2 3 4 5 6 7 8 9 10 11 12 13 var b, c int = 1, 2 var e float64 // 短变量声明 f := a // 数组 var a [5]int b := [5]int{1, 2, 3, 4, 5} // 多维数组 var twoD [2][3]int byte 在 Go 编程语言中，byte 是一种基本数据类型，用于表示一个 8 位的无符号整数。它是 uint8 类型的别名。每个 byte 的取值范围是 0 到 255。\n在实际应用中，byte 类型通常用于处理二进制数据、字节流以及字符编码等场景。例如，在读取文件或网络数据时，常常使用 byte 数组来存储和操作字节数据。同时，Go 中的字符串也是由一系列 byte 组成的，因此 byte 类型也经常用于处理字符串的各种操作。\n可以通过以下方式声明和使用 byte 类型变量：\n1 2 3 4 5 6 7 8 9 var b byte // 声明一个 byte 类型变量 b = 65 // 赋值一个字节值 fmt.Println(b) // 输出: 65 str := \u0026#34;Hello\u0026#34; for i := 0; i \u0026lt; len(str); i++ { fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) // 遍历字符串并打印每个字符的 byte 值 } // 输出: 72 101 108 108 111 const 常量, 不用定义类型 1 2 3 const s string = \u0026#34;constant\u0026#34; const h = 500000000 const i = 3e20 / h type 定义类型 25 个关键字 1 2 3 4 5 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var switch 默认只进入一个道路 , 与c 不同 也能实现自定义结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { a := 2 switch a { case 1: fmt.Println(\u0026#34;one\u0026#34;) case 2: fmt.Println(\u0026#34;two\u0026#34;) case 3: fmt.Println(\u0026#34;three\u0026#34;) case 4, 5: fmt.Println(\u0026#34;four or five\u0026#34;) default: fmt.Println(\u0026#34;other\u0026#34;) } t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;It\u0026#39;s before noon\u0026#34;) default: fmt.Println(\u0026#34;It\u0026#39;s after noon\u0026#34;) } } 切片\u0026mdash; 长度可变的数组 1 2 3 4 5 6 // 无力吐槽了 int* arr = new int[size]; s := make([]string, 3) // c 风格 api s = append(s, \u0026#34;d\u0026#34;) s = append(s, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;) 字典/ 哈希 1 2 3 4 5 6 7 8 9 10 // ------------map------------- m := make(map[string]int) m[\u0026#34;one\u0026#34;] = 1 m[\u0026#34;two\u0026#34;] =2 // 遍历 for i, num := range nums{ } new 和 make 也是像 C++ 在 Go 语言中，make 和 new 是两个用于创建对象的关键字，但它们用途不同。\nnew：new 用于创建各种类型的指针，并分配了零值。例如，使用 new 可以创建一个指向整数、结构体或数组的指针，而指针指向的内容会被初始化为对应类型的零值。对于数组来说，返回的是指向数组的指针。\n1 2 3 4 5 var p *int = new(int) // 创建一个指向 int 类型的指针，并初始化为零值 fmt.Println(*p) // 输出：0 var arr *[]int = new([]int) // 创建一个指向 int 类型切片的指针，并初始化为零值 fmt.Println(*arr) // 输出：[] make：make 用于创建切片、映射和通道等引用类型的对象，并进行初始化。它会分配内存并返回一个已经初始化的非零值对象。对于切片、映射和通道来说，返回的是对象本身（非指针）。\n1 2 3 4 5 6 7 8 9 10 make(T, size) slice := make([]int, 5, 10) // 创建一个长度为 5，容量为 10 的 int 类型切片 fmt.Println(slice) // 输出：[0 0 0 0 0] m := make(map[string]int) // 创建一个 key 为字符串，value 为整数的映射 m[\u0026#34;foo\u0026#34;] = 42 fmt.Println(m) // 输出：map[foo:42] ch := make(chan int) // 创建一个整数类型的通道 控制流 for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 for j := 7; j \u0026lt; 9; j++ { fmt.Println(j) } // 大为震撼.jpg for { // ... } // else 空行不限制 if 7%2 == 0 { fmt.Println(\u0026#34;7 is even\u0026#34;) } else { fmt.Println(\u0026#34;7 is odd\u0026#34;) } a := 2 switch a { case 1: fmt.Println(\u0026#34;one\u0026#34;) case 2: fmt.Println(\u0026#34;two\u0026#34;) case 3: fmt.Println(\u0026#34;three\u0026#34;) case 4, 5: fmt.Println(\u0026#34;four or five\u0026#34;) default: fmt.Println(\u0026#34;other\u0026#34;) } 函数 一个函数的声明由func关键字、函数名、参数列表、返回值列表（这个例子里的main函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。第五章进一步考察函数。\n支持返回多个值 1 2 3 4 5 6 7 8 9 10 func add(n int){ n += 2 return n } func exists(m map[string]string, k string) (v string, ok bool) { v, ok = m[k] return v, ok } 在 Go 中，我们可以使用函数字面值（function literal）或闭包（closure）来定义匿名函数。匿名函数是没有名称的函数，可以直接在代码中声明和使用。\n匿名函数的定义语法如下：\n1 2 3 func() { // 函数体 } 匿名函数通常被赋值给一个变量，以便后续调用。示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { // 定义并调用匿名函数 func() { fmt.Println(\u0026#34;Hello, anonymous function!\u0026#34;) }() // 将匿名函数赋值给变量，然后进行调用 greeting := func() { fmt.Println(\u0026#34;Hello, anonymous function assigned to a variable!\u0026#34;) } greeting() } 当我们执行上述代码时，输出将会是：\n1 2 Hello, anonymous function! Hello, anonymous function assigned to a variable! 通过匿名函数，我们可以灵活地在代码中定义临时的、功能独立的函数，并且可以直接调用或将其赋值给变量后再调用。\n指针 对传入的参数进行修改 1 2 3 4 5 6 7 func addw(n int){ n += 2; } func add2(n *int){ *n += 2 } nil 在 Go 语言中，nil 表示一个空值或空指针。它是一种特殊的预定义常量，可以用来表示某些类型的零值或未初始化的变量。\n在 Go 中，nil 可以用于多种类型的数据，如指针、切片（slice）、映射（map）、通道（channel）和函数等。当这些类型的变量没有被分配具体的值或引用时，它们的默认值就是 nil。\n使用 nil 可以判断一个指针是否为空或未初始化，以避免访问空指针而导致程序崩溃。例如，如果一个指针的值为 nil，就表示它没有指向任何有效的内存地址。\n需要注意的是，在 Go 语言中，不同类型的 nil 并不相等。例如，一个指针类型的 nil 与一个切片类型的 nil 是不相等的。因此，在比较 nil 值时，应该使用相应类型的零值或其他相应的方法来进行比较。\n结构体 1 2 3 4 5 6 7 8 type user struct{ name string password string } func main(){ a := user(name: \u0026#34;wang\u0026#34;, password: \u0026#34;1024\u0026#34;) } 结构体方法 带指针可以修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type user struct { name string password string } func (u user) checkPassword(password string) bool { return u.password == password } func (u *user) resetPassword(password string) { u.password = password } func main() { a := user{name: \u0026#34;wang\u0026#34;, password: \u0026#34;1024\u0026#34;} a.resetPassword(\u0026#34;2048\u0026#34;) fmt.Println(a.checkPassword(\u0026#34;2048\u0026#34;)) // true } 大括号 在 Go 语言中，大括号（{}）通常用于以下几个方面：\n块语句：大括号用于定义代码块，将多条语句组织在一起形成一个逻辑单元。例如，在函数、条件语句（if、switch）、循环语句（for）等结构中，可以使用大括号包裹多条语句来构成一个代码块。 示例：\n1 2 3 4 5 6 7 8 go复制代码func main() { // 代码块 var x int = 10 if x \u0026gt; 5 { fmt.Println(\u0026#34;x 大于 5\u0026#34;) // ... } } 结构体和数组的字面量初始化：在结构体和数组的初始化过程中，大括号可以用来指定初始值。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Person struct { Name string Age int } func main() { // 使用大括号初始化结构体 p := Person{ Name: \u0026#34;Alice\u0026#34;, Age: 25, } // 使用大括号初始化数组 arr := [3]int{1, 2, 3} } 匿名函数体：在 Go 语言中，可以使用匿名函数（闭包）。匿名函数的函数体也需要用大括号包裹。 示例：\n1 2 3 4 5 6 func main() { // 定义匿名函数，并调用 func() { fmt.Println(\u0026#34;Hello, world!\u0026#34;) }() } 除了上述用途外，大括号在其他情况下并没有特殊的含义。需要注意的是，在 Go 语言中，大括号是强制性的，即使代码块只包含一条语句，仍然需要使用大括号将其包裹起来。\n进阶 错误处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) type user struct { name string password string } func findUser(users []user, name string) (v *user, err error) { for _, u := range users { if u.name == name { return \u0026amp;u, nil } } return nil, errors.New(\u0026#34;not found\u0026#34;) } func main() { u, err := findUser([]user{{\u0026#34;wang\u0026#34;, \u0026#34;1024\u0026#34;}}, \u0026#34;wang\u0026#34;) if err != nil { fmt.Println(err) return } fmt.Println(u.name) // wang if u, err := findUser([]user{{\u0026#34;wang\u0026#34;, \u0026#34;1024\u0026#34;}}, \u0026#34;li\u0026#34;); err != nil { fmt.Println(err) // not found return } else { fmt.Println(u.name) } } 字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { a := \u0026#34;hello\u0026#34; fmt.Println(strings.Contains(a, \u0026#34;ll\u0026#34;)) // true fmt.Println(strings.Count(a, \u0026#34;l\u0026#34;)) // 2 fmt.Println(strings.HasPrefix(a, \u0026#34;he\u0026#34;)) // true fmt.Println(strings.HasSuffix(a, \u0026#34;llo\u0026#34;)) // true fmt.Println(strings.Index(a, \u0026#34;ll\u0026#34;)) // 2 fmt.Println(strings.Join([]string{\u0026#34;he\u0026#34;, \u0026#34;llo\u0026#34;}, \u0026#34;-\u0026#34;)) // he-llo fmt.Println(strings.Repeat(a, 2)) // hellohello fmt.Println(strings.Replace(a, \u0026#34;e\u0026#34;, \u0026#34;E\u0026#34;, -1)) // hEllo fmt.Println(strings.Split(\u0026#34;a-b-c\u0026#34;, \u0026#34;-\u0026#34;)) // [a b c] fmt.Println(strings.ToLower(a)) // hello fmt.Println(strings.ToUpper(a)) // HELLO fmt.Println(len(a)) // 5 b := \u0026#34;你好\u0026#34; fmt.Println(len(b)) // 6 } 字符串格式化 %v方便的输出所有的数据 %+v 十分详细 %#v 非常详细 %.2f 保留两位小数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; type point struct { x, y int } func main() { s := \u0026#34;hello\u0026#34; n := 123 p := point{1, 2} fmt.Println(s, n) // hello 123 fmt.Println(p) // {1 2} fmt.Printf(\u0026#34;s=%v\\n\u0026#34;, s) // s=hello fmt.Printf(\u0026#34;n=%v\\n\u0026#34;, n) // n=123 fmt.Printf(\u0026#34;p=%v\\n\u0026#34;, p) // p={1 2} fmt.Printf(\u0026#34;p=%+v\\n\u0026#34;, p) // p={x:1 y:2} fmt.Printf(\u0026#34;p=%#v\\n\u0026#34;, p) // p=main.point{x:1, y:2} f := 3.141592653 fmt.Println(f) // 3.141592653 fmt.Printf(\u0026#34;%.2f\\n\u0026#34;, f) // 3.14 } JSON 处理 类型首字母需要大写 打印JSON的话需要 套一层 string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type userInfo struct { Name string // 输出时, 将会是小写 Age int `json:\u0026#34;age\u0026#34;` Hobby []string } func main() { a := userInfo{Name: \u0026#34;wang\u0026#34;, Age: 18, Hobby: []string{\u0026#34;Golang\u0026#34;, \u0026#34;TypeScript\u0026#34;}} buf, err := json.Marshal(a) if err != nil { panic(err) } fmt.Println(buf) // [123 34 78 97...] fmt.Println(string(buf)) // {\u0026#34;Name\u0026#34;:\u0026#34;wang\u0026#34;,\u0026#34;age\u0026#34;:18,\u0026#34;Hobby\u0026#34;:[\u0026#34;Golang\u0026#34;,\u0026#34;TypeScript\u0026#34;]} buf, err = json.MarshalIndent(a, \u0026#34;\u0026#34;, \u0026#34;\\t\u0026#34;) if err != nil { panic(err) } fmt.Println(string(buf)) var b userInfo err = json.Unmarshal(buf, \u0026amp;b) if err != nil { panic(err) } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, b) // main.userInfo{Name:\u0026#34;wang\u0026#34;, Age:18, Hobby:[]string{\u0026#34;Golang\u0026#34;, \u0026#34;TypeScript\u0026#34;}} } time 转化为字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { now := time.Now() fmt.Println(now) // 2022-03-27 18:04:59.433297 +0800 CST m=+0.000087933 t := time.Date(2022, 3, 27, 1, 25, 36, 0, time.UTC) t2 := time.Date(2022, 3, 27, 2, 30, 36, 0, time.UTC) fmt.Println(t) // 2022-03-27 01:25:36 +0000 UTC fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute()) // 2022 March 27 1 25 // 字符串形式 fmt.Println(t.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) // 2022-03-27 01:25:36 diff := t2.Sub(t) fmt.Println(diff) // 1h5m0s fmt.Println(diff.Minutes(), diff.Seconds()) // 65 3900 // 解析字符串, 转化为 time 格式 t3, err := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, \u0026#34;2022-03-27 01:25:36\u0026#34;) if err != nil { panic(err) } fmt.Println(t3 == t) // true // 获取时间戳 fmt.Println(now.Unix()) // 1648738080 } 数字解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { // 字符串, 进制, 精度 // 进制传 0 自动推测 f, _ := strconv.ParseFloat(\u0026#34;1.234\u0026#34;, 64) fmt.Println(f) // 1.234 n, _ := strconv.ParseInt(\u0026#34;111\u0026#34;, 10, 64) fmt.Println(n) // 111 n, _ = strconv.ParseInt(\u0026#34;0x1000\u0026#34;, 0, 64) fmt.Println(n) // 4096 n2, _ := strconv.Atoi(\u0026#34;123\u0026#34;) fmt.Println(n2) // 123 // 十进制的转化 n2, err := strconv.Atoi(\u0026#34;AAA\u0026#34;) fmt.Println(n2, err) // 0 strconv.Atoi: parsing \u0026#34;AAA\u0026#34;: invalid syntax } 进程信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { // go run example/20-env/main.go a b c d fmt.Println(os.Args) // [/var/folders/8p/n34xxfnx38dg8bv_x8l62t_m0000gn/T/go-build3406981276/b001/exe/main a b c d] fmt.Println(os.Getenv(\u0026#34;PATH\u0026#34;)) // /usr/local/go/bin... fmt.Println(os.Setenv(\u0026#34;AA\u0026#34;, \u0026#34;BB\u0026#34;)) buf, err := exec.Command(\u0026#34;grep\u0026#34;, \u0026#34;127.0.0.1\u0026#34;, \u0026#34;/etc/hosts\u0026#34;).CombinedOutput() if err != nil { panic(err) } fmt.Println(string(buf)) // 127.0.0.1 localhost } https://fanyi.caiyunapp.com/\n关键字 defer \u0026mdash;\u0026mdash;推迟运行 在 Go 语言中，defer 是一个关键字，用于延迟（defer）函数的执行。当一个函数中包含 defer 语句时，被延迟的函数不会马上执行，而是等到包含它的函数执行完毕后才会被调用。\ndefer 语句通常用于在函数返回之前执行一些清理或收尾操作，例如关闭文件、释放资源等。无论函数是正常返回还是发生异常，被延迟的函数都会被执行。\n延迟执行的函数调用会按照后进先出（LIFO）的顺序执行，即最后一个 defer 语句会最先执行。\n下面是一个简单的示例代码，演示了 defer 的使用：\n1 2 3 4 5 6 7 8 func main() { defer fmt.Println(\u0026#34;延迟执行的函数\u0026#34;) fmt.Println(\u0026#34;普通的函数\u0026#34;) // 输出结果： // 普通的函数 // 延迟执行的函数 } 在上述代码中，fmt.Println(\u0026quot;延迟执行的函数\u0026quot;) 使用了 defer 关键字，所以它会在 main 函数执行完毕之前被延迟执行，而 fmt.Println(\u0026quot;普通的函数\u0026quot;) 则会马上执行。因此，最终的输出结果将先打印 \u0026ldquo;普通的函数\u0026rdquo;，再打印 \u0026ldquo;延迟执行的函数\u0026rdquo;。\n常用的包 组织形式 每个包都对应一个独立的名字空间。每个源文件都是以包的声明语句开始，用来指明包的名字。 包内的成员将通过类似 tempconv.CToF 的形式访问。 同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。 要注意的是 tempconv.go 源文件导入了 fmt 包，但是 conv.go 源文件并没有，因为这个源文件中的代码并没有用到 fmt 包。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 每个源文件都是以包的声明语句开始，用来指明包的名字。 // Package tempconv performs Celsius and Fahrenheit conversions. package tempconv import \u0026#34;fmt\u0026#34; type Celsius float64 type Fahrenheit float64 const ( AbsoluteZeroC Celsius = -273.15 FreezingC Celsius = 0 BoilingC Celsius = 100 ) func (c Celsius) String() string { return fmt.Sprintf(\u0026#34;%g°C\u0026#34;, c) } func (f Fahrenheit) String() string { return fmt.Sprintf(\u0026#34;%g°F\u0026#34;, f) } 什么叫做 基于 GOPATH 开发的 基于 GOPATH 开发指的是在 Go 语言中使用 GOPATH 环境变量设置的工作目录进行开发。在 Go 语言中，GOPATH 是一个重要的环境变量，它指定了 Go 项目的根目录。\n当我们使用 Go 语言进行开发时，我们需要将项目源代码和依赖的第三方库都放置在 GOPATH 目录下的相应位置。通常，该目录结构如下：\n1 2 3 4 5 6 GOPATH/ |-- bin/ # 可执行文件 |-- pkg/ # 编译后生成的库文件 |-- src/ # 项目源代码、第三方库等 |-- myproject/ # 项目代码 |-- github.com/xxx/yyy/ # 第三方库 依赖管理 go 依赖管理主要经历以下三个阶段：\nGOPATH GO VENDOR GO Module gopath gopath 是 go 语言支持的一个环境变量，value 是 Go 项目的工作区。\n1 2 3 4 cd $GOPATH |---bin 项目编译的二进制文件 |---pkg 项目编译的中间产物加速编译 |---src 项目源码 项目代码直接依赖src下的代码 go get下载最新版本的包到src 目录下 同一个 pkg，但是 pkg 有不同版本 pkg v1 和 pkg v2, 里面包含两个方法。而 src 下只能有一个版本存在，那 AB 项目无法保证都能编译通过。\n就是在 gopath 管理模式下，如果多个项目依赖同一个库，则依赖该库是同一份代码，所以不同项目不能依赖同一个库的不同版本，这很显然不能满足我们的项目依赖需求。无法实现 package 的多版本控制。\n为了解决这个问题，go vendor 出现了。\nGo Vendor 项目目录下增加 vendor 文件, 所有依赖包副本形式放在$ProjectRoot/vendor 依赖寻址方式:vendor=\u0026gt;GOPATH 问题\nA依赖于 B C B C 依赖于 D不同的版本 go module 有了 Go module 之后，可以方便地管理项目的依赖关系，并且不需要手动下载库。使用 Go module，你可以在代码中引入需要的库，并通过指定版本或者版本范围来自动获取相应的库。当你首次引入一个新的库时，Go module 会自动下载该库及其依赖到本地的缓存中。这样，你就可以随意引入库，而无需手动下载。\n依赖管理三要素\n1.配置文件, 描述依赖go.mod 2.中心仓库管理依赖库 Proxy 3.本地工具 go get/mod 1 2 3 4 5 6 7 8 module example/project/ap // p依赖管理基本单元 go 1.16 // 原生库 require ( // 单元依赖 example/lib1 v1.0.2 example/lib2 v1.0.0 // indirect example/lib3 v0.1.0-20190725025543-5a5fe074e612 example/lib4 v0.0.0-20180306012644-bacd9c7ef1dd // indirect example/lib5/v3 v3.0.2 ) 依赖配置 - indirect 关键字\nA-\u0026gt;B-\u0026gt;C，A-\u0026gt;B 属于直接依赖，A-\u0026gt;C 属于间接依赖。 在 go.mod 中，对于没有直接导入该依赖模块的包，也就是非直接依赖，标识间接依赖。所以加上 indirect 后缀。 为什么需要 Proxy\n直接使用版本管理仓库下载依赖，存在多个问题，\n无法保证构建确定性：软件作者可以直接代码平台增加 / 修改 / 删除软件版本，导致下次构建使用另外版本的依赖，或者找不到依赖版本。 无法保证依赖可用性：依赖软件作者可以直接代码平台删除软件，导致依赖不可用。 增加第三方代码托管平台的压力，代码托管平台负载问题。 使用 go proxy 之后，构建时会直接从 go proxy 站点拉取依赖。类比项目中，下游无法满足我们上游的需求。\n1 GOPROXY=\u0026#34;https://proxy1.cn, https://proxy2.cn ,direct\u0026#34; 工具 - go get/mod 开头提到 go model 有两个本地工具，go get/mod。\n指令功能 @update 默认 @none 删除依赖 @v1.1.2 下载指定tag版本,语义版本 @23dfdd5 下载特定的commit版本 @master 下载分支的最新commit go mod\n指令 功能 init 初始化,创建go.mod文件 tidy 增加需要的依赖,删除不需要的依赖 go module 使用方法 确保你的项目目录下有一个有效的 go.mod 文件。如果没有，可以通过运行 go mod init 命令来初始化一个新的模块。 在你的项目中，使用 import 语句导入你需要的依赖项。 运行 go mod tidy 命令来自动分析你的代码并下载缺少的依赖项。这个命令会根据你的代码中的导入语句自动更新 go.mod 文件，并下载相应的依赖项。 如果你想手动下载特定的依赖项，可以使用 go get 命令，例如 go get github.com/example/package。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 $ go env GO111MODULE=\u0026#34;on\u0026#34; GOARCH=\u0026#34;amd64\u0026#34; GOBIN=\u0026#34;\u0026#34; GOCACHE=\u0026#34;/home/runner/.cache/go-build\u0026#34; GOENV=\u0026#34;/home/runner/.config/go/env\u0026#34; GOEXE=\u0026#34;\u0026#34; GOEXPERIMENT=\u0026#34;\u0026#34; GOFLAGS=\u0026#34;\u0026#34; GOHOSTARCH=\u0026#34;amd64\u0026#34; GOHOSTOS=\u0026#34;linux\u0026#34; GOINSECURE=\u0026#34;\u0026#34; GOMODCACHE=\u0026#34;/home/runner/go/pkg/mod\u0026#34; GONOPROXY=\u0026#34;\u0026#34; GONOSUMDB=\u0026#34;\u0026#34; GOOS=\u0026#34;linux\u0026#34; GOPATH=\u0026#34;/home/runner/go\u0026#34; GOPRIVATE=\u0026#34;\u0026#34; GOPROXY=\u0026#34;https://goproxy.cn,direct\u0026#34; GOROOT=\u0026#34;/nix/store/4m1nfq0xhc9p1hi6dnxbcpppcgz22yf9-go-1.17.5/share/go\u0026#34; GOSUMDB=\u0026#34;sum.golang.org\u0026#34; GOTMPDIR=\u0026#34;\u0026#34; GOTOOLDIR=\u0026#34;/nix/store/4m1nfq0xhc9p1hi6dnxbcpppcgz22yf9-go-1.17.5/share/go/pkg/tool/linux_amd64\u0026#34; GOVCS=\u0026#34;\u0026#34; GOVERSION=\u0026#34;go1.17.5\u0026#34; GCCGO=\u0026#34;gccgo\u0026#34; AR=\u0026#34;ar\u0026#34; CC=\u0026#34;gcc\u0026#34; CXX=\u0026#34;g++\u0026#34; CGO_ENABLED=\u0026#34;1\u0026#34; GOMOD=\u0026#34;/home/runner/app/go.mod\u0026#34; CGO_CFLAGS=\u0026#34;-g -O2\u0026#34; CGO_CPPFLAGS=\u0026#34;\u0026#34; CGO_CXXFLAGS=\u0026#34;-g -O2\u0026#34; CGO_FFLAGS=\u0026#34;-g -O2\u0026#34; CGO_LDFLAGS=\u0026#34;-g -O2\u0026#34; PKG_CONFIG=\u0026#34;pkg-config\u0026#34; GOGCCFLAGS=\u0026#34;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build2769124553=/tmp/go-build -gno-record-gcc-switches\u0026#34; # 设置 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct GO111MODULE 有三个值：off、on 和 auto (默认值)\nGO111MODULE=off ：go 命令行将不会支持 module 功能，寻找依赖包的方式将会沿用旧版本那种通过 vendor 目录或者 GOPATH 模式来查找。\nGO111MODULE=on ：go 命令行会使用 modules，而一点也不会去 GOPATH 目录下查找。\n1 GO111MODULE=auto ：默认值，go 命令行将会根据当前目录来决定是否启用 module 功能。这种情况下可以分为两种情形：\n当前目录在 GOPATH/src 之外且该目录包含 go.mod 文件 当前文件在包含 go.mod 文件的目录下面。 嘿！要查看当前环境下是否已安装 github.com/jinzhu/gorm 包，你可以尝试以下步骤：\n打开终端或命令提示符。 运行 go list -m github.com/jinzhu/gorm 命令。 如果你看到了类似 github.com/jinzhu/gorm 的输出，那么说明该包已经在当前环境中安装了，并且输出会显示其版本号。 如果没有输出或者显示 go: github.com/jinzhu/gorm: module github.com/jinzhu/gorm not found，那么说明该包尚未在当前环境中安装。 如果你发现该包尚未安装，你可以尝试使用 go get 命令来安装它，如：go get -u github.com/jinzhu/gorm。\ngo mod 使用 | 全网最详细 - 知乎 (zhihu.com)\n直接在文件里 import 然后运行 go mod tidy就行吗\ngo build 编译的时候会根据 go.mod 里自己下载包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 go mod init packagename Go mod provides access to operations on modules. Note that support for modules is built into all the go commands, not just \u0026#39;go mod\u0026#39;. For example, day-to-day adding, removing, upgrading, and downgrading of dependencies should be done using \u0026#39;go get\u0026#39;. See \u0026#39;go help modules\u0026#39; for an overview of module functionality. Usage: go mod \u0026lt;command\u0026gt; [arguments] The commands are: download download modules to local cache edit edit go.mod from tools or scripts graph print module requirement graph init initialize new module in current directory tidy add missing and remove unused modules vendor make vendored copy of dependencies verify verify dependencies have expected content why explain why packages or modules are needed Use \u0026#34;go help mod \u0026lt;command\u0026gt;\u0026#34; for more information about a command. 1 2 # 发布到 github之上, 如果别人需要 go get github.com/jacksonyoudi/gomodone fmt 1 fmt.Println(\u0026#34;hello world\u0026#34;) net 在 Go 语言中，net 包是一个标准库的包，提供了网络相关的功能和接口。它包含了一系列用于网络编程的函数和类型，可以用于创建和管理网络连接、实现网络通信、处理网络协议等操作。\nnet 包提供了对常见网络协议（如 TCP、UDP、IP）的支持，以及一些基本的网络操作，如域名解析、网络地址转换、端口扫描等。通过该包，你可以创建客户端和服务器，进行网络数据的发送和接收，处理网络连接的状态和错误等。\n在使用 net 包时，你可以创建各种类型的网络连接，在这些连接上进行读写操作，还可以设置连接的属性和超时时间。此外，net 包也提供了一些高级功能，比如通过 net/http 包实现 HTTP 服务器和客户端。\n总的来说，net 包是 Go 语言中用于网络编程的核心库，为开发人员提供了丰富的功能和接口，方便进行网络通信和处理。\ngin Gin 是一种轻量级的 Web 框架，用于构建基于 Go 语言的后端应用程序。它提供了快速、简单和具有高度灵活性的方式来处理 HTTP 请求和响应。Gin 框架具有良好的性能，并且易于学习和使用，适用于构建各种规模的 Web 应用程序。它支持中间件、路由、参数解析、错误处理等功能，可以帮助开发者高效地构建 RESTful API 或者其他类型的 Web 服务。Gin 框架在 Go 社区广泛流行，并得到了很多开发者的支持和贡献。\n它和其他第三方 Golang 库一样。如果你是基于 GOPATH 开发的，你需要先使用 go get -u github.com/gin-gonic/gin 下载 gin，然后 import 导入即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;github.com/gin-gonic/gin\u0026#34; func main() { r := gin.Default() r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;Blog\u0026#34;:\u0026#34;www.flysnow.org\u0026#34;, \u0026#34;wechat\u0026#34;:\u0026#34;flysnow_org\u0026#34;, }) }) r.Run(\u0026#34;:8080\u0026#34;) } gin.Context 是 Gin 框架中的上下文对象，它封装了请求和响应的相关信息，并提供了许多有用的方法来处理 HTTP 请求和构建 HTTP 响应。\n在使用 Gin 编写路由处理函数时，通常需要接收一个 gin.Context 参数。通过这个参数，我们可以获取请求的各种信息，如请求头、URL 参数、请求体等，并使用它们来进行逻辑处理和生成响应。\n下面是一些常用的 gin.Context 方法：\nc.Request：获取原始的 http.Request 对象，可以通过它访问更底层的请求和响应信息。 c.Param(name)：获取 URL 路径中的参数值。 c.Query(key)：获取查询字符串中指定键名的值。 c.GetHeader(key)：获取请求头中指定键名的值。 c.ShouldBindJSON(obj)：将请求的 JSON 数据绑定到指定的结构体对象中。 c.ShouldBindQuery(obj)：将查询字符串的参数绑定到指定的结构体对象中。 c.JSON(code, obj)：将指定的对象以 JSON 格式作为响应发送给客户端。 c.String(code, format string, values ...interface{})：将格式化后的字符串作为响应发送给客户端。 c.HTML(code, name string, data interface{})：渲染指定名称的 HTML 模板，并将其作为响应发送给客户端。 通过使用 gin.Context，我们可以方便地处理请求和构建响应，实现更加灵活和强大的 Web 应用程序。\ngin.Default () 默认使用了 logger and recovery (crash-free) 中间件 recovery 会把异常捕获到 做一个处理 比如返回一个状态码\n1 2 3 4 5 6 7 // Default逻辑 func Default() *Engine { debugPrintWARNINGDefault() engine := New() engine.Use(Logger(), Recovery()) return engine } router.GET(\u0026quot;/someGet\u0026quot;, getting) 表示在路由器上注册了一个 GET 请求的路由端点。当客户端发送一个 GET 请求到路径 \u0026ldquo;/someGet\u0026rdquo; 时，它会调用名为 getfun 的处理函数来响应这个请求。 1 2 router := gin.Default () router.GET (\u0026#34;/someGet\u0026#34;, getfun) 路由 创建一个默认的 Gin 路由器对象（router），然后定义了两个分组（group）：v1 和 v2。 v1 分组用于处理路径以 \u0026ldquo;/v1\u0026rdquo; 开头的请求，包括三个路由端点：/login、/submit 和 /read。这些端点分别对应 loginEndpoint、submitEndpoint 和 readEndpoint 函数。 v2 分组用于处理路径以 \u0026ldquo;/v2\u0026rdquo; 开头的请求，同样包括三个路由端点。这些端点也对应 loginEndpoint、submitEndpoint 和 readEndpoint 函数。 你访问的路径是 /v3 时，由于在代码中没有注册路径为 /v3 的路由端点，因此无论请求方法是什么（POST、GET 等），都会返回 404 Not Found 错误。Gin 默认情况下会返回 404 错误 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { router := gin.Default() // Simple group: v1 v1 := router.Group(\u0026#34;/v1\u0026#34;) { v1.POST(\u0026#34;/login\u0026#34;, loginEndpoint) v1.POST(\u0026#34;/submit\u0026#34;, submitEndpoint) v1.POST(\u0026#34;/read\u0026#34;, readEndpoint) } // Simple group: v2 v2 := router.Group(\u0026#34;/v2\u0026#34;) { v2.POST(\u0026#34;/login\u0026#34;, loginEndpoint) v2.POST(\u0026#34;/submit\u0026#34;, submitEndpoint) v2.POST(\u0026#34;/read\u0026#34;, readEndpoint) } router.Run(\u0026#34;:8080\u0026#34;) } ","date":"2023-07-28T21:19:24Z","permalink":"https://li54426.github.io/p/go_1_%E7%AE%80%E4%BB%8B/","title":"Go_1_简介"},{"content":" content {:toc} 概要 1课表,2 结营要求,笔记, 打卡,项目, 沸点, 3 1024如何使用,如何团队协作, 出现问题怎么处理, app如何下载运行\n‬⁢﻿⁣⁤⁣﻿‍‍⁡⁣‌﻿⁤⁡﻿⁢‌‍‌⁡‬⁡‌⁢⁤﻿﻿‌‍⁢‌⁣⁣‍‍⁢‬第六届字节跳动青训营-后端方向开营班会 - 飞书云文档 (feishu.cn)\n课表 进阶班:直播+录播 时间 7月25日(周二) 7月26日(周三) 7月28日(周五) 7月31日(周一) 8月1日(周二 课程 Go语言基础语法 Go语言工程实践 高质量编程与性能调优实践 HTTP框架修炼之道 打开抖音会发生什么 时间 8月2日(周三) 8月4日(周五) 8月5日(周六) 8月7日(周一) 8月8日(周二) 课程 将我的服务开放给用户 深入浅出RPC框架 带你认识存储\u0026amp;数据库 Go三件详解(Web/ RPC/ORM)R redis一大厂程序员是怎么用的 时间 8月10日(周四) B月11日(周五) 8月14日(周一) 8月15日(周二) B月18日(周五) 课程 TOS对象存储实战 走进消息队列 微服务架构原理与治理实践 架构初探之谁动了我的蛋糕 网站常见安全漏洞 8月21日(周一) 8月22日(周二) 8月24日周四 高性能Go语言发行版优化与落实 入理解RDBMS 从零拷贝视角看性能忧化 宝子们，文档来啦~\n开营班会文档：\n【开营班会】第六届字节跳动青训营-后端方向\n开营班会回放：https://meetings.feishu.cn/s/1j4s831x15i4i?src_type=3（已编辑）\n第一节课《Go 语言基础语法》分为两小节，课程链接如下：\n走进 Go 语言基础语法 - 掘金 Go 语言的实战案例 - 掘金 1024Code 组队协作编程流程说明文档（后端） - 飞书云文档 (feishu.cn)\n同学们早上好[愉快]今天我们上第二节课《Go 语言工程实践》，本节课分为两小节，课程链接如下： 1.\nGo 语言进阶与依赖管理 - 掘金\nGo 语言工程实践之测试 - 掘金\n【后端专场 学习资料一】字节跳动青训营 - 掘金\n同学们早上好[辛勤营业]今天我们上第三节课《高质量编程与性能调优实践》，本节课我们分为四小节，课程链接如下：\n高质量编程简介及编码规范 - 掘金\n性能优化指南 - 掘金\n性能优化分析工具 - 掘金\n性能调优实战案例 - 掘金\n今天的课程视频较多，请大家按时学习，学习结束别忘了填写签到问卷～\n课程签到问卷：\n《高质量编程与性能调优实践》后端进阶班 签到\n签到时限：截止到 2023.7.28 23:59（过时不支持补签！）\n参考资料：\n【后端专场 学习资料一】字节跳动青训营 - 掘金\n由于前两天很多同学签到信息有误，今天的考勤信息更新延迟到下周二，请大家后续认真填写签到问卷，确保信息正确无\n学们早上好～今天我们上第四节课《HTTP 框架修炼之道》，本节课分为三小节，课程链接如下：\n走进 HTTP 协议 - 掘金\nHTTP 框架的设计与实现 - 掘金\n性能修炼之道与企业实践 - 掘金\n请大家按时学习，学习结束别忘了填写签到问卷～\n课程签到问卷：\n《HTTP 框架修炼之道》后端进阶班 签到\n签到时限：截止到 2023.7.31 23:59（过时不支持补签！）\n参考资料：\n【Go 语言框架与实现 学习资料】字节跳动青训营 - 后端专场 - 掘金\n今天我们上第十三节课《微服务架构原理与治理实践》，本节课分为三小节，课程链接如下：\n微服务架构原理及特征 - 掘金\n核心服务治理功能 - 掘金\n字节跳动服务治理实践 - 掘金\n请大家按时学习，学习结束别忘了填写签到问卷～\n签到 uid 不要填错了！！看不懂说明的问问别人，填错的话无法统计到数据！\n课程签到问卷：\n《微服务架构原理与治理实践》后端进阶班 签到\n签到时限：截止到 2023.8.14 23:59（过时不支持补签！）\n参考资料：\n【后端专场 学习资料四】字节跳动青训营 - 掘金\n今天我们上第十四节课《架构初探之谁动了我的蛋糕》，本节课分为四小节，课程链接如下：\n架构定义解析 - 掘金\n企业级后端架构剖析 - 掘金\n业内后端架构面临的挑战 - 掘金\n后端架构实战 - 掘金\n参考资料：\n【后端专场 学习资料三】字节跳动青训营 - 掘金\n要求 每日问卷签到, 问卷开放时间为课程当日10:00-23:59, 过时不候 周五出结果, 申诉要趁早 **[8月30日]**之前 , 符合要求打卡天数≥21天 **[8月30日]**之前 , 笔记≥6篇 技术学习总结：总结青训营直播课程学习到的知识点，梳理分析，并给出自己的理解和对其他入门同学的学习建议 Go GORm 学习课表中的课程数13,且每门课程学习进度≥50% 条件4(满足其中一个): 项目 符合要求的课程笔记≥8篇 证书为电子证书 在沸点圈子「青训营 - 快乐出发」每日发布不少于 30 字的沸点，可优先进行阅读打卡，除了文末提供的阅读材料外，只要是掘金的技术文章都可以，也可以在圈子内分享自己的暑期生活。可以参考话题：# 挑战每日一条沸点 #、# 碳水使我快乐 #等，更多话题可以到话题广场进行搜索。 juejin.cn/pin/topics\n组队要求 小组人数4~8, 不能跨班 笔记要求 标题格式：xxxxx 标题 ｜ 青训营；（示例：“第六届字节跳动青训营第一课 ｜ 青训营”） 文章字数不得少于 650 字，不得有广告 / 洗稿 / 凑字数等行为； 所有的笔记都不能只贴代码，要有自己的分析思考，代码文字比不得超过 70% 。 📚 第六届青训营笔记伴读 ｜ 升级学习体验，高效掌握知识 - 掘金 (juejin.cn)\n1024 相关/ 项目 1024 code/ 代码 拿到邀请码以后再去注册\n主要功能\n在线多人协作, 包括代码 code 在线分享: 类似于 kaggle 助手:gpt Git版本管理:Git Commit,管理你的代码版本 数据库:云端数据库 建议 创建 github仓库\n‌‌‌⁢⁤﻿‍⁣‍‌‬‌‌﻿﻿﻿⁡⁣⁤‌⁡﻿⁣⁤‬⁣‬﻿﻿‍⁡⁢⁡⁣‬⁣⁡⁡⁤⁡‌1024Code 组队协作编程流程说明文档（后端） - 飞书云文档 (feishu.cn)\n产品简介 | 1024Code 文档中心\ngithub 联动 添加公钥到 GitHub/Gitee/GitLab\n打开个人中心设置页面复制个人的 SSH 公钥：添加到你的 GitHub/Gitee/GitLab 账户中：\n创建一个和代码空间同名的远程仓库，或在已存在的远程仓库中复制该仓库地址，如：git@github.com:li382112772/SimpleNES.git 创建团队 登录1024Code账号,进入工作台后,点击我的团队区域的\u0026quot;创建团队\u0026ldquo;功能按钮创建团队. 上传团队头像,填写团队名称以及团队简介信息后创建团队. 在团队工作台成员页面,添加或使用链接邀请成员加入团队. 在对团队成员列表里,可以更改成员角色、移出团队成员,可更改的角色包括:\n成员:可自由创建团队代码空间,可见团队所有代码空间,但不可编辑自己未加入协作的代码空间 管理员:可自由创建团队代码空间,可见并可主动加入所有团队代码空间进行协作编辑,可处理团队加入申请、可管理团队 所有者:拥有管理员全部权限的同时,可移交团队给其他成员(将其他成员设为所有者) 1024 创建代码空间 进入团队工作台,点击新建按钮选择 Go1.17环境模版,给团队创建代码空间: 代码空间创建成功后,在终端 shell中使用 git clone命令从服务端 Demo仓库(https://github.com/RaymondCode/simple-demo) clone项代码 或者直接Fork现成的项目demo代码空间:抖音项目服务端Demo - 1024Code 邀请队员加入代码空间协作\n在代码空间中点击协作浮窗,搜索添加或链接邀请队员加入代码空间进行实时协作编程. 使用git功能从远程仓库同步代码\n首先前往GitHub/GitLab网站创建一个项目,作为这次组队项目的远程代码仓库,并各自创建分支,以方便团队成员之间异步协作. 之后,打开1024Code代码空间git功能侧边窗口,按照操作提示流程连接远程仓库,同步1024Code代码仓库代码和GitHub/GitLab远程库代. 连接App调试接口\n按照项目要求下载apk 安装App后.在App中设置服务端地址,即1024Code代码空间浏览器输出窗口中的URL地址,进行接口调试,如下图: 注意:1024Code代码空间浏览器输出窗口中的URL地址,如https:/e398ab9bee48dc435e6fd167398b57c3-app.1024paas.com,伴随着代码空间所在容器的释放和重启激活(代码空间长时间无操作或者关闭页面后代码空间所在容器会被释放掉,再次打开后会重启一个容器),该URL地址会变.当服务端URL地址改变后,需要在App中重新设置下服务端地址. 此外,1024Code浏览器输出端口暂时仅支持8080端口,参照demo代码空间, listen and serve on 0.0.0.0:8080.\n1024 的问题 使用git clone命令克隆项目代码报错 1024Code IDE环境默认为国内网络环境,国内网络环境连接 GitHub,使用git clone命令会有不稳定的情况导致clone失败,失败时可多次尝试. 如何安装依赖1024 Code IDE代码空间基于Linux环境,并使用了Nixos来管理系统依赖,常用的第三方依赖我们可以使用npm install的方式进行安装,系统级依赖,如node.js和npm包,需要通过nix的方式,具体可参照:https://docs.1024code.com/Tutorials/practice 项目编译被 Killed 1024Code默认提供了1G内存大小的容器环境给每个代码空间,部分项目编译及运行时需要的内存大小瞬时超过1G,内存不足系统会kill掉该进程.遇到这种情况,大家在群里联系我们,青训营期间我们可以直接帮大家调大代码空间容器内存大小. APP 接口 极简抖音App使用说明 - 第六届青训营版 - 飞书云文档 (feishu.cn)\n‍‌‬‍‍⁢‌⁣⁤⁣‍⁡⁡‌‬‬⁢⁡‌‌‬⁢‬⁣‌‍⁣⁤‌‍⁣﻿﻿‍抖音项目方案说明-第六届青训营后端项目 - 飞书云文档 (feishu.cn)\n","date":"2023-07-26T13:21:50Z","permalink":"https://li54426.github.io/p/%E5%AD%97%E8%8A%82%E5%90%8E%E7%AB%AF%E8%AE%AD%E7%BB%83%E8%90%A5/","title":"字节后端训练营"},{"content":" content {:toc} 基础知识 代码风格 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int slowIndex = 0; for (int fastIndex = 0; fastIndex \u0026lt; nums.size(); fastIndex++) { if (nums[fastIndex] != 0) { nums[slowIndex++] = nums[fastIndex]; } } for (int i = slowIndex; i \u0026lt; nums.size(); i++) { nums[i] = 0; } } }; ACM模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main() { int n; while (cin \u0026gt;\u0026gt; n) { vector\u0026lt;int\u0026gt; gym(n); vector\u0026lt;int\u0026gt; work(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; work[i]; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; gym[i]; int result = 0; // 处理逻辑 cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } return 0; } leetcode模式/ 核心代码模式 只关注核心逻辑, 培养算法思维 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int slowIndex = 0; for (int fastIndex = 0; fastIndex \u0026lt; nums.size(); fastIndex++) { if (nums[fastIndex] != 0) { nums[slowIndex++] = nums[fastIndex]; } } for (int i = slowIndex; i \u0026lt; nums.size(); i++) { nums[i] = 0; } } }; 究竟什么是时间复杂度 时间复杂度是一个函数，它定性描述该算法的运行时间。\n我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。\n那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认 CPU 的每个单元运行消耗的时间都是相同的。\n假设算法的问题规模为 n，那么操作单元数量便用函数 f (n) 来表示，随着数据规模 n 的增大，算法执行时间的增长率和 f (n) 的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O (f (n))。\n什么是大o什么是大 O 这里的大 O 是指什么呢，说到时间复杂度，大家都知道 O (n)，O (n^2)，却说不清什么是大 O。\n算法导论给出的解释：大 O 用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。\n同样算法导论给出了例子：拿插入排序来说，插入排序的时间复杂度我们都说是 O (n^2) 。\n输入数据的形式对程序运算时间是有很大影响的，在数据本来有序的情况下时间复杂度是 O (n)，但如果数据是逆序的话，插入排序的时间复杂度就是 O (n^2)，也就对于所有输入情况来说，最坏是 O (n^2) 的时间复杂度，所以称插入排序的时间复杂度为 O (n^2)。\n同样的同理再看一下快速排序，都知道快速排序是 O (nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是 O (n^2) 的，所以严格从大 O 的定义来讲，快速排序的时间复杂度应该是 O (n^2)。\n但是我们依然说快速排序是 O (nlogn) 的时间复杂度，这个就是业内的一个默认规定，这里说的 O 代表的就是一般情况，而不是严格的上界。\n比如下面的常用算法的运行时间\n排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 O(n^2) O(n) O(n^2) OG) In-place 稳定 快速排序 O(n log n) O( n logn) Olon n In-place 不稳定 抓主要矛盾 1 2 3 4 O(2*n^2 + 10*n + 1000) = O(2*n^2 + 10*n) = O(n^2 + n) = O(n^2) O (nlogn) 和 O (n) 在算法的时间复杂度分析中，O (nlogn) 和 O (n) 是具有明显差异的复杂度级别。尽管它们都随着输入规模 n 的增加而增加，但增长率不同。\n当 n 增加时，O (nlogn) 的增长速度比 O (n) 快得多。具体来说，当 n 增加时，O (nlogn) 的增长率是线性对数级别（即 n 乘以其对数）。而 O (n) 的增长率是线性级别（即 n 的倍数）。\n举个例子，假设 n = 10^6，则 O (n) 的时间复杂度为 10^6，而 O (nlogn) 的时间复杂度为 10^6 * log₂(10^6)，约为 10^6 * 20 ≈ 2 * 10^7。可以看到，O (nlogn) 明显大于 O (n)。\n当输入规模较大时，如 n = 10^9，O (n) 的时间复杂度为 10^9，而 O (nlogn) 的时间复杂度为 10^9 * log₂(10^9)，约为 10^9 * 30 ≈ 3 * 10^10。同样可以看到，O (nlogn) 明显大于 O (n)。\n1 2 3 4 2^10 = 1024 ≈ 1000 n = 1000 时 O(n) = 1000 O(nlogn) = (1000 * 10) = 10,000 2 一些技巧 1.0 如何判断你的代码能不能在规定时间内通过: 机器处理的数据量为 1e8\n因此，一般1e4 范围内的数据可以 O(n2), 1e5范围内的数据O(nlogn)\n1.1 概念辨析 命令 解释 fun(x++) 输入到函数里面的是 x fun(++x) 输入到函数里面的是 x+1 if(! flag) 当 flag == 0的时候执行 if( 1== a) 写出if(1=a)就会报错, 少打了= int n = 1e5 少写几个零 (a, b)中有 b-a+1 个数字 vector\u0026lt;int\u0026gt;的中位数 a[n/2] 或者 1/2 * (a[n/2] +a[n/2 -1] ) max({a, b, c,,,}) abc,,,,中最大的数 1.2 各种初始化 有三种初始化方式,\n小括号初始化, 当你想用默认初始化时, Weight(), 会声明一个函数 大括号统一初始化, 从概念上可以用于一切场合, 表达一切意思的初始化, 有个新特性, 禁止内建型别之间进行隐式窄化型别转化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // -----------------------初始化------------------------- // 列表初始化 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; map = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; // 多维数组的列表初始化, 和上面一样 int map[4][2] = {1, 0, -1, 0, 0, 1, 0, -1}; // 默认值的初始化, 全部是 0 int a[26] ={}; int a[26]{}; // 前三个是 1, 2, 3, 后面的值都是 0 int a[26] ={1, 2, 3}; // 大括号 初始化 vector\u0026lt;int\u0026gt; v{1,3,4}; 1.3 巧用 引用ref 1 2 3 4 5 6 7 8 // -----------------------巧用引用------------------------- void mysort(vector\u0026lt;int\u0026gt; \u0026amp;nums){ // 如果要对数组元素进行改变, 可以使用引用. for(int \u0026amp;x: nums){ if(x% 2) x=-x; } sort(nums.begin(), nums.end()); } 1.4 数组的中位数 长度为len, 奇数: 正中间, 偶数中间偏右 使用下标时, a[l, r] $\\frac{l+r}{2}$中间靠左 1.6 类型上下界 缩写 类型 INT_MAX INT_MIN int 类型最大最小 UINT_MAX unsigned 最大最小 LONG_MIN LLONG_MAX long long最大最小 ULONG_MAX 1.5 模板 访问类内部成员 模拟题才会用到 1 2 3 4 5 6 // 访问类内部的类型时, 一般而言, 需要实例化以后才可以访问类内部的对象 template\u0026lt;typename T\u0026gt; class Myclass{ typename T::subtype *ptr; } // 含义是指向类内部类型的指针 ","date":"2023-07-25T21:19:24Z","permalink":"https://li54426.github.io/p/basic_1_%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"basic_1_算法基础知识"},{"content":" content {:toc} 1 allocator( 配置器 ) 1.1 代码分布 \u0026lt;stl_construct.h\u0026gt; 定义了全局函数construct()和destroy()，负责对象的构造和析构。 \u0026lt;stl_alloc.h\u0026gt; 定义了一二级配置器，配置器统称为alloc而非allocator！ \u0026lt;stl_uninitialized.h\u0026gt; 定义了一些全局函数，用来填充(fill)或者复制(copy)大块内存数据，也隶属于STL标准规范。 G 2.9 使用的是 alloc, 在G4.9中，分配器变成了new_allocator，旧的分配器alloc改名为_pool_alloc。STL标准告诉我们, 分配器在****中,\n考虑到小型区块所可能造成的内存破碎问题,SGI设计了双层级配置器,\n第一级配置器直接使用malloc()和free(), SGI第一级配置器的 allocate()和realloc都是在调用malloc和realloc()；不成功后，改调用oom_malloc()和oom_realloc();后两者都有内循环不断调用客户端注册的\u0026quot;__malloc_alloc_oom_handler “，以期望在某次调用之后获得足够的内存而圆满完成任务，但是如果没有注册”__malloc_alloc_oom_handler \u0026ldquo;，那么oom_malloc()和oom_realloc()便直接丢出bad_alloc异常信息或者exit(1)硬生生终止程序。\n第二级配置器则视情况采用不同的策略:当配置区块超过128 bytes时, 视之为\u0026quot;足够大\u0026rdquo;,便调用第一级配置器;当配置区块小于128 bytes时,视之为\u0026quot;过小\u0026quot;,为了降低额外负担, 便采用复杂的memory pool整理方式,而不再求助于第一级配置器 .\n所谓C++ new handler 机制是，你可以要求系统在内存配置需求无法被满足时，调用一个你所指定的函数。换句话说，-旦：：operator new无法完成任务，在丢出std:：bad_alloc异常状态之前，会先调用由客端指定的处理例程，该处理例\n整个 STL 的操作对象 都放在容器之内, 容器一定需要空间以配置资料 STL规则告诉我们配置器定义与\u0026lt;memory\u0026gt;中, 1 2 3 //----------memory.h---------- #include \u0026lt;stl_alloc.h\u0026gt; #include \u0026lt;stl_construct.h\u0026gt; 1.2 defalloc.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 文件目录 defalloc.h //仅仅是对 malloc 的包装 template \u0026lt;class T\u0026gt; class allocator { public: pointer allocate(size_type n) { return ::allocate((difference_type)n, (pointer)0);//函数2 } void deallocate(pointer p) { ::deallocate(p); } pointer address(reference x) { return (pointer)\u0026amp;x; } const_pointer const_address(const_reference x) { return (const_pointer)\u0026amp;x; } size_type init_page_size() { return max(size_type(1), size_type(4096/sizeof(T))); } size_type max_size() const { return max(size_type(1), size_type(UINT_MAX/sizeof(T))); } }; //函数2 template \u0026lt;class T\u0026gt; inline T* allocate(ptrdiff_t size, T*) { set_new_handler(0); T* tmp = (T*)(::operator new((size_t)(size * sizeof(T)))); if (tmp == 0) { cerr \u0026lt;\u0026lt; \u0026#34;out of memory\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } return tmp; } 1.3 stl_alloc.h __malloc_alloc_template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 // stl_alloc.h __malloc_alloc_template // 第一级配置器 // 该泛型类没有类型参数； //“__inst”是一个写死的int类型，但无实际意义 template \u0026lt;int __inst\u0026gt; class __malloc_alloc_template { private: //以下两个函数是，malloc 申请失败后（内存不足时）的处理方法 //用来申请空间，参数是申请的大小 static void* _S_oom_malloc(size_t); //用来扩增一个旧的内存空间 //参数1，是旧的空间地址；参数2，是重新申请的大小 static void* _S_oom_realloc(void*, size_t); #ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG //这是一个函数指针（指向函数的指针） static void (* __malloc_alloc_oom_handler)(); #endif public: static void* allocate(size_t __n) { // 调用 malloc() void* __result = malloc(__n); // 如果申请失败，改用 _S_oom_malloc() if (0 == __result) __result = _S_oom_malloc(__n); return __result; } //释放空间，参数1，地址指针；参数2，大小 //（很显然这里的第二参数没有意义） // 调用 free()释放空间 static void deallocate(void* __p, size_t /* __n */) { free(__p); //(为何__n 没有意义，c语言得知，free释放空间，是全部释放，不存在只释放一部分的情况) } //对一段旧空间扩容 static void* reallocate(void* __p, size_t /* old_sz */, size_t __new_sz) { void* __result = realloc(__p, __new_sz); // 如果申请失败，改用 _S_oom_malloc() if (0 == __result) __result = _S_oom_realloc(__p, __new_sz); return __result; } //动态指定，针对内存不足时的处理方法（注意书写格式） static void (* __set_malloc_handler(void (*__f)()))() { void (* __old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = __f; return(__old); } }; // malloc_alloc 针对内存不足时的处理方法 #ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG // 默认为0 template \u0026lt;int __inst\u0026gt; void (* __malloc_alloc_template\u0026lt;__inst\u0026gt;::__malloc_alloc_oom_handler)() = 0; #endif template \u0026lt;int __inst\u0026gt; void* __malloc_alloc_template\u0026lt;__inst\u0026gt;::_S_oom_malloc(size_t __n) { void (* __my_malloc_handler)(); //声明一个处理内存不足的函数指针； void* __result; // 一直申请直到失败或成功 for (;;) { __my_malloc_handler = __malloc_alloc_oom_handler; //当 \u0026#34;内存不足处理方法\u0026#34; 并未被设置，便调用 __THROW_BAD_ALLOC，抛出异常信息 if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; } // 调用内存不足时的处理函数 (*__my_malloc_handler)(); __result = malloc(__n); // 再次尝试申请内存 if (__result) return(__result); } } // 给一个已经分配了地址的指针重新分配空间 template \u0026lt;int __inst\u0026gt; void* __malloc_alloc_template\u0026lt;__inst\u0026gt;::_S_oom_realloc(void* __p, size_t __n) { void (* __my_malloc_handler)(); void* __result; for (;;) { __my_malloc_handler = __malloc_alloc_oom_handler; if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; } (*__my_malloc_handler)(); __result = realloc(__p, __n); if (__result) return(__result); } } 1.4 stl_alloc.h __default_alloc_template 两级结构, 第一级是 链表( free list ) 第二级是内存池 内存池不够的话, 继续 malloc\n其实 free list 可以和内存池相互转换,\n当 free list 某个大小的结点不足时, 可以调用内存池中的内存\n当内存池空的时候, 可以从free list中 调用 内存\n1 2 3 4 5 6 7 if(链表够): 从链表中取 else: if(内存池够): 从内存池中取(static refill(size_t __n)函数) refill调用 static _chunk_alloc(ize_t __size, int \u0026amp;__nobjs)函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // stl_alloc.h __default_alloc_template template \u0026lt;bool threads, int inst\u0026gt; class __default_alloc_template { private: static const int _ALIGN = 8; // 调整到 8字节 static const int _MAX_BYTES = 128; // 最大字节数 static const int _NFREELISTS = 16; // free lists 数目 _MAX_BYTES/_ALIGN static size_t _S_round_up(size_t __bytes){// 调整到 8字节 return (((__bytes) + (size_t) _ALIGN-1) \u0026amp; ~((size_t) _ALIGN - 1)); } union _Obj{ union _Obj* _M_free_list_link; char _M_client_data[1]; };//感觉定义一个结构体, 元素只有一个 指向 自己的 地址也可以 // 静态变量 static _Obj* volatile _S_free_list[]; // 确定应在哪个 list static size_t _S_freelist_index(size_t __bytes){ return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1); } static void* _S_refill(size_t __n); static char* _S_chunk_alloc(size_t __size, int \u0026amp;__nobjs); // Chunk allocation state, chunk_alloc 里使用 static char* _S_start_free; // 内存池起始地址 static char* _S_end_free; // 内存池结束地址 static size_t _S_heap_size; // 内存池大小 public: //-------接口---------- static void *allocate(size_t __n){ void *__ret = 0; if (__n \u0026gt; (size_t) _MAX_BYTES){ __ret = malloc_alloc::allocate(__n); } else{ //volatile 告诉编译器 不进行优化 _Obj* volatile* __my_free_list = _S_free_list + _S_freelist_index(__n); _Obj* __result = *__my_free_list; if (__result == 0) __ret = _S_refill(_S_round_up(__n)); //重填链表 else{ //和链表一样, 指向下一个结点 *__my_free_list = __result -\u0026gt; _M_free_list_link; __ret = __result; } } return __ret; }; static void deallocate(void* __p, size_t __n){ // 小于128的存储块, 要将他返回到那个链表中 if (__n \u0026gt; (size_t) _MAX_BYTES) malloc_alloc::deallocate(__p, __n); else { _Obj* volatile* __my_free_list = _S_free_list + _S_freelist_index(__n); _Obj* __q = (_Obj*)__p; __q -\u0026gt; _M_free_list_link = *__my_free_list; *__my_free_list = __q; } } static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz){ void *__result; size_t __copy_sz; if (__old_sz \u0026gt; (size_t) _MAX_BYTES \u0026amp;\u0026amp; __new_sz \u0026gt; (size_t) _MAX_BYTES){ //原来的大小比128大 return(realloc(__p, __new_sz)); } if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p); __result = allocate(__new_sz); __copy_sz = __new_sz \u0026gt; __old_sz? __old_sz : __new_sz; memcpy(__result, __p, __copy_sz); deallocate(__p, __old_sz); return(__result); } }; template \u0026lt;bool __threads, int __inst\u0026gt; char* __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_S_start_free = 0; template \u0026lt;bool __threads, int __inst\u0026gt; char* __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_S_end_free = 0; template \u0026lt;bool __threads, int __inst\u0026gt; size_t __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_S_heap_size = 0; template \u0026lt;bool __threads, int __inst\u0026gt; typename __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_Obj* volatile __default_alloc_template\u0026lt;__threads, __inst\u0026gt; ::_S_free_list[ __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_NFREELISTS ] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 // 返回一个大小为 n 的对象(假定 n 已经适当上调至 8 的倍数), // 因为free list中没有了节点, 所以尝试为对应的 free list 增加节点数目 // 默认取得20个新节点, 但如果内存池空间不足,获得的节点数可能小于20, 其中一个节点返回给调用者, 剩下的节点添入对应 free list template \u0026lt;bool __threads, int __inst\u0026gt; void *__default_alloc_template\u0026lt;__threads, __inst\u0026gt;:: _S_refill(size_t __n){ //重填链表, 默认重新要20个节点 int __nobjs = 20; // 注意参数 nobjs 是引用类型 char* __chunk = _S_chunk_alloc(__n, __nobjs); _Obj* volatile* __my_free_list; _Obj* __result; _Obj* __current_obj; _Obj* __next_obj; // 仅获得一个区块, 分配给调用者用, free list 无新节点 if (1 == __nobjs) return(__chunk); // 将多余区块纳入 free list __my_free_list = _S_free_list + _S_freelist_index(__n); __result = (_Obj*)__chunk; *__my_free_list = __next_obj = (_Obj*)(__chunk + __n); // 因为原始的内存里面的内容都是空的, 或者没有意义的, 需要将各节点串联起来, 第0个区块将返回给调用者 for (int __i = 1; __i \u0026lt; __nobjs - 1; __i++){ __current_obj = __next_obj; __next_obj = (_Obj*)((char*)__next_obj + __n); __current_obj -\u0026gt; _M_free_list_link = __next_obj; } __next_obj -\u0026gt; _M_free_list_link = 0; return(__result); } // 被 refill() 调用, 从内存池中取空间给 free list 使用 // 个人感觉没有必要, 毕竟这一个函数也只有 refill 调用(错误) // 为了递归调用自己(从freelist中找到了能用的 块 ) // 分配 nobjs 个大小为 size 的区块, template \u0026lt;bool __threads, int __inst\u0026gt; char *__default_alloc_template\u0026lt;__threads, __inst\u0026gt;:: _S_chunk_alloc(size_t __size, int \u0026amp;__nobjs){ char *__result; size_t __total_bytes = __size * __nobjs; size_t __bytes_left = _S_end_free - _S_start_free; // 内存池剩余空间 if (__bytes_left \u0026gt;= __total_bytes){ // 内存池剩余空间完全满足需求量 __result = _S_start_free; _S_start_free += __total_bytes; return(__result); } else if (__bytes_left \u0026gt;= __size){ // 内存池剩余空间不能完全满足需求量, 但能够供应至少一个区块 __nobjs = (int)(__bytes_left/__size); __total_bytes = __size * __nobjs; __result = _S_start_free; _S_start_free += __total_bytes; return(__result); } else{ // 内存池剩余空间连一个区块的大小能不能提供 // 利用 malloc() 从 heap 中配置内存, 大小为需求量的两倍, 再加上一个随着配置次数增加而越来越大的附加量 size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size \u0026gt;\u0026gt; 4); // 因为要创建新的内存池了, 所以 将 旧的 内存池中剩余的残余空间分配到适当的 free list 中 if (__bytes_left \u0026gt; 0){ _Obj* volatile* __my_free_list = _S_free_list + _S_freelist_index(__bytes_left); ((_Obj*)_S_start_free) -\u0026gt; _M_free_list_link = *__my_free_list; *__my_free_list = (_Obj*)_S_start_free; } // 尝试从 heap 中配置内存 _S_start_free = (char*)malloc(__bytes_to_get); if (0 == _S_start_free){ // heap 空间不足, malloc() 失败, 无法获得内存 size_t __i; _Obj* volatile* __my_free_list; _Obj* __p; // 从free list 找, 因为可能有些块比你需要的块 大 可以把他切割掉 for (__i = __size; __i \u0026lt;= (size_t)_MAX_BYTES; __i += (size_t)_ALIGN){ __my_free_list = _S_free_list + _S_freelist_index(__i); __p = *__my_free_list; if (0 != __p){ *__my_free_list = __p -\u0026gt; _M_free_list_link; _S_start_free = (char*)__p; _S_end_free = _S_start_free + __i; // 现在至少能提供一个区块了, 递归调用自己以修正 nobjs return(_S_chunk_alloc(__size, __nobjs)); } } // 连 free list 里也没有可用内存了 _S_end_free = 0; // 调用一级配置器看能不能有点用 // 一级配置器有 out-of-memory 处理机制, 或许有机会改善现在的情况, 如果无法改善, 抛出bad_alloc异常 _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get); } _S_heap_size += __bytes_to_get; _S_end_free = _S_start_free + __bytes_to_get; return(_S_chunk_alloc(__size, __nobjs)); } } ","date":"2023-07-25T21:19:24Z","permalink":"https://li54426.github.io/p/cpp_stl_1_alloctor/","title":"cpp_STL_1_alloctor"},{"content":" content {:toc} 类内成员 1.1 类内的静态变量 static 优点:\nstatic的名字在类的作用域内, 是类的一部分, 而不是对象的一部分 static成员可以是私有成员 所有对象共享同一份数据 类内声明，类外初始化 在编译阶段分配内存 1.2 静态成员函数 在类中声明函数的前面加static就成了静态成员函数, 可以通过对象来访问, 也可以通过类名来访问 所有对象共享同一个函数 静态成员函数只能访问静态成员变量, 静态成员函数没有this指针，既然它没有指向某一对象，就无法对一个对象中的非静态成员进行默认访问 泛整型可以类内直接初始化，包括bool short int long等，其余类型包括float，double及string等都不可以。\n1 2 3 4 5 class A{ public: static int staint; }; int A::staint = 0; 1.3 操作符 重载 作用 : 对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n一般的重载运算符\n加号运算符重载 左移运算符重载 :: 可以输出自定义数据类型 递增运算符重载 赋值运算符重载 关系运算符重载 函数调用运算符重载 Note: :: .* . ?= 不能重载\n3 模板 3.1 模板简介 ​\t泛型编程就是以独立于任何特定类型的方式编写代码, 使用泛型程序时， 需要提供具体程序实例所操作的类型或值. ​\t泛型程序设计背后有一种隐含的共性：模板机制 ​\twhy: 除了类型之外， 其余代码看起来是相同的。\n包括:\n函数模板 类模板 3.2 函数模板 函数模板提供了一种函数行为，该函数行为可以用多重不同类型进行调用。也就是说，函数模板代表一个函数家族。\n1 2 3 4 5 6 7 8 9 10 11 12 //尖括号内的是 一个或者多个模板形参 //模板形参定义了特定类型的局部变量但是不初始化， 只有当运行时才初始化. template\u0026lt;typename T\u0026gt; int compare(const T \u0026amp;a, const T \u0026amp;b){ if(a \u0026lt;b) return -1; else if(a \u0026gt;b) return 1; else return 0; } //使用函数模板时, 编译器会自己推断哪个或者哪些模板实参绑定到形参 //一旦编译器确定了实际的模板实参， 就是, 实例化了函数模板的一个实例 cout\u0026lt;\u0026lt; compare(1, 0); 3.3 类模板 类模板与函数模板区别主要有两点：\n类模板没有自动类型推导的使用方式\n类模板在模板参数列表中可以有默认参数\n类模板中成员函数和普通类中成员函数创建时机是有区别的：\n普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建 3.4 类模板的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;class NameType, class AgeType = int\u0026gt; class Person{}; void test01(){ // 错误 类模板使用时候，不可以用自动类型推导 // Person p(\u0026#34;孙悟空\u0026#34;, 1000); //必须使用显示指定类型的方式，使用类模板 Person \u0026lt;string ,int\u0026gt;p(\u0026#34;孙悟空\u0026#34;, 1000); } void test02(){ //类模板中的模板参数列表 可以指定默认参数 Person \u0026lt;string\u0026gt; p(\u0026#34;猪八戒\u0026#34;, 999); } 3.5 类模板 做 函数参数 一共有三种传入方式：\n指定传入的类型 \u0026mdash; 直接显示对象的数据类型**( 最常用 )** 参数模板化 \u0026mdash; 将对象中的参数变为模板进行传递 整个类模板化 \u0026mdash; 将这个对象类型 模板化进行传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 template\u0026lt;class NameType, class AgeType = int\u0026gt; class Person{}; //1、指定传入的类型 void printPerson1(Person\u0026lt;string, int\u0026gt; \u0026amp;p){ p.showPerson(); } void test01(){ Person \u0026lt;string, int \u0026gt;p(\u0026#34;孙悟空\u0026#34;, 100); printPerson1(p); } //2、参数模板化 template \u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt;\u0026amp;p){ p.showPerson(); cout \u0026lt;\u0026lt; \u0026#34;T1的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T2的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; } void test02(){ Person \u0026lt;string, int \u0026gt;p(\u0026#34;猪八戒\u0026#34;, 90); printPerson2(p); } //3、整个类模板化 template\u0026lt;class T\u0026gt; void printPerson3(T \u0026amp; p){ cout \u0026lt;\u0026lt; \u0026#34;T的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl; p.showPerson(); } void test03(){ Person \u0026lt;string, int \u0026gt;p(\u0026#34;唐僧\u0026#34;, 30); printPerson3(p); } int main() { test01(); test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 3.6 类内的 模板对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;class T\u0026gt; class stack{ private: vector \u0026lt;T\u0026gt; elem(n); public: void pop(); void push(T); }; //可以有非模板类型参数, 非模板类型参数是有限制的, 可以是长整数, 或者指向外部链接对象的指针 template\u0026lt;class T, int max\u0026gt; stack{}; //在定义函数时, 模板定义了几个形参就要带着几个形参 template\u0026lt;class T, int max\u0026gt; stack :: pop(){ } 3.7 特化 有时候我们可能需要为某些特定类型或特定情况提供特殊的实现方式。这就是模板的特化的作用。 偏特化与完全特化类似，但存在一定的区别。完全特化是对模板的所有类型参数都进行具体化，而偏特化则只对其中的部分类型参数进行特化。所以偏特化以后, 依旧是 模板 偏特化的定义: 提供另一份 template 的定义式, 本是一就是templatized\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 泛化, 特化 template \u0026lt;class T, class Allocalloc\u0026gt; class vector { }; // 个数的偏特化 - 原来是两个模板参数, 现在是一个 // 针对某个类型做特别的优化 template\u0026lt;class Alloc\u0026gt; class vector\u0026lt;bool, Alloc\u0026gt; { }; //范围的偏特化 -指针类型 template\u0026lt;class T\u0026gt; class demo{}; template\u0026lt;class T\u0026gt; class demo\u0026lt;T*\u0026gt;{ }; ","date":"2023-07-25T21:19:24Z","permalink":"https://li54426.github.io/p/cpp_stl_o_basic/","title":"cpp_STL_O_basic"},{"content":" content {:toc} 天若 OCR调用 simpletex API\n记录一次使用别人的接口\n1 什么是天若 OCR 图片转文字准确率超高的办公利器 可以截图 可以翻译 可以识别公式 2 作者暴露出的部分接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //image：要识别的图片 public static string OCR_Custom(Image image) { //string url = \u0026#34;\u0026#34;; //string poststr =\u0026#34;\u0026#34;; //string result =CustomHelp.HttpPost(url,poststr); //获取请求获取解析结果后按照下面格式进行解析 TxtFormat.Root jsonRoot=new TxtFormat.Root(); jsonRoot.result=new List\u0026lt;TxtFormat.TextBlock\u0026gt;(); jsonRoot.isHasLocation=true;//判断是否含有坐标返回 for(int i=0; i\u0026lt;5; i++)//遍历返回的json字符串 { TxtFormat.TextBlock textBlock = new TxtFormat.TextBlock(); textBlock.Text = \u0026#34;公式测试文本\u0026#34;+i.ToString();//json内的文本 textBlock.TopLeft = new Point(0,0);//左上角坐标 textBlock.TopRight = new Point(0,0);//右上角坐标 textBlock.BottomRight =new Point(0,0);//右下角坐标 textBlock.BottomLeft =new Point(0,0);//左下角坐标 jsonRoot.result.Add(textBlock); } string json = JsonConvert.SerializeObject(jsonRoot); return json; } 一开始认为 CustomHelp.HttpPost()是一个具体的类, 但是也没有一个demo来说明各个参数的意义, 因此认为是伪码, 所以认为下面的也全是伪代码, 让我付出了惨重的代价 实际上就应该是一个具体的类, 因为后文的TxtFormat等也是具体的类, 但是没有使用说明, 就只能使用 HttpWebResponse库交换 http报文 3 天若开源版本的代码 猜测typeset_txt 就是显示的内容, 也是 接口中返回的原始字符串对应起来 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var img = image_screen; var inArray = OcrHelper.ImgToBytes(img); var s = \u0026#34;{\\t\\\u0026#34;formats\\\u0026#34;: [\\\u0026#34;latex_styled\\\u0026#34;, \\\u0026#34;text\\\u0026#34;],\\t\\\u0026#34;metadata\\\u0026#34;: {\\t\\t\\\u0026#34;count\\\u0026#34;: 0,\\t\\t\\\u0026#34;platform\\\u0026#34;: \\\u0026#34;windows 10\\\u0026#34;,\\t\\t\\\u0026#34;skip_recrop\\\u0026#34;: true,\\t\\t\\\u0026#34;user_id\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\t\\t\\\u0026#34;version\\\u0026#34;: \\\u0026#34;snip.windows@01.02.0027\\\u0026#34;\\t},\\t\\\u0026#34;ocr\\\u0026#34;: [\\\u0026#34;text\\\u0026#34;, \\\u0026#34;math\\\u0026#34;],\\t\\\u0026#34;src\\\u0026#34;: \\\u0026#34;data:image/jpeg;base64,\u0026#34; + Convert.ToBase64String(inArray) + \u0026#34;\\\u0026#34;}\u0026#34;; var bytes = Encoding.UTF8.GetBytes(s); var httpWebRequest = (HttpWebRequest)WebRequest.Create(\u0026#34;https://api.mathpix.com/v3/latex\u0026#34;); httpWebRequest.Method = \u0026#34;POST\u0026#34;; httpWebRequest.ContentType = \u0026#34;application/json\u0026#34;; httpWebRequest.Timeout = 8000; httpWebRequest.ReadWriteTimeout = 5000; httpWebRequest.Headers.Add(\u0026#34;app_id: mathpix_chrome\u0026#34;); httpWebRequest.Headers.Add(\u0026#34;app_key: 85948264c5d443573286752fbe8df361\u0026#34;); using (var requestStream = httpWebRequest.GetRequestStream()) { requestStream.Write(bytes, 0, bytes.Length); } var responseStream = ((HttpWebResponse)httpWebRequest.GetResponse()).GetResponseStream(); var value = new StreamReader(responseStream, Encoding.GetEncoding(\u0026#34;utf-8\u0026#34;)).ReadToEnd(); responseStream.Close(); var text = \u0026#34;$\u0026#34; + ((JObject)JsonConvert.DeserializeObject(value))[\u0026#34;latex_styled\u0026#34;] + \u0026#34;$\u0026#34;; split_txt = text; typeset_txt = text; 4 simpletex API 的python调用 使用 post 方法 1 2 3 4 5 6 7 8 import requests api_url=\u0026#34;https://server.simpletex.cn/api/latex_ocr/v2\u0026#34; # 接口地址 data = { } # 请求数据 header={ \u0026#34;token\u0026#34;: \u0026#34;\u0026#34; } # 鉴权信息，此处使用UAT方式 file=[(\u0026#34;file\u0026#34;,(\u0026#34;test.png\u0026#34;,open(\u0026#34;test.png\u0026#34;, \u0026#39;rb\u0026#39;)))] # 请求文件,字段名一般为file res = requests.post(api_url, files=file, data=data, headers=header) # 使用requests库上传文件 print(res.status_code) print(res.text) 1 2 3 4 5 6 7 { \u0026#34;status\u0026#34;: true/false, // 是否成功调用接口 \u0026#34;res\u0026#34;: { // 调用结果 ... }, \u0026#34;request_id\u0026#34;: \u0026#34;tr_xxxxxxxxxx\u0026#34; // 请求ID } 5 如何输出错误 发现 MessageBox.Show()能输出信息, 就用它来调试 1 MessageBox.Show(responseContent.ToString() ); 6 协议 post 的数据格式 边界符: boundary=AaB03x Post 中定义的换行符是 \\r\\n, 每一个边界符前面都需要加 2 个连字符 “\u0026ndash;”，然后跟上换行符。 使用Content-Type 指定发送或接收实体正文的媒体类型 Content-Type 由两部分组成，用斜杠分隔：媒体类型（media type）和子类型（subtype）。常见的媒体类型包括： text/plain：纯文本类型。 text/html：HTML 文档类型。 application/json：JSON 数据类型。 application/xml：XML 数据类型。 application/octet-stream : 二进制数据. image/jpeg：JPEG 图片类型。 audio/mpeg：MPEG 音频类型。 video/mp4：MP4 视频类型。 Content-Disposition：该头部字段用于指示如何处理包含在消息体中的数据。它可以指定将数据显示在浏览器窗口中、作为附件下载、保存到磁盘等行为。常见的值包括： inline：默认值，将数据在浏览器中显示。 attachment：将数据作为附件下载。 filename=\u0026lt;文件名\u0026gt;：指定下载时的文件名。 Content-Disposition: form-data; name=\u0026ldquo;file\u0026rdquo;; filename=\u0026ldquo;file1.dat\u0026rdquo;, 通常是用在客户端向服务端传送大文件数据，如：图片或者文件 使用 boundary来分隔文件 数据结束后的分界符，注意因为这个后面没有数据了所以需要在后面追加一个 “\u0026ndash;” 表示结束。 1 2 3 4 5 6 7 8 9 10 11 12 13 // 来自 https://blog.csdn.net/flymorn/article/details/6769722 Content-Type: multipart/form-data; boundary=AaB03x --AaB03x Content-Disposition: form-data; name=\u0026#34;submit-name\u0026#34; Larry --AaB03x Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;file1.dat\u0026#34; Content-Type: application/octet-stream ... contents of file1.dat ... --AaB03x-- 7 完整代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public static string OCR_Custom(Image image) {// Image 是一个类，它是用于处理图像和图形的基本类之一。 byte[] result; using (var memoryStream = new MemoryStream()) { image.Save(memoryStream, ImageFormat.Png); result = memoryStream.ToArray(); } // request string url = \u0026#34;https://server.simpletex.cn/api/latex_ocr/v2\u0026#34;; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url); request.ContentType = \u0026#34;multipart/form-data;boundary=---------------------------boundary\u0026#34;; request.Method = \u0026#34;POST\u0026#34;; request.Headers[\u0026#34;token\u0026#34;] = \u0026#34;\u0026#34;; string boundary = \u0026#34;---------------------------boundary\u0026#34;; byte[] boundaryBytes = Encoding.UTF8.GetBytes(\u0026#34;\\r\\n--\u0026#34; + boundary + \u0026#34;\\r\\n\u0026#34;); string formDataTemplate = \u0026#34;--{0}\\r\\nContent-Type:application/octet-stream\\r\\nContent-Disposition: form-data; name=\\\u0026#34;file\\\u0026#34;; filename=\\\u0026#34;image.png\\\u0026#34;\\r\\nContent-Type: image/png\\r\\n\\r\\n\u0026#34;; string formData = string.Format(formDataTemplate, boundary); byte[] formDataBytes = Encoding.UTF8.GetBytes(formData); // 设置请求体长度 request.ContentLength = formDataBytes.Length + result.Length + boundaryBytes.Length; // 将请求体数据写入请求流中 using (Stream requestStream = request.GetRequestStream()) { requestStream.Write(formDataBytes, 0, formDataBytes.Length); requestStream.Write(result, 0, result.Length); requestStream.Write(boundaryBytes, 0, boundaryBytes.Length); } // 发送请求并获取响应 HttpWebResponse response = (HttpWebResponse)request.GetResponse(); // 处理响应 string responseContent; using (StreamReader reader = new StreamReader(response.GetResponseStream())) { responseContent = reader.ReadToEnd(); // Console.WriteLine(responseContent); } response.Close(); var resultData = ((JObject)JsonConvert.DeserializeObject(responseContent)); var data = resultData[\u0026#34;res\u0026#34;]; var region = data[\u0026#34;latex\u0026#34;]; var text = \u0026#34;$\u0026#34; +region.ToString() + \u0026#34;$\u0026#34;; TxtFormat.Root jsonRoot=new TxtFormat.Root (); jsonRoot.result=new List\u0026lt;TxtFormat.TextBlock\u0026gt;(); jsonRoot.isHasLocation=true;// 判断是否含有坐标返回 TxtFormat.TextBlock textBlock = new TxtFormat.TextBlock (); textBlock.Text = text;//json 内的文本 textBlock.TopLeft = new Point (0,0);// 左上角坐标 textBlock.TopRight = new Point (0,0);// 右上角坐标 textBlock.BottomRight =new Point (0,0);// 右下角坐标 textBlock.BottomLeft =new Point (0,0);// 左下角坐标 jsonRoot.result.Add (textBlock); // `SerializeObject(object value)`：将对象序列化为 **JSON 字符串**。 return JsonConvert.SerializeObject (jsonRoot); } 记录一下用的接口 服务 免费额度 超出免费额度 并发请求数 百度通用文字识别 每月1000次（实名认证后） 0.0050元/次（开通付费后） 通用文字识别（高精度版） 每月1000次（实名认证后） 0.028元/次（开通付费后） 彩云小译API(在用) 每月100万字符 20元/100万字符 无相关说明 百度通用翻译API（标准版） 完全免费 1次/秒 百度通用翻译API（高级版） 每月200万字符 49元/100万字符 10次/秒 百度教育场景文字识别 每月500次（有效期365天, 后续资源付费） 1500元/万次（开通付费后） 腾讯数学试题识别()已经废弃 每月1000次 120元/1000次 ","date":"2023-07-25T21:19:24Z","permalink":"https://li54426.github.io/p/%E5%A4%A9%E8%8B%A5ocr%E8%B0%83%E7%94%A8simpletex/","title":"天若ocr调用simpletex"},{"content":" content {:toc} 一 简介 1 什么是markdown ​\tMarkdown是一种轻量级标记语言，创始人为约翰-格鲁伯（John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 ​\t由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub，Reddit，Diaspora，Stack Exchange，OpenStreetMap，SourceForge、简书等，甚至还能被使用来撰写电子书。\n\u0026mdash;\u0026mdash;-来自百度百科\n2 为什么我们需要markdown 在我们需要进行记笔记时, 我们对于格式( 例如, 字号, 段间距)并没有太大的要求, 反而对结构有要求, 例如标题是什么, 这个标题下有几个小标题, 对于我们的要求来讲, word 显得过于臃肿, markdown 是 latex 和 word 的一个 trade-off 因为他的轻量化, 导致他的格式固定, 使用不同的平台不会出现 word 那样不兼容的问题 因为是近几年才出现的( 04年 ), 能够更贴近这个时代, 例如md文件本身不保存图片, 这就可以使用网络上的图床, 让专业的人干专业的事 3 markdown 工具( 软件 ) Typora( 强推 )Typora 官方中文站、MacDown\n4 markdown 插件 1 2 markdown here [Markdown Here](https://markdown-here.com/) markdownload [markdownload](https://microsoftedge.microsoft.com/addons/detail/hajanaajapkhaabfcofdjgjnlgkdkknm) 二 markdown 语法 1 标题 \u0026lsquo;#\u0026rsquo; 号\u0026mdash;-生成文章的结构 后面需要一个空格 一个是一级标题, 两个是二级标题, 依次类推, 越少代表优先级越高, 被用来生成文章的结构, 我经常用###代表目录, ####代表子目录 1 2 3 ### 第一章 #### 第一章第一节 #### 第一章第二节 2 无序列表 1 使用- (注意后面有空格) 3 网址 1 2 3 [显示内容](网址) 例如上文的 [Typora 官方中文站](https://typoraio.cn/) 4 图片 1 2 3 4 5 6 7 ![图片名称]() ![image-20220906145334336](https://i0.hdslb.com/bfs/album/2f4f352c599fdd8c59177cd0aabd91db8c7dad15.png) # 图片 base 64 ![csdn图片Base64][csdn] [csdn]:data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAABYCAYAAABcS93LAAATuUlEQVR4Xu1dCXBc5ZH++h/5tjHmMjaXAVuyjTSaN/PkY55sK5tjgbBJCDjh2Cy7LMdWQsgCIZUKCRtvkU2RBRI24UhlKY5ANpCCLNcCGwIKmifZ0pt5MyMi27I4YogDwRjbeC0saV5v/bLkGkmjeceMnampv6soqvy6++/u/5v3+u+//18ERSoCVRQBqiJflCsqAlCAViCoqggoQFfVdCpnFKAVBqoqAgrQVTWdyhkFaIWBqoqAAnRVTadyRgFaYaCqIqAAXVXTqZxRgFYYqKoIKEBX1XQqZxSgFQaqKgIK0FU1ncoZBWiFgaqKgAJ0VU2nckYBWmGgqiKgAF1V06mcUYBWGKiqCChAV9V0KmcUoBUGqioCCtBVNZ3KGQVohYGqioACdFVNp3JGAVphoKoioABdVdOpnPmLAzrb0DBvJtFKB6hnYCmARQScyMAJAGYAmE6AYCAH4AAB+wHsYaL3mHkHAduIuddhTtW9+uqrBDilTev6UDT69umOELVwME8IzHYIc8A866BeGgQw/J+As59Be0nwBxgK7SSiHclk27so2YY8D9avD+FXv5K+VxKRpq05DuCFRM6xLDAPELMIPIMZRARm8H4G9oZYvAPQ9mSy7U9HwoEjDujHgJDW0NDsEP0NgLPBvAxEokzOfij27z9+SV/fAa/6GhtXn0QhOlcQrWNCBIzFIEzzKj+RjwcAvMZM3QTaJOA8mUy2vzaeL6ob1zBoBYPnEyQgeB5A8kczC+DpzKihkbgws0NEAyD0g7EL4PeZsYNIvA52+ojJnjbNyXR0dPQHt3uiZCy2ZkGOnHqScyTEUjAvBnA6gFMBTPU51l4AKTBeIaanUqlE0qe8J/YjBuieZctOq5ky5UoAlzFwsifr/DPtqstmj3UTW7SoZfoxxw9dzIwrAF4tX7tuMoGfM99uJ9u/Pl4+ohtbCKgLrHei4BBAnSB+3gGeyHSZvw+qW9PjDwF0NoDjg+pwlWNkiOjulLXgPqB8X6DDN5EjHvUtX744V1PzbQCXAJji6mhpDOm6bFYrokJoMeMqEL4DYGFpQ3mTZqKvpLsSdxcA9F4C5njTEoSLOon4P1Jd5n/5TYEiuvE+AccEGdW3DCETYnGVZbV1+pYtIHDYAP1OODxrL9HNzPw1oJRPuHc3CXiqNpv9bCGJBr35jBD4FwSs9K6xLJzn2pb5XL6m5ctbZk+bOfhhWbS7KqHNDHw5bSVaXVkBxGKxKQ5NlynbYcNGATs+cgiXZbrMx7zYWIznsBi9tbFxBTE/zMCSUg30JU90V10mc814mViseaVDzrMAuaYjvsbzwJwDlmYtc2s+aySydgnV5Ho9iJeHRebgoDtSSfMbALiYUrmmEFPE2+UZ2JeWHAPnpC3zN76kxjGXHdDbGhsvzzHfS4c/vZjgNxN9c2kmc2v+g7Bu1IUYHSC58DqyJBdz+/bMndnX99yYRarWFF8Lpt8dWWuG37m/sLvMLxVLQWKxVVGHQodlwebB3539YnDpls7O9z3wFmQpK6B7Gxq+A6INXIbPFQP7BbBP/p+Yh5hoJh0s4x3FQKiQNwRcUpvNypxxlISmGzI3iwUI0BAYbwLYDsI+ZuRAPJWGKxF81MjbXi6aZk6qm/FHO2lOWABrevwigPLtLKhipLrRL0uRfLCqUEL1ZXQIusO2EjdMZnO0qflsZh6TIgWIXXAR4tvtromLaK8KywborY2NN4D5Nq8Dj+OT9eTfMPAyiDbPHBzsO6WnZ1chXRLMvY2NJ9bkcgsc4AwIsYyBKDMbEOJzdZlMYlTOK3Dyx2HgfwG+u38avbTVNF3z3FgsNndITD+ZHJb18zMIWMqEswDSwMjYSXPteD+iunEdA3cUixUx35lKtl+f/zZdv359aPv27bMGB6cuYpFbTqCoA1wgx/URdyYhzkl1tr1QSCYSMy4jwgOu+ggPgtHGoNcc8J9CObErl5uxf2hogGbPDk0bGho4ySGuJ3LOBujCkT0FV7UA9n6wc8r8N99s/cgL83iesgC6NxL5NDvO0z4XEizBI5hvq+3ufjGI8eOAKNDSIqi1dWj03yN68zME/rRH3TK3vNK2zPs88ruxifDKloXZTa0T8tGIbvyAgBuLKWDgurRl/shtEPk8oq8xBJzb2eOCl4E3QvxRXTKZlBtEYyiqx7/BoDFpW0EbcjjJts0dXuzTNGMhQngQwCe88AP4rG2ZT3nkHcNWMqC3aNpCGhrKgnwtuGQg/q4um/1tEKO9ymi68WcftdQnbcv8nFfdpfBFdOPnBPxtcR18sW21/9LHOLIkeRMI/+pFhoguT3Ul7h/PqzXFbwPTpCnJCD8f2P/B9J6eHrmJ5IkWL148bc7R8+XXU3cVYHzfTprfcuUrwFAyoHsbGx9m5ks9D07Uhf7+c+t6e3d6lgnIqOmGfFsXzLcnqGS6x04mvhxwKF9imt78IsAfLypEosXuavO9cNRixvdB+KYHg0zbMpvH83n7sWG3bZm+F9kR3fgkDad0rvS0bZmfceUqN6C31NfrJIRcdHn6YTDz9qFcbmV9T887QYz1K6Ppxh+9b6DwHkBcaFuJktMfNzu1WHMPiJcV4ytU7nPTK5+3tLTU7Nk3KEuCcot6cmJ2BEInj++x0HRDAu6TRUWBrWnLlH03vmjEtt0Ht/eLjtBpW+2B9gs8AXGyoX2+nVkwG0u6uzt8RaEEZk1vfghgWabyQ11gehwhPG93JrJudVs/ikd5Nd34AMDRxWSnhobmbtq0SfY/+KaoblzNwL1ugszi/HSy7b/z+bSYkQEh7CLbalvmx9z0F3oe1Y0t7LrlT5ttK7E8iP7AgH5Nru4HB2WO6qlJhYGnl2azgT4jQRyTMmE9Xi+YLArebPQeM14WRL8dBF7sthKvB7VlVG716tUzPhoUsmOwGO23LdPlLTa5eDgcPyE0leRXsOj8Mvi7aat9wxhA64bsijux6PuT8Ug6abqsAQpr8NjD8nvbMuuDxDowoLfU13+BhHjU86DM59d1d495G3iWLYHRS4nMs3rmbSDxtMP8zLw5U9pa8yoqXnXILfga8ITuu3x5Bl5PW+aZXnUW4tM8ABNE99hdY9YNsm4vF3ou6w661bYSXvL0CaZpevNbALs1p3XZlrkiiP+BAd3b0HAvE13tcdAhPnDgmKVbt7rWdT3q88UWaTK+TowfuL2xfCkFdoDxoADfV6g9dDJdssRGcA7VyifhK7hg82OfFjPSIDQWl6Ff2lbi4lGe+pUr50/J1bivb5ivtZPtP/Zjj+QdyaFlfdltof68bZnn+NUv+QMDems43AZgwiq5oBHMfXXd3Ue2r2OcIbFY/FMOkcwriy+W/EcxR4SfO6HchvTGjXJnsShFYs3riditCedx2zLlZkRg0nTDctshZeDhtDW8FT5MjfpqTUCk3AflC22r/XF3vrEckciqRVQTesNNjhkPpJPmP7jxFXoeGNC94fA7DMz3MigRtdZmMoEWEV70e+UJh8OzxJQ51xLwz6DhEzHlpH4w32An2+8pplSLxa8F0Z3FeBi4K22ZE5qs/Bir6cY2ALIhvxj91LbMfxpliK5oPo8dlhtkxUlw3O5s9724j+jNLQR+2U09Af+Wssyb3PjKCuit4bBc2MjeClci4IXabFY2jFcEyYVZ/4C4lAjy7bSmlC/VeIeI6WepZOKqyRz1Uicm0LdTVuJ7QYM1svDc49Z/zuANaav9u4cA7bU6MpQ7PZ12/xqNtz8SNS4lgYfd/CLgqynL/IkbX7kBLTvIPFU4CNhYm83KkyEVR5FVqxZRruYzYJY52zqvP9JijhBoQ8pKHAJKPq/WZDwAxmUugbiilC34aNRYwwKvuAfbucS2Og41SWkxYwMIN7vI8Ye7353R5+OY26i+iG7cSBheyxQlIlyQ6jKfcOMrL6AbGnaAaIGXQQnYvSSbPbb0A6xeRgvOI99sAwNiVY54rQCtY2BVIIAzDgjwWYUWixHdeIGATxWzkpnPSyfbnw3qSbTJuJ8Zf+8mL9hZlkx2bBnl03TjPwH8o4vc+7ZlHuemu9DziG7cQcB1rrI5jtu2/5RG6g2cQ28Nh+VK3XA1boTBYW5Z1t3teyvXq/7DwXfy6tUzThgKrWPwRWC+GCBPX6RhW4hvsbva5VGvMRTRjW4CitZYBYtYMtnmYXE20evwirWnh5ycBGlRWxn8dtpqPyVfg6Ybsm3UJTWkbttKuG28FJwOTTdkb8oXXecqx4tsu/0PrnwFGAIDujcc/iHLxZVHIubW2u7uv/jC0KO5E9ii0TVhFk67+7btIdGCu2mabsgeluInZ3x0suUbOtIAJKtPTR78/IltmV8dC+jmLMANRWWZXrCTiUDrIS1mvAIaXrMUI9+NT/nKAgO6r7HxYznmlzwE7hCLAK5Yks2Wqz3Tz9Bl4fWSLuQNZNmWOQZYI4CTVw1MGnfZ1H/0nKnT/G7aSN1HzZ3/EBO+4MVZwU44mezozuf1cjiWQfenrcTlXsYYz+Ox8rLTtszAp80DA5oB0RsO9/mp65K8LIboytpMZkLbYpAAHWEZ2Z75GgiLvIzLQCJtmWPeRpoWPw0hKl6rZvzZTpqeyqGjdoycA5S7tp5SQAI9m7IS5+X7sailZfq8fYOyclUUE6WU1DTd+L+iJ3wOGpS1LdNlQ2jyGQgMaKlyWzh8hQP8zMsEj/ssPBMS4voz02lZKy07yfQgR85RmaQpU4QSb1I6aF5Ej/8LgQpWLgo5UKiWrGnx1QiRtGlyOnjKJeIlKHV1xpyZs+lrIJbb0F57PwbIyUVSqY2b88eIxeJnOkTyBVWUCHRNykrc5cY3/nks9om5DvXLTjs3CrxLKBWXBOjh41DhsAmPJyXGeMLsgKg9RPToAHP7jGOO6Tm91f3YzR8aGub1M59JodAyYtaJ+aUl3d1P5uuO6vGbGHQLA7tA+J1gdAw5nJxCU7PJZKuvPmxthaFTDt9iwvluM5H/3GH8VSZpjtlEiDYZn2dG8R025hfsZPukOerKlSvnD+RqVjKwnjBsk1cgD5vHhBvTXeaEo3KaFl+LkPvB3aAltWh07TIWuR63GJaS0pQMaKlgc2NjLTFvPHidVUkk7297E8y7QCQPx+6T94Ox3Lxhngui4wk4gccdSiXgwtpsdgxIInr8pwSabHNjNwFvyGNIBGxnxl4aPgTL+1hgCBAzBbMcRzYHydq5vPbKL3XYlhkfLxTVm7/CYLcNA5ljy1uPdjAPx4AdQXOJeR4BpzIwpjLhxzAiPJbqMi8q1BLr9fwlOVidSpkb/YwreTVtzccRclx7zQn0vZSVkBcTBaKS3tCjI27TtHWcy/3PeLAFssinEAvRvDSdll+JQ6TF4s+D6K99qioPO2OfI7Cq0FVcUb35FgYH2tItg3FPC/7ogkLnCIcBF2u+AeR+yFkwTksmze1+7dH05i8B/JCbHIOuSQdIaUb1lgXQUtmWSMQgx5EHG4/MFVIjHhDzmbXd3WP6lDU93gNQ0RMhboEN8pwZBwC+YLJNEU2P3wdQoApBEHtGZOR9oD+2uxZcX+wOOU1vvh1gecq8GAUuqXk9fOs49PlMKvHroP6WDdDSgB5NOy2Uy8m9em9deEGtzpObOWvWzFPG3bqp6cY+v7llqaYw+F2i0BeLnQP0tnFRqiVj5HeQQ1enUoln3LR63PR4z7bMQE1dkVj8R0Qkr4UrSjmmVdlkYpMb32TPywpoOYgs5/WFw5c7wC3w2I1XgvG7a7PZMbl7LNZynEOD7wXVGUBOXsfwiDPAN2Sz7fIEz6TkrUc5gAUTRHgPmO480D/l33t6WuWP25UiutFGbi8iHxWY8QNGYsaj5KFGPkihU1/teuUtV4MnYSg7oEfH2RGLzfxwcFD2E1wL1zNkwcwnYHNtNjvm7Fljk3EWOZwdvVs5mGYPUjK9IHoCArfanYmMBwloMePdw9C2Ojq0/GF1EvMj+6fTA14uycm3WdMNmba59YoHLql5+8HIg7sHpk+W53uJ8WEDdP7gmxsaYkKIC8EsLxqR1926nVjwYjvA/Fhdd/eE3oCmprWnDME5H8xnM9Bcxmtr9zKoDURPhpzQr32WAElran4OjnMGQKeWdqn6cHjkAVpZDckScSJXwy9nOjrkKfdAFNWNH4KL96o44M500pQXxvgmrcm4mRwqumHEQL+dTEy4S9vPYEcE0PkGbVu8+CieMSPCRPUE1IJoITPLrr25BEwfvb8t/09QsPwTFMAuInqHHWd7iEg236SWZLNebskUjU3GMnKokQQvlddmMeMUef8xM2aDMFvm28wQIAwQo58JHxD4fYDeAoZ39nogkLE7F7xapsu5KRJpmYtp/ceLwZpjHSH/5IWYJYQzKweeSg6FCPIGf/mnHQ7+CQxm+pDh7HHg7Azlpr2VTrd62aTwg4Wq4D3igK6KqCknKjYCCtAVOzXKsCARUIAOEjUlU7ERUICu2KlRhgWJgAJ0kKgpmYqNgAJ0xU6NMixIBBSgg0RNyVRsBBSgK3ZqlGFBIqAAHSRqSqZiI6AAXbFTowwLEgEF6CBRUzIVGwEF6IqdGmVYkAgoQAeJmpKp2AgoQFfs1CjDgkRAATpI1JRMxUZAAbpip0YZFiQCCtBBoqZkKjYCCtAVOzXKsCARUIAOEjUlU7ERUICu2KlRhgWJgAJ0kKgpmYqNgAJ0xU6NMixIBBSgg0RNyVRsBBSgK3ZqlGFBIqAAHSRqSqZiI6AAXbFTowwLEoH/B5Gu0rNlwMl/AAAAAElFTkSuQmCC 5 代码 使用```(数字1前面的那个)\n6 引用 1 \u0026gt; (小于号) 三 markdown 与浏览器交互 3.1 markdown here\u0026mdash;\u0026mdash;将markdown上传为 html 格式 下载地址：Markdown Here微软商店下载地址\n使用方法 : 点击插件图标或者是, alt + ctrl + M (动画在下面)\nGIF 2022-9-11 20-27-10 设置格式 : 右键浏览器插件图标 -\u0026gt; 扩展选项-\u0026gt; 基本渲染CSS\n还可以使用 latex公式使用$$包裹起来\n3.2 将网页下载为markdown 下载地址：markdownload_微软商店下载 使用方法: 点击图标 -\u0026gt; Download\n四 图床 有了图床的 markdown 才是完整的markdown\n1 介绍 图床（Image Hosting Service）是一种用于存储和分享图片的在线服务。它允许用户上传图片文件，并生成一个可访问的 URL 地址，用户可以通过该地址在网页上或其他平台上分享图片。图床通常提供免费和付费两种服务，用户可以根据需要选择合适的方案使用。\n图床的主要功能包括：\n图片存储：用户可以将图片文件上传到图床服务器上进行存储，这些图片文件可以是网页中的配图、产品图片、个人照片等。 图片分享：图床为用户生成的图片 URL 地址可以方便地在网页、论坛、社交媒体等平台上分享图片内容，用户只需复制图片链接即可。 图片管理：图床通常提供图片管理功能，允许用户对上传的图片进行管理，包括查看、编辑、删除等操作。 图片处理：一些高级图床服务还提供图片处理功能，如裁剪、旋转、压缩等，使用户可以在图床上直接对图片进行编辑处理。 使用图床的好处包括：\n节省空间：通过将图片上传到图床服务器，可以减轻自己网站或应用的服务器负担，节省存储空间。 加快加载速度：使用图床存储图片可以加速网站或应用的加载速度，因为图床通常会使用 CDN（内容分发网络）技术，将图片文件分发到全球各地的服务器节点，使用户可以从距离更近的服务器获取图片，从而加快加载速度。 方便分享：图床生成的图片 URL 地址可以方便地在各种平台上分享图片内容，无需担心图片被删除或地址失效的问题。 总的来说，图床是一个方便的在线服务，可以帮助用户轻松存储、管理和分享图片。\n2 picgo PicGo 是一个开源的图片上传工具，可以帮助用户快速上传图片到图床并生成图片链接。它提供了简洁友好的图形界面，支持多种图床服务，并且具有丰富的配置选项和插件扩展功能。可以帮助用户快速、便捷地上传和管理图片，并生成图片链接用于分享或嵌入网页。\nPicGo 的主要特点和功能有：\n支持多种图床服务：PicGo 支持丰富的图床服务，包括但不限于 GitHub、七牛云、阿里云、腾讯云、Imgur 等。用户可以根据自己的需求选择合适的图床服务进行配置和使用。 多种上传方式：PicGo 提供了多种上传方式，包括拖拽上传、剪贴板上传、截图上传等。用户可以根据自己的习惯和需求选择合适的上传方式。 支持快捷键操作：PicGo 支持自定义快捷键，用户可以通过快捷键实现快速上传图片、截图等操作，提高工作效率。 自定义命名规则：PicGo 支持用户自定义图片文件名的命名规则，包括时间格式、文件名格式等，使用户可以根据自己的需求对上传的图片进行命名。 图片处理功能：PicGo 提供了一些简单的图片处理功能，如图片压缩、图片裁剪等，用户可以在上传图片之前对图片进行简单的处理。 丰富的插件扩展：PicGo 支持插件扩展，用户可以根据自己的需求安装各种插件，扩展 PicGo 的功能和特性，例如支持更多图床服务、添加更多上传方式等。 跨平台支持：PicGo 支持 Windows、macOS 和 Linux 等多个平台，用户可以在不同的操作系统上使用相同的工具和配置。 开源免费：PicGo 是开源项目，用户可以自由获取、使用和修改源代码，完全免费。 配置手册 | PicGo\n3 B站图床picgo 插件 插件在线安装\n打开 PicGo 详细窗口，选择 插件设置，搜索 bili 安装，然后重启应用即可。 使用方法\n找cookie中的 SESSDATA 还有 bli_jct 复制即可 实现原理\n将图片存在一个 B 站的公共静态资源空间。 举例：所有人上传的图片都会放在这个空间里面，但是你不发布动态的话，那么这个资源与你就没有绑定关系，那么你自然是找不到的。你发布了的话，你的这条动态就会跟这个图片资源绑定关系，那么查看的时候，就知道这个动态绑定了哪些图片链接，就可以看到对应的图片了。 4 其他哔哩哔哩图床软件推荐 浏览器插件 - Bilibili 图床 Typora 插件 - Bilibili 图床 五 typora 1 主题 主题获取网站 Themes Gallery — Typora\n然后打开我们的 Typora 和 -\u0026gt; 文件 -\u0026gt; 偏好设置 -\u0026gt; 外观 -\u0026gt; 打开主题文件夹，将解压好的文件拖到这个 Typora 的主题文件夹\n注意：不能解压到单独的文件夹，直接将解压的文件拖到主题文件夹中，否则会不识别\n","date":"2023-07-23T14:21:18Z","permalink":"https://li54426.github.io/p/%E6%B0%B8%E8%BF%9C%E7%83%AD%E7%88%B1markdown/","title":"永远热爱markdown"},{"content":" content {:toc} 2788. 按分隔符拆分字符串 - 力扣（LeetCode） 给你一个字符串数组 words 和一个字符 separator ，请你按 separator 拆分 words 中的每个字符串。\n返回一个由拆分后的新字符串组成的字符串数组，不包括空字符串 。\n注意\nseparator 用于决定拆分发生的位置，但它不包含在结果字符串中。 拆分可能形成两个以上的字符串。 结果字符串必须保持初始相同的先后顺序。 1 2 3 4 5 6 7 8 9 输入：words = [\u0026#34;one.two.three\u0026#34;,\u0026#34;four.five\u0026#34;,\u0026#34;six\u0026#34;], separator = \u0026#34;.\u0026#34; 输出：[\u0026#34;one\u0026#34;,\u0026#34;two\u0026#34;,\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;five\u0026#34;,\u0026#34;six\u0026#34;] 解释：在本示例中，我们进行下述拆分： \u0026#34;one.two.three\u0026#34; 拆分为 \u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34; \u0026#34;four.five\u0026#34; 拆分为 \u0026#34;four\u0026#34;, \u0026#34;five\u0026#34; \u0026#34;six\u0026#34; 拆分为 \u0026#34;six\u0026#34; 因此，结果数组为 [\u0026#34;one\u0026#34;,\u0026#34;two\u0026#34;,\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;five\u0026#34;,\u0026#34;six\u0026#34;] 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 vector\u0026lt;string\u0026gt; splitWordsBySeparator(vector\u0026lt;string\u0026gt;\u0026amp; words, char c) { vector\u0026lt;string\u0026gt; res; for(auto \u0026amp; s : words){ // 字符串左侧包括 l int l = 0; for(int i = 0; i\u0026lt; s.size(); ++i){ if(s[i] == c ){ if(i - l \u0026gt; 0){ res.push_back(s.substr(l, i-l)); } l = i+1; } // 处理最后不为 c 的情况 if(i == s.size() - 1 \u0026amp;\u0026amp; s[i] != c ){ res.push_back(s.substr(l, i- l+1)); } } } return res; } class Solution { public: vector\u0026lt;string\u0026gt; splitWordsBySeparator(vector\u0026lt;string\u0026gt;\u0026amp; words, char separator) { vector\u0026lt;string\u0026gt; res; for(int i = 0;i\u0026lt;words.size();i++){ istringstream iss(words[i]);\t// 输入流 string token;\t// 接收缓冲区 while (getline(iss, token, separator)){// 以split为分隔符 if(token.size()!=0) res.push_back(token); } } return res; } }; 作者：知忆梦往昔 链接：https://leetcode.cn/problems/split-strings-by-separator/solutions/2361633/jie-he-istringstreamhe-getlinefang-fa-sh-scem/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1 2 3 4 #include \u0026lt;sstream\u0026gt; // 构造函数 istringstream::istringstream(string str); 2790. 长度递增组的最大数目 - 力扣（LeetCode） 给你一个下标从 0 开始、长度为 n 的数组 usageLimits 。\n你的任务是使用从 0 到 n - 1 的数字创建若干组，并确保每个数字 i 在 所有组 中使用的次数总共不超过 usageLimits[i] 次。此外，还必须满足以下条件：\n每个组必须由 不同 的数字组成，也就是说，单个组内不能存在重复的数字。 每个组（除了第一个）的长度必须 严格大于 前一个组。 在满足所有条件的情况下，以整数形式返回可以创建的最大组数。\n1 2 3 4 5 6 7 8 9 输入：usageLimits = [1,2,5] 输出：3 解释：在这个示例中，我们可以使用 0 至多一次，使用 1 至多 2 次，使用 2 至多 5 次。 一种既能满足所有条件，又能创建最多组的方式是： 组 1 包含数字 [2] 。 组 2 包含数字 [1,2] 。 组 3 包含数字 [0,1,2] 。 可以证明能够创建的最大组数是 3 。 所以，输出是 3 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int maxIncreasingGroups(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 贪心的想, 让次数**更少**的元素在长度**更长**的分组中 // 本题最关键的一点是，单个组横着看，最优解是每一行的元素都不同，但竖着看就会发现最优解的情况是优先一列全部取一样的数字 sort(nums.begin(),nums.end());//先递增排序； // * // ** // *** long long sum = 0; int res = 0; int len = nums.size(); for(int i = 0; i\u0026lt;len; ++i){ sum += nums[i]; if(sum \u0026gt;= 1LL * (res + 1) * (res + 2) / 2){ res ++; } } return res; } ","date":"2023-07-23T13:55:12Z","permalink":"https://li54426.github.io/p/%E7%AC%AC355%E5%9C%BA%E5%91%A8%E8%B5%9B/","title":"第355场周赛"},{"content":" content {:toc} cpp感想(1)\u0026mdash;指针 版本号: V1.2\n1 第一版本感想 一开始认为只是一个存储地址的变量, 但是发现有些片面了\n2 第二版感想 想了很久发现, 没有一个词能够很好的形容指针, 感觉协议还靠边一点\n协议, 协议就是一些特殊的规则集合\n指针 是我们自己定义的操纵内存的接口\n我现在的理解就是 指针 = 地址 + 协议\n地址是指在内存中的位置, 协议是指如何管理指向的内存,\n2.1 void指针 ​\tvoid指针不是空指针, 而是可以没有约束( 协议 )的指针, 任何指针指都可以赋值给他, 但是不能用void指针进行操作, 要转换后才能进行操作 ​\t因为void*可以接受任何类型指针，就是所谓的上转型（upcasting），将一个更具体的指针转换成一个类型更泛化的指针。编译器知道这种类型转换并不会带来风险。如果进行下转型（downcasting），就告诉编译器，我现在有一个类型更加泛化的指针，我知道此指针具体类型是什么，但是如果涉及引用就想要进行强制转换。\n1 2 char a[10]; void *b = a; 2.2 malloc 函数 malloc 函数 返回的指针就是void * 类型, 也就是没有协议的类型\n2.3 链表\u0026mdash;来自数据结构 1 2 3 4 typedef struct Listnode{ datatype data; struct Listnode *next; }listnode; 为什么可以做到嵌套定义 :\nListnode 类型的变量可以有两个元素, 一个是数据域, 另一个是指针.这两个的大小和组织形式都是固定的, 例如, datatype为int时, 占据8个字节, 指针一般占据8个字节. 这就占据16个字节. Listnode 指针的协议就可以这么来描述: 大小为16个字节, 类内元素排列是 int ( 8 )+ 指针 ( 8 ) 2.4 obj\u0026mdash;来自SGIGCC2.9 1 2 3 4 5 union obj { union obj * free_list_link; char client_data[1]; /* The client sees this. */ }; //其实就是告诉指针, 这块内存中存储的是个地址, 并且占用8个字节的内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct listnode{ listnode *next; }; typedef struct listnode listnode; int main() { // your code goes here listnode a,b; a.next = \u0026amp;b; cout\u0026lt;\u0026lt; \u0026#34;sizeof listnode = \u0026#34;\u0026lt;\u0026lt; sizeof(listnode)\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;the address of a =\u0026#34;\u0026lt;\u0026lt; \u0026amp;a\u0026lt;\u0026lt; \u0026#34;the address of b =\u0026#34;\u0026lt;\u0026lt; \u0026amp;b\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;the a.next = \u0026#34;\u0026lt;\u0026lt; a.next \u0026lt;\u0026lt;endl; return 0; } /* sizeof listnode = 8 the address of a =0x7ffc8f28fcf8 the address of b =0x7ffc8f28fd00 the a.next = 0x7ffc8f28fd00 */ 2.5 short和int\u0026mdash;来自编程范式(视频) 1 2 3 4 5 6 int arr[5]; arr[3]= 128; ((short*)arr)[6]= 2; //arr被重新解释成2bytes的short型，此时，之前赋值128的地方变为arr[7] //因为short占用的字节小, 因此你可以通过short指针的方式来进行操控一部分内存 ","date":"2023-07-03T23:13:54Z","permalink":"https://li54426.github.io/p/c-%E6%84%9F%E6%83%B3%E4%B9%8B%E6%8C%87%E9%92%881/","title":"c++感想之指针1"},{"content":" Github Action 官方文档：https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#name\n是 Github 推出的持续集成工具\n持续集成是什么？ 简单说就是自动化的打包程序 —— 如果是前端程序员，这样解释比较顺畅：\n每次提交代码到 Github 的仓库后，Github 都会自动创建一个虚拟机（Mac / Windows / Linux 任我们选），来执行一段或多段指令（由我们定），例如：\nnpm install npm run build Yaml 是什么？ 我们集成 Github Action 的做法，就是在我们仓库的根目录下，创建一个 .github 文件夹，里面放一个 *.yaml 文件 —— 这个 Yaml 文件就是我们配置 Github Action 所用的文件。\n它是一个非常容易地脚本语言，如果我们不会的话，也没啥大事继续往下看就成了。\n参考文档：五分钟学习 YAML\nGithub Action 的使用限制 每个 Workflow 中的 job 最多可以执行 6 个小时 每个 Workflow 最多可以执行 72 小时 每个 Workflow 中的 job 最多可以排队 24 小时 在一个存储库的所有 Action 中，一个小时最多可以执行 1000 个 API 请求 并发工作数：Linux：20，Mac：5（专业版可以最多提高到 180 / 50） 什么是 Workflow？ Workflow 是由一个或多个 job 组成的可配置的自动化过程。我们通过创建 YAML 文件来创建 Workflow 配置。\n一、如何定义 Workflow 的名字？ name\nWorkflow 的名称，Github 在存储库的 Action 页面上显示 Workflow 的名称。\n如果我们省略 name，则 Github 会将其设置为相对于存储库根目录的工作流文件路径。\n1 name: Greeting from Mona on: push 二、如何定义 Workflow 的触发器？ on\n触发 Workflow 执行的 event 名称，比如：每当我提交代码到 Github 上的时候，或者是每当我打 TAG 的时候。\n1 // 单个事件 on: push // 多个事件 on: [push,pull_request] 事件大全：https://docs.github.com/en/actions/reference/events-that-trigger-workflows#about-workflow-events\n三、Workflow 的 job 是什么？ 答：一个 Workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。\n1、如何定义一个 job？ 1 jobs: my_first_job: name: My first job my_second_job: name: My second job 答：通过 job 的 id 定义。\n每个 job 必须具有一个 id 与之关联。\n上面的 my_first_job 和 my_second_job 就是 job_id。\n2、如何定义 job 的名称？ jobs.\u0026lt;job_id\u0026gt;.name\nname 会显示在 Github 上\n3、如何定义 job 的依赖？job 是否可以依赖于别的 job 的输出结果？ jobs.\u0026lt;job_id\u0026gt;.needs\n答：needs 可以标识 job 是否依赖于别的 job—— 如果 job 失败，则会跳过所有需要该 job 的 job。\n1 jobs: job1: job2: needs: job1 job3: needs: [job1, job2] jobs.\u0026lt;jobs_id\u0026gt;.outputs：用于和 need 打配合，outputs 输出 =》need 输入\njobs 的输出，用于和 needs 打配合：可以看到 ouput\n1 jobs: job1: runs-on: ubuntu-latest # Map a step output to a job output outputs: output1: ${{ steps.step1.outputs.test }} output2: ${{ steps.step2.outputs.test }} steps: - id: step1 run: echo \u0026#34;::set-output name=test::hello\u0026#34; - id: step2 run: echo \u0026#34;::set-output name=test::world\u0026#34; job2: runs-on: ubuntu-latest needs: job1 steps: - run: echo ${{needs.job1.outputs.output1}} ${{needs.job1.outputs.output2}} 4、如何定义 job 的运行环境？ jobs.\u0026lt;job_id\u0026gt;.runs-on\n指定运行 job 的运行环境，Github 上可用的运行器为：\nwindows-2019 ubuntu-20.04 ubuntu-18.04 ubuntu-16.04 macos-10.15 1 jobs: job1: runs-on: macos-10.15 job2: runs-on: windows-2019 5、如何给 job 定义环境变量？ jobs.\u0026lt;jobs_id\u0026gt;.env\n1 jobs: job1: env: FIRST_NAME: Mona 6、如何使用 job 的条件控制语句？ jobs.\u0026lt;job_id\u0026gt;.if\n我们可以使用 if 条件语句来组织 job 运行\n四、Step 属性是什么？ 答：每个 job 由多个 step 构成，它会从上至下依次执行。\nstep 运行的是什么？ step 可以运行：\ncommands：命令行命令 setup tasks：环境配置命令（比如安装个 Node 环境、安装个 Python 环境） action（in your repository, in public repository, in Docker registry）：一段 action（Action 是什么我们后面再说） 每个 step 都在自己的运行器环境中运行，并且可以访问工作空间和文件系统。\n因为每个 step 都在运行器环境中独立运行，所以 step 之间不会保留对环境变量的更改。\n1 # 定义 Workflow 的名字 name: Greeting from Mona # 定义 Workflow 的触发器 on: push # 定义 Workflow 的 job jobs: # 定义 job 的 id my-job: # 定义 job 的 name name: My Job # 定义 job 的运行环境 runs-on: ubuntu-latest # 定义 job 的运行步骤 steps: # 定义 step 的名称 - name: Print a greeting # 定义 step 的环境变量 env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat # 运行指令：输出环境变量 run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 五、Action 是什么？ 我们可以直接打开下面的 Action 市场来看看：\nAction 其实就是命令，比如 Github 官方给了我们一些默认的命令：\n比如最常用的，check-out 代码到 Workflow 工作区：\n1、我们应该如何使用 Action？ jobs.\u0026lt;job_id\u0026gt;.steps.uses\n比如我们可以 check-out 仓库中最新的代码到 Workflow 的工作区：\n1 steps: - uses: actions/checkout@v2 当然，我们还可以给它添加个名字：\n1 steps: - name: Check out Git repository uses: actions/checkout@v2 再比如说，我们如果是 node 项目，我们可以安装 Node.js 与 NPM：\n1 steps: - uses: actions/checkout@v2 - uses: actions/setup-node@v2-beta with: node-version: \u0026#39;12\u0026#39; 2、上面我们为什么要用：@v2 和 @v2-beta 呢？ 答：首先，正如大家所想，这个 @v2 和 @v2-beta 的意思都是 Action 的版本。\n我们如果不带版本号的话，其实就是默认使用最新版本的了。\n但是 Github 官方强烈要求我们带上版本号 —— 这样子的话，我们就不会出现：写好一个 Workflow，但是由于某个 Action 的作者一更新，我们的 Workflow 就崩了的问题。\n3、上面的 with 参数是什么意思？ 答：有的 Action 可能会需要我们传入一些特定的值：比如上面的 node 版本啊之类的，这些需要我们传入的参数由 with 关键字来引入。\n具体的 Action 需要传入哪些参数，还请去 Github Action Market 中 Action 的页面中查看。\n具体库的使用和参数，我们可以去官方的 Action 市场查看：\n六、我们如何运行命令行命令？ 上文说到，steps 可以运行：action 和 command-line programs。\n我们现在已经知道可以使用 uses 来运行 action 了，那么我们该如何运行 command-line programs 呢？\n答案是：run\nrun 命令在默认状态下会启动一个没有登录的 shell 来作为命令输入器。\n1、如何运行多行命令？ 每个 run 命令都会启动一个新的 shell，所以我们执行多行连续命令的时候需要写在同一个 run 下：\n单行命令 1 - name: Install Dependencies run: npm install 多行命令 1 - name: Clean install dependencies and build run： | npm ci npm run build 2、如何指定 command 运行的位置？ 使用 working-directory 关键字，我们可以指定 command 的运行位置：\n1 - name: Clean temp directory run: rm -rf * working-directory: ./temp 3、如何指定 shell 的类型？（使用 cmd or powershell or python？？） 使用 shell 关键字，来指定特定的 shell：\n1 steps: - name: Display the path run: echo $PATH shell: bash 下面是各个系统支持的 shell 类型：\n七、什么是矩阵？ 答：就是有时候，我们的代码可能编译环境有多个。比如 electron 的程序，我们需要在 macos 上编译 dmg 压缩包，在 windows 上编译 exe 可执行文件。\n这种时候，我们使用矩阵就可以啦～\n比如下面的代码，我们使用了矩阵指定了：2 个操作系统，3 个 node 版本。\n这时候下面这段代码就会执行 6 次 —— 2 x 3 = 6！！！\n1 runs-on: ${{ matrix.os }} strategy: matrix: os: [ubuntu-16.04, ubuntu-18.04] node: [6, 8, 10] steps: - uses: actions/setup-node@v1 with: node-version: ${{ matrix.node }} 下一篇文章：《实战：electron 通过 Github Action 自动打包，并上传到 Github 的 release 中》 敬请期待！！！！！\n","date":"0001-01-01T00:00:00Z","permalink":"https://li54426.github.io/p/","title":""},{"content":"那该怎么获得最最一手的版本呢？嘿嘿，GitHub 上有源码，咱们完全可以自己编译打包。\n当然，当然，如果是从头开始打包，那不得搞个 Android Studio 自己慢慢折腾？\n感觉光安装编译工具就能劝退 90% 的小伙伴了，所以这里肯定不是这种传统的编译教程，而是取个巧，通过白嫖 GitHub 来一键打包。\nGitHub Actions，这是 GitHub 为开发者准备的跑脚本的服务，你可以简单理解成 GitHub 准备了一个开箱即用的远程虚拟机。\n虽然免费账号有限制，但对于打包一个 apk 绰绰有余了。\n具体操作是 ——\n1、登录自己的 GitHub 账号，然后 Fork 一下项目源码，在跳转页点「Create fork」就好了。\n地址：github.com/bggRGjQaUbCoE/c001apk\n2、Fork 成功后，在咱们自己的仓库里，点击「Actions」，并启用。\n3、然后运行脚本。\n等脚本跑完，也就是那个对号出现，咱们点进去。\n这里有个「build」的选项，再点进去。\n在「Upload release」里，就能找到打包好的 apk 文件了。\n把压缩包下载下来，解压后就能在手机上安装了。\n就是这么简单，唯一的难点，大概就是搞定 GitHub 的网络问题了。\n结语\n好了，这就是今天的全部内容了，既分享了 c001apk 这个开源的第三方客户端，又分享了 GitHub 一键打包的方案。\n我顺便把最新版的 c001apk 分流到了蓝奏云，老规矩，有需要的小伙伴自取就好。\n地址：wwx.lanzouj.com/iMu6a1tmliob\n授人以鱼也授人以渔，希望能帮到大家。\n","date":"0001-01-01T00:00:00Z","permalink":"https://li54426.github.io/p/","title":""},{"content":"20240407\u0026mdash;\u0026mdash;392 3105. 最长的严格递增或递减子数组 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: int longestMonotonicSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(); vector\u0026lt;int\u0026gt; n(nums.size(), 1); int plus = 1; int res =1; for(int i = 1; i\u0026lt; len; ++i){ if(nums[i]\u0026gt; nums[i-1]){ n[i] = n[i-1]+1; res = max(res, n[i]); } } vector\u0026lt;int\u0026gt; m(nums.size(), 1); for(int i = 1; i\u0026lt; len; ++i){ if(nums[i]\u0026lt; nums[i-1]){ m[i] = m[i-1]+1; res = max(res, m[i]); } } return res; } }; 3106. 满足距离约束且字典序最小的字符串 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: // 问题等价于，寻找一个字典序最小的，编辑距离d \u0026lt;= k的字符串 string getSmallestString(string s, int k) { // 26个英文字母 vector\u0026lt;int\u0026gt; change(26, 0); for(int i = 0; i\u0026lt; 13; ++i){ change[i] = i; } for(int i = 13; i\u0026lt;26; ++i){ change[i] = 26-i; } // 0 1 2 3 4 5 6 7 8 9 10 11 12 13 12 11 10 9 8 7 6 5 4 3 2 1 // for(auto n: change){ // cout\u0026lt;\u0026lt; n\u0026lt;\u0026lt; \u0026#39; \u0026#39;; // } int len = s.size(); for(int i = 0; i\u0026lt; len; ++i){ if(k == 0){ break; } if(k \u0026gt;= change[s[i] - \u0026#39;a\u0026#39;]){ k -= change[s[i] - \u0026#39;a\u0026#39;]; s[i] = \u0026#39;a\u0026#39;; }else{ s[i] -=k; k = 0; } } return s; } }; 3107. 使数组中位数等于 K 的最少操作数 - 力扣（LeetCode）\n给你一个整数数组 nums 和一个 非负 整数 k 。一次操作中，你可以选择任一元素 加 1 或者减 1 。\n请你返回将 nums 中位数 变为 k 所需要的 最少 操作次数。\n一个数组的中位数指的是数组按非递减顺序排序后最中间的元素。如果数组长度为偶数，我们选择中间两个数的较大值为中位数。\n示例 1：\n**输入：**nums = [2,5,6,8,5], k = 4\n**输出：**2\n**解释：**我们将 nums[1] 和 nums[4] 减 1 得到 [2, 4, 6, 8, 4] 。现在数组的中位数等于 k 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: long long minOperationsToMakeMedianK(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { sort(nums.begin(), nums.end()); long long res = 0; int len = nums.size(); int m = len/2; if(nums[m] \u0026gt; k){ for(int i = m; i\u0026gt; -1 \u0026amp;\u0026amp; nums[i] \u0026gt;k ; i--){ res += nums[i] - k; } }else{ for(int i =m ; i\u0026lt;len \u0026amp;\u0026amp; nums[i] \u0026lt;k ; i++){ res += k - nums[i]; } } return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // not change(3 4) // (3 4) // not change(3 4)(1 3) // (3 4)(1 3) // not change(3 4)(3 3)(2 2) // (3 3)(2 2) // not change(3 3)(2 2)(0 1) // (3 3)(2 2)(0 1) // not change(3 3)(3 2)(1 1)(1 0) // (3 2)(1 0) bool cmp(pair\u0026lt;int, int\u0026gt; \u0026amp;a, pair\u0026lt;int, int\u0026gt; \u0026amp;b){ if( a.first == b.first){ a.second = b.second; return 1; } return 0; } class Solution { public: vector\u0026lt;int\u0026gt; smallestSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 找一个最短的子数组, 使得 | 之后的值最大 // 按位或的性质? // 从x=nums[i]出发,OR的结果至多有多少种? // 关键:1不能变成0, 0可以变成1至多能变多少次?变29次,总共30种 int len = nums.size(); vector\u0026lt;int\u0026gt; res(len, 0); vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; ors; for(int i= len-1; i\u0026gt;-1; --i){ ors.push_back({nums[i], i}); for(int j = 0; j\u0026lt; ors.size(); ++j){ ors[j].first |= nums[i]; } // 原地去重 auto it = unique(ors.begin(), ors.end(), cmp); ors.resize(it - ors.begin()); res[i] = ors[0].second-i +1; } return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public: vector\u0026lt;int\u0026gt; smallestSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 找一个最短的子数组, 使得 | 之后的值最大 // 按位或的性质? // 从x=nums[i]出发,OR的结果至多有多少种? // 关键:1不能变成0, 0可以变成1至多能变多少次?变29次,总共30种 int n = nums.size(); vector\u0026lt;int\u0026gt; ans(n); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ors; // 按位或的值 + 对应子数组的右端点的最小值 for (int i = n - 1; i \u0026gt;= 0; --i) { ors.emplace_back(0, i);//小集合总是在后面插入的，因此ors是递减的 for (int j = 0; j \u0026lt; ors.size(); ++j) {//更新集合，把nums[i]插入集合 ors[j].first |= nums[i]; } cout\u0026lt;\u0026lt; \u0026#34;not change\u0026#34;; for(auto \u0026amp; p : ors){ cout\u0026lt;\u0026lt; \u0026#34;(\u0026#34;\u0026lt;\u0026lt; p.first\u0026lt;\u0026lt; \u0026#34; \u0026#34;\u0026lt;\u0026lt; p.second \u0026lt;\u0026lt;\u0026#39;)\u0026#39;; } cout\u0026lt;\u0026lt; endl; int j=0, k=0;//原地去重的两个指针，j用来遍历，k用来记录已去重的最后一个元素下标，方便比较 for(;j\u0026lt;ors.size();j++) {//原地去重，和421相同，集合更新保证ors的或值是递减的（不一定是严格递减的，可能有重复，所以需要去重） if (ors[k].first != ors[j].first) {//不重复，先递增k，因为k的定义和421有一点不同，再记录下来 ors[++k] = ors[j]; } else //重复了，只记录最小的下标，k不递增 ors[k].second = ors[j].second; // 合并相同值，下标取最小的 } ors.resize(k + 1);//k是已去重的最后一个元素下标，因此保留k+1个元素 for(auto \u0026amp; p : ors){ cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;\u0026lt;\u0026lt; p.first\u0026lt;\u0026lt; \u0026#34; \u0026#34;\u0026lt;\u0026lt; p.second \u0026lt;\u0026lt;\u0026#39;)\u0026#39;; } cout\u0026lt;\u0026lt; endl; // 本题只用到了 ors[0]，如果题目改成任意给定数字，可以在 ors 中查找 ans[i] = ors[0].second - i + 1; } return ans; } }; 2447. 最大公因数等于 K 的子数组数目 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的子数组中元素的最大公因数等于 k 的子数组数目。\n子数组 是数组中一个连续的非空序列。\n数组的最大公因数 是能整除数组中所有元素的最大整数。\n1 2 3 4 5 6 7 输入：nums = [9,3,1,2,6,3], k = 3 输出：4 解释：nums 的子数组中，以 3 作为最大公因数的子数组如下： - [9,3,1,2,6,3] - [9,3,1,2,6,3] - [9,3,1,2,6,3] - [9,3,1,2,6,3] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 bool cmp(pair\u0026lt;int, int\u0026gt; \u0026amp;a, pair\u0026lt;int, int\u0026gt; \u0026amp;b){ if( a.first == b.first){ a.second = b.second; return 1; } return 0; } class Solution { int gcd (int a, int b){ if(b == 0){ return a; } int temp = b; b = a %b; a = temp; return gcd(a, b); } public: int subarrayGCD(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // cout\u0026lt;\u0026lt; gcd(3, 6); int len = nums.size(); int res = 0 ; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; ors; int i0 = len; for(int i= len-1; i\u0026gt;-1; --i){ if(nums[i] %k ){ ors.clear(); i0 = i; continue; } ors.push_back({nums[i], i}); for(int j = 0; j\u0026lt; ors.size(); ++j){ ors[j].first = __gcd(ors[j].first, nums[i]) ; } // cout\u0026lt;\u0026lt; \u0026#34;before\u0026#34;; // for(auto p: ors){ // cout\u0026lt;\u0026lt; \u0026#34;(\u0026#34;\u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#34; \u0026#34;\u0026lt;\u0026lt;p.second\u0026lt;\u0026lt; \u0026#34;)\u0026#34;; // } // cout\u0026lt;\u0026lt; endl; // 原地去重 auto it = unique(ors.begin(), ors.end(), cmp); ors.resize(it - ors.begin()); // for(auto \u0026amp; p : ors){ // cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;\u0026lt;\u0026lt; p.first\u0026lt;\u0026lt; \u0026#34; \u0026#34;\u0026lt;\u0026lt; p.second \u0026lt;\u0026lt;\u0026#39;)\u0026#39;; // } // cout\u0026lt;\u0026lt; endl; if(ors.size() \u0026amp;\u0026amp; ors[0].first == k){ res+= i0 -ors[0].second ; // res++; } } return res; } }; 907. 子数组的最小值之和 给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。\n由于答案可能很大，因此 返回答案模 10^9 + 7 。\n1 2 3 4 5 输入：arr = [3,1,2,4] 输出：17 解释： 子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。 1 2 输入：arr = [11,81,94,43,3] 输出：444 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Solution { public: // 如果 arr\\textit{arr}arr 有重复元素，例如 arr=[1,2,4,2,3,1]，其中第一个 222 和第二个 222 对应的边界都是开区间 (0,5)，子数组 [2,4,2,3] 都包含这两个 2，这样在计算答案时就会重复统计同一个子数组，算出错误的结果。 // 为避免重复统计，可以修改边界的定义，把右边界改为「找小于或等于 arr[i] 的数的下标」，那么： // 第一个 2 对应的边界是 (0,3)，子数组需要在 (0,3) 范围内且包含下标 1； // 第二个 2 对应的边界是 (0,5)，子数组需要在 (0,5) 范围内且包含下标 3。 int sumSubarrayMins(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 子数组和的最小值 // 找左右两边 第一个 小于的元素, 找什么, 什么放到底下 int len = nums.size(); vector\u0026lt;int\u0026gt; r(len, len), l(len, -1); stack\u0026lt;int\u0026gt; st; for(int i = len-1; i\u0026gt;-1; --i){ while(st.size() \u0026amp;\u0026amp; nums[st.top()] \u0026gt; nums[i]){ st.pop(); } if(st.size() ){ r[i] = st.top(); } st.push(i); } while(st.size()){ st.pop(); } for(int i = 0; i\u0026lt;len; ++i ){ while(st.size() \u0026amp;\u0026amp; nums[st.top()] \u0026gt;= nums[i]){ st.pop(); } if(st.size() ){ l[i] = st.top(); } st.push(i); } // for(int n : r){ // cout\u0026lt;\u0026lt; n\u0026lt;\u0026lt; endl; // } // for(int n : l){ // cout\u0026lt;\u0026lt; n\u0026lt;\u0026lt; endl; // } int res = 0; int k = 1e9+7; for(int i = 0; i\u0026lt; len; ++i){ res += 1LL * (r[i]-i) * (i-l[i]) * nums[i] % k; res %= k; } return res; return 0; } }; 316 2447. 最大公因数等于 K 的子数组数目\n给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的子数组中元素的最大公因数等于 k 的子数组数目。\n子数组 是数组中一个连续的非空序列。\n数组的最大公因数 是能整除数组中所有元素的最大整数。\n1 2 3 4 5 6 7 输入：nums = [9,3,1,2,6,3], k = 3 输出：4 解释：nums 的子数组中，以 3 作为最大公因数的子数组如下： - [9,3,1,2,6,3] - [9,3,1,2,6,3] - [9,3,1,2,6,3] - [9,3,1,2,6,3] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { int gcd (int a, int b){ if(b == 0){ return a; } int temp = b; b = a %b; a = temp; return gcd(a, b); } public: int subarrayGCD(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // cout\u0026lt;\u0026lt; gcd(3, 9); int len = nums.size(); int res = 0; for(int i = 0; i\u0026lt;len; ++i){ int g = 0; for(int j = i; j\u0026lt;len; ++j){ g = gcd(nums[j], g); if(g == k){ res ++; } if(g \u0026lt; k){ break; } } } return res; } }; 2448. 使数组相等的最小开销 给你两个下标从 0 开始的数组 nums 和 cost ，分别包含 n 个 正 整数。\n你可以执行下面操作 任意 次：\n将 nums 中 任意 元素增加或者减小 1 。 对第 i 个元素执行一次操作的开销是 cost[i] 。\n请你返回使 nums 中所有元素 相等 的 最少 总开销。\n示例 1：\n1 2 3 4 5 6 7 8 输入：nums = [1,3,5,2], cost = [2,3,1,14] 输出：8 解释：我们可以执行以下操作使所有元素变为 2 ： - 增加第 0 个元素 1 次，开销为 2 。 - 减小第 1 个元素 1 次，开销为 3 。 - 减小第 2 个元素 3 次，开销为 1 + 1 + 1 = 3 。 总开销为 2 + 3 + 3 = 8 。 这是最小开销。 示例 2：\n1 2 3 输入：nums = [2,2,2,2,2], cost = [4,2,8,1,3] 输出：0 解释：数组中所有元素已经全部相等，不需要执行额外的操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: long long minCost(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; cost) { // 设变为的元素是k, 当k 是中位数时最小, 因此需要对数组进行排序 int len = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; a(len, vector\u0026lt;int\u0026gt;(2)); long long all = 0; for(int i = 0;i\u0026lt;len; ++i){ all += (long long)cost[i]; a[i][0] = nums[i]; a[i][1] = cost[i]; } long long mid = all/2, k =0; sort(a.begin(), a.end(), [](auto \u0026amp;x, auto \u0026amp;y){ return x[0]\u0026lt;y[0]; }); for(int i =0; i\u0026lt;len; ++i){ k+= a[i][1]; if(k\u0026gt;= mid) { k = i; break; } } k = a[k][0]; long long res = 0; for(int i =0;i\u0026lt;len; ++i){ res += (long long)abs(nums[i] - k) * (long long)cost[i]; } return res; } }; 2788. 按分隔符拆分字符串 - 力扣（LeetCode） 给你一个字符串数组 words 和一个字符 separator ，请你按 separator 拆分 words 中的每个字符串。\n返回一个由拆分后的新字符串组成的字符串数组，不包括空字符串 。\n注意\nseparator 用于决定拆分发生的位置，但它不包含在结果字符串中。 拆分可能形成两个以上的字符串。 结果字符串必须保持初始相同的先后顺序。 1 2 3 4 5 6 7 8 9 输入：words = [\u0026#34;one.two.three\u0026#34;,\u0026#34;four.five\u0026#34;,\u0026#34;six\u0026#34;], separator = \u0026#34;.\u0026#34; 输出：[\u0026#34;one\u0026#34;,\u0026#34;two\u0026#34;,\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;five\u0026#34;,\u0026#34;six\u0026#34;] 解释：在本示例中，我们进行下述拆分： \u0026#34;one.two.three\u0026#34; 拆分为 \u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34; \u0026#34;four.five\u0026#34; 拆分为 \u0026#34;four\u0026#34;, \u0026#34;five\u0026#34; \u0026#34;six\u0026#34; 拆分为 \u0026#34;six\u0026#34; 因此，结果数组为 [\u0026#34;one\u0026#34;,\u0026#34;two\u0026#34;,\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;five\u0026#34;,\u0026#34;six\u0026#34;] 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 vector\u0026lt;string\u0026gt; splitWordsBySeparator(vector\u0026lt;string\u0026gt;\u0026amp; words, char c) { vector\u0026lt;string\u0026gt; res; for(auto \u0026amp; s : words){ // 字符串左侧包括 l int l = 0; for(int i = 0; i\u0026lt; s.size(); ++i){ if(s[i] == c ){ if(i - l \u0026gt; 0){ res.push_back(s.substr(l, i-l)); } l = i+1; } // 处理最后不为 c 的情况 if(i == s.size() - 1 \u0026amp;\u0026amp; s[i] != c ){ res.push_back(s.substr(l, i- l+1)); } } } return res; } class Solution { public: vector\u0026lt;string\u0026gt; splitWordsBySeparator(vector\u0026lt;string\u0026gt;\u0026amp; words, char separator) { vector\u0026lt;string\u0026gt; res; for(int i = 0;i\u0026lt;words.size();i++){ istringstream iss(words[i]);\t// 输入流 string token;\t// 接收缓冲区 while (getline(iss, token, separator)){// 以split为分隔符 if(token.size()!=0) res.push_back(token); } } return res; } }; 作者：知忆梦往昔 链接：https://leetcode.cn/problems/split-strings-by-separator/solutions/2361633/jie-he-istringstreamhe-getlinefang-fa-sh-scem/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1 2 3 4 #include \u0026lt;sstream\u0026gt; // 构造函数 istringstream::istringstream(string str); 2790. 长度递增组的最大数目 - 力扣（LeetCode） 给你一个下标从 0 开始、长度为 n 的数组 usageLimits 。\n你的任务是使用从 0 到 n - 1 的数字创建若干组，并确保每个数字 i 在 所有组 中使用的次数总共不超过 usageLimits[i] 次。此外，还必须满足以下条件：\n每个组必须由 不同 的数字组成，也就是说，单个组内不能存在重复的数字。 每个组（除了第一个）的长度必须 严格大于 前一个组。 在满足所有条件的情况下，以整数形式返回可以创建的最大组数。\n1 2 3 4 5 6 7 8 9 输入：usageLimits = [1,2,5] 输出：3 解释：在这个示例中，我们可以使用 0 至多一次，使用 1 至多 2 次，使用 2 至多 5 次。 一种既能满足所有条件，又能创建最多组的方式是： 组 1 包含数字 [2] 。 组 2 包含数字 [1,2] 。 组 3 包含数字 [0,1,2] 。 可以证明能够创建的最大组数是 3 。 所以，输出是 3 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int maxIncreasingGroups(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 贪心的想, 让次数**更少**的元素在长度**更长**的分组中 // 本题最关键的一点是，单个组横着看，最优解是每一行的元素都不同，但竖着看就会发现最优解的情况是优先一列全部取一样的数字 sort(nums.begin(),nums.end());//先递增排序； // * // ** // *** long long sum = 0; int res = 0; int len = nums.size(); for(int i = 0; i\u0026lt;len; ++i){ sum += nums[i]; if(sum \u0026gt;= 1LL * (res + 1) * (res + 2) / 2){ res ++; } } return res; } 358 2817. 限制条件下元素之间的最小绝对差 - 力扣（LeetCode） 给你一个下标从 0 开始的整数数组 nums 和一个整数 x 。\n请你找到数组中下标距离至少为 x 的两个元素的 差值绝对值 的 最小值 。\n换言之，请你找到两个下标 i 和 j ，满足 abs(i - j) \u0026gt;= x 且 abs(nums[i] - nums[j]) 的值最小。\n请你返回一个整数，表示下标距离至少为 x 的两个元素之间的差值绝对值的 最小值 。\n1 2 3 4 5 输入：nums = [4,3,2,4], x = 2 输出：0 解释：我们选择 nums[0] = 4 和 nums[3] = 4 。 它们下标距离满足至少为 2 ，差值绝对值为最小值 0 。 0 是最优解。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int minAbsoluteDifference(vector\u0026lt;int\u0026gt;\u0026amp; nums, int x) { int res = INT_MAX, len = nums.size(); // 两个哨兵, 保证一定能找到比 n 大和小的元素 set\u0026lt;int\u0026gt; s={INT_MIN/2, INT_MAX}; for(int i = x; i\u0026lt;len; ++i){ int n = nums[i-x]; s.insert(n); int y = nums[i]; // auto it = s.lower_bound(y); res = min(res, min(*it - y, y- *--it)); } return res; } }; \u0026mdash;\u0026mdash;359 2830. 销售利润最大化 给你一个整数 n 表示数轴上的房屋数量，编号从 0 到 n - 1 。\n另给你一个二维整数数组 offers ，其中 offers[i] = [starti, endi, goldi] 表示第 i 个买家想要以 goldi 枚金币的价格购买从 starti 到 endi 的所有房屋。\n作为一名销售，你需要有策略地选择并销售房屋使自己的收入最大化。\n返回你可以赚取的金币的最大数目。\n注意 同一所房屋不能卖给不同的买家，并且允许保留一些房屋不进行出售。\n1 2 3 4 5 6 输入：n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]] 输出：3 解释： 有 5 所房屋，编号从 0 到 4 ，共有 3 个购买要约。 将位于 [0,0] 范围内的房屋以 1 金币的价格出售给第 1 位买家，并将位于 [1,3] 范围内的房屋以 2 金币的价格出售给第 3 位买家。 可以证明我们最多只能获得 3 枚金币。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int maximizeTheProfit(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; offers) { // 这是个区间的问题 // 为了方便遍历，可以先把所有 end 相同的数据用哈希表归类。 // group[i] 是 i == end 的 集合, 既然记录了 end 那么 end 就可以不要了 vector\u0026lt;vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; \u0026gt; groups(n); for(auto \u0026amp; offer: offers){ int s = offer[0], e = offer[1], gold = offer[2]; groups[e].push_back({s, gold}); } vector\u0026lt;int\u0026gt; f(n+1, 0); for(int i =0; i\u0026lt;n; ++i){ f[i+1] = f[i]; for(auto\u0026amp; group: groups[i]){ int start = group.first, gold = group.second; f[i+1] = max(f[i+1], f[start] + gold); } } return f[n]; } }; 相似题目\n出租车的最大盈利（和本题几乎一样） 规划兼职工作（数据范围更大的情况，我的题解） 最多可以参加的会议数目 II（区间个数限制） 两个最好的不重叠活动 作者：灵茶山艾府 链接：https://leetcode.cn/problems/maximize-the-profit-as-the-salesman/solutions/2396402/xian-xing-dpfu-xiang-si-ti-mu-pythonjava-wmh7/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n2831. 找出最长等值子数组 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。\n如果子数组中所有元素都相等，则认为子数组是一个 等值子数组 。注意，空数组是 等值子数组 。\n从 nums 中删除最多 k 个元素后，返回可能的最长等值子数组的长度。\n子数组 是数组中一个连续且可能为空的元素序列。\n示例 1：\n1 2 3 4 5 6 输入：nums = [1,3,2,3,1,3], k = 3 输出：3 解释：最优的方案是删除下标 2 和下标 4 的元素。 删除后，nums 等于 [1, 3, 3, 3] 。 最长等值子数组从 i = 1 开始到 j = 3 结束，长度等于 3 。 可以证明无法创建更长的等值子数组。 示例 2：\n1 2 3 4 5 6 输入：nums = [1,1,2,2,1,1], k = 2 输出：4 解释：最优的方案是删除下标 2 和下标 3 的元素。 删除后，nums 等于 [1, 1, 1, 1] 。 数组自身就是等值子数组，长度等于 4 。 可以证明无法创建更长的等值子数组。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public: int longestEqualSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // 最大值为 出现频率最大的数字, int len = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; pos(len+ 1); for(int i = 0; i\u0026lt;len; ++i){ int n = nums[i]; pos[n].push_back(i); } int res = 0; // 相同数字的id 为[3, 5, 9] 如何算出 删除k 元素, 以后最长的子数组呢 // 5-3+1 - (2) = 1 for(int i = 1; i\u0026lt;= len; ++i){ if(res\u0026gt;= pos[i].size()){ continue; } int l = 0, r = 0; while(r \u0026lt; pos[i].size()){ while(pos[i][r] - pos[i][l] + 1 - (r-l+ 1)\u0026gt; k ){ l++; } r++; res = max(res, r-l); } } return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main(){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n, 0), b; for(int i = 0; i\u0026lt;n; ++i){ cin\u0026gt;\u0026gt; a[i]; } // change int flag = 1; int res = 0; while(flag){ flag = 0; b.push_back(a[0]); n = a.size(); for(int i = 1; i\u0026lt; n; ++i){ if(a[i] \u0026gt; a[i-1]){ b.push_back(a[i]); flag = 1; } } res++; swap(a, b); b.clear(); } cout\u0026lt;\u0026lt; res\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 2904. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）\n给你一个二进制字符串 s 和一个正整数 k 。\n如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。\n令 len 等于 最短 美丽子字符串的长度。\n返回长度等于 len 且字典序 最小 的美丽子字符串。如果 s 中不含美丽子字符串，则返回一个 空 字符串。\n对于相同长度的两个字符串 a 和 b ，如果在 a 和 b 出现不同的第一个位置上，a 中该位置上的字符严格大于 b 中的对应字符，则认为字符串 a 字典序 大于 字符串 b 。\n例如，\u0026quot;abcd\u0026quot; 的字典序大于 \u0026quot;abcc\u0026quot; ，因为两个字符串出现不同的第一个位置对应第四个字符，而 d 大于 c 。 示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 输入：s = \u0026#34;100011001\u0026#34;, k = 3 输出：\u0026#34;11001\u0026#34; 解释：示例中共有 7 个美丽子字符串： 1. 子字符串 \u0026#34;100011001\u0026#34; 。 2. 子字符串 \u0026#34;100011001\u0026#34; 。 3. 子字符串 \u0026#34;100011001\u0026#34; 。 4. 子字符串 \u0026#34;100011001\u0026#34; 。 5. 子字符串 \u0026#34;100011001\u0026#34; 。 6. 子字符串 \u0026#34;100011001\u0026#34; 。 7. 子字符串 \u0026#34;100011001\u0026#34; 。 最短美丽子字符串的长度是 5 。 长度为 5 且字典序最小的美丽子字符串是子字符串 \u0026#34;11001\u0026#34; 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public: string shortestBeautifulSubstring(string s, int k) { // 如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。 string res; int len = s.size(); int l = 0, r = 0; int cnt = 0; while(r\u0026lt; len){ if(s[r++] == \u0026#39;1\u0026#39;){ cnt++; } while(cnt == k){ // cout\u0026lt;\u0026lt; s.substr(l, r-l)\u0026lt;\u0026lt; endl; if(res.empty()){ res = s.substr(l, r-l); }else if(res.size() \u0026amp;\u0026amp; res.size()\u0026gt; r-l ){ // cout\u0026lt;\u0026lt; \u0026#34;short string\u0026#34;\u0026lt;\u0026lt; endl; res = s.substr(l, r-l); }else if(res.size() == r-l){ res = min(res, s.substr(l, r-l)); } if(s[l++] == \u0026#39;1\u0026#39;){ cnt--; } } } return res; } }; 2905. 找出满足差值条件的下标 II 给你一个下标从 0 开始、长度为 n 的整数数组 nums ，以及整数 indexDifference 和整数 valueDifference 。\n你的任务是从范围 [0, n - 1] 内找出 2 个满足下述所有条件的下标 i 和 j ：\nabs(i - j) \u0026gt;= indexDifference 且 abs(nums[i] - nums[j]) \u0026gt;= valueDifference 返回整数数组 answer。如果存在满足题目要求的两个下标，则 answer = [i, j] ；否则，answer = [-1, -1] 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。\n注意：i 和 j 可能 相等 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: vector\u0026lt;int\u0026gt; findIndices(vector\u0026lt;int\u0026gt;\u0026amp; nums, int idiff, int vdiff) { int len = nums.size(); // 满足 (j-i)\u0026gt;= idiff 时, 左边数组的最大最小值 int maxid = 0, minid = 0; for(int j = idiff; j\u0026lt; len; ++j){ int i = j - idiff; if(nums[maxid] \u0026lt; nums[i]){ maxid = i; } if(nums[minid] \u0026gt; nums[i]){ minid = i; } if(abs(nums[maxid] - nums[j]) \u0026gt;= vdiff){ return {maxid, j}; } if(abs(nums[j] - nums[minid]) \u0026gt;= vdiff){ return {minid, j}; } } return {-1, -1}; } }; ","date":"0001-01-01T00:00:00Z","permalink":"https://li54426.github.io/p/","title":""}]
[{"content":" content {:toc} 1 C++ 11 之前的初始化方式 C++ 11 之前初始化的方式可以分为：直接初始化、拷贝初始化和大括号列表初始化\n直接初始化 这个最好理解，直接用显式的构造调用初始化，基本数据类型同样适用\n1 2 int j(0); MyClass myclass(123); //Foo is a class 拷贝初始化 1 2 int i = 0; MyClass myclass; //Foo is a class 大括号列表初始化 这种列表初始化方式仅限于有限的几种类型：数组和 POD 类型（plain old data 类型，指的是这样一些数据类型：基本数据类型、指针、union、数组、构造函数是 trivial 的 struct 或者 class 等与 C 相兼容的数据类型，可以按照 C 的方式来处理（运算、拷贝等））\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 列表初始化 C11 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; map = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; // 如果有些元素没有指定, 那么就会默认初始化 int arr[4] = { 1, 2, 3 }; // 默认值的初始化, 全部是 0 int a[26] ={}; int a[26]{}; struct A{ int i; struct B{ int j; int k; } b; } a = { 1, { 2, 3 } }; //POD类型 C++ 11 提供了统一的列表初始化方式 以下内容来自chatgpt\nC++列表初始化（List Initialization）是一种用于初始化对象、数组和容器的新语法。它在C++11标准中引入，并在后续的C++14、C++17和C++20中得到进一步扩展和改进。列表初始化通过使用花括号 {} 来简化初始化语法，同时提高代码的安全性和可读性。\n列表初始化的类型 列表初始化主要有以下几种类型：\n直接列表初始化：\n直接在对象创建时使用花括号进行初始化。\n1 2 int x{5}; // 直接列表初始化 double y{3.14}; 拷贝列表初始化： 使用等号和花括号进行初始化。\n1 2 int x = {5}; // 拷贝列表初始化 double y = {3.14}; 聚合初始化： 用于聚合类型（如结构体、数组等）的初始化。\n1 2 3 4 5 6 7 struct Point { int x; int y; }; Point p = {1, 2}; // 聚合初始化 int arr[] = {1, 2, 3, 4}; // 数组的聚合初始化 范围for循环： 使用范围for循环遍历列表初始化的容器。\n1 2 3 4 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; for (int n : vec) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } 标准库容器的列表初始化： 初始化标准库容器，如 std::vector、std::array 等。\n1 2 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; std::array\u0026lt;int, 4\u0026gt; arr = {1, 2, 3, 4}; 列表初始化的优势 避免窄化转换： 列表初始化不会允许从浮点到整数、较大范围整数到较小范围整数等潜在的危险转换。\n1 int x{3.14}; // 错误，不能从double到int的窄化转换 统一的初始化语法： 提供了一种统一的对象初始化语法，提高了代码的一致性和可读性。\n1 2 3 int x{5}; double d{3.14}; std::vector\u0026lt;int\u0026gt; vec{1, 2, 3, 4}; 更简洁的代码： 列表初始化语法通常比传统的构造函数调用更简洁和直观。\n1 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4}; // 比 vec.push_back(1); vec.push_back(2); 等更简洁 列表初始化的示例代码 以下是一些具体的列表初始化示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; struct Point { int x; int y; }; int main() { // 直接列表初始化 int a{10}; double b{3.14}; // 拷贝列表初始化 int c = {15}; double d = {2.71}; // 聚合初始化 Point p = {1, 2}; int arr[3] = {4, 5, 6}; // 标准库容器的列表初始化 std::vector\u0026lt;int\u0026gt; vec = {7, 8, 9, 10}; std::array\u0026lt;int, 4\u0026gt; arr2 = {11, 12, 13, 14}; // 输出测试 std::cout \u0026lt;\u0026lt; \u0026#34;a: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;c: \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;, d: \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Point p: (\u0026#34; \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;arr: \u0026#34;; for (int i : arr) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;vec: \u0026#34;; for (int i : vec) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;arr2: \u0026#34;; for (int i : arr2) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 以上代码展示了不同情况下的列表初始化使用方法及其输出结果。列表初始化不仅能使代码更清晰，还能防止许多潜在的错误，是C++11及以后标准推荐的初始化方式。\n","date":"2024-06-15T22:22:02Z","permalink":"https://li54426.github.io/p/cpp%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/","title":"CPP的初始化方式"},{"content":" content {:toc} 1 基础 1.1 不知道具体行数,直到文件末尾( EOF ) 输入样例:\n1 2 3 1 2 3 4 5 6 输入代码\n1 2 3 4 5 6 7 8 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; } } 1.2 有具体行数 输入样例:\n输入 n+1 行 第一行为n 接下来 n 行代表\u0026hellip;. 1 2 5 1 2 3 4 5 代码\n1 2 3 4 5 6 7 8 9 10 11 12 // 输入 n+1 行 // 第一行为xxx // 第二行为 xxx #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt; n; for(int i = 0; i\u0026lt; n; ++i){ // ... } } 2 string 2.1 多组数据, 空格分隔每个字符串 输入样例\n1 2 aaa bbb ccc aaa bbb ccc 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1, s2; while (cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2) { //... } return 0; } 2.2 输入一行为一个字符串 operator \u0026gt;\u0026gt; 有个问题, 遇到空格就停止 1 my name is li54426 1 2 3 4 5 6 7 8 9 #include\u0026lt;sstream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;iostream\u0026gt; int main{ string line; // 获取一整行数组 getline(cin, line); } 2.3 多组数据, 一行为一个字符串 数据格式为\n1 2 asd ddd ddd adsfa ddsf dfasd 1 2 3 4 5 6 7 int main(){ string line; while(getline(cin, line)) { //依靠geline读入一行 cout\u0026lt;\u0026lt; s\u0026lt;\u0026lt; endl; } } 2.4 输入一行字符串, 从中查找数字 输入格式\n1 \u0026#34;type:directReductionCoupon,price:50,isStackable:false\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 // \u0026#34;type:directReductionCoupon,price:50,isStackable:false\u0026#34; // 需要分离出来数字等 int main(){ string s; cin\u0026gt;\u0026gt; s; int base = ss.find(\u0026#34;price\u0026#34;); int end = ss.find(\u0026#34;,\u0026#34;, base); string numstr = ss.substr(base+6 , end- base-6); double price = stod(numstr ); } 3 进阶\u0026mdash;stringstream 的使用 3.1 输入方式为每行一个数组 输入样例\n1 2 3 1 2 3 4 5 0 0 0 0 0 代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;sstream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;iostream\u0026gt; int main{ vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; tree; string line; while(getline(cin, line)) { //依靠geline读入一行 stringstream ss(line); //每行先读入字符串，然后再区分每个数字 int num; int sum=0; vector\u0026lt;int\u0026gt; nums; nums.clear(); while(ss \u0026gt;\u0026gt; num){ nums.push_back(nums); } tree.push_back(nums); } } 3.2 输入方式为每行一个数组, 数字之间用逗号分隔 输入样例\n1 2 1,2,3 4,5,6 代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 1,2,3 // sum = 6 #include\u0026lt;sstream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;iostream\u0026gt; int main(){ string line; while(getline(cin, line) ) { //依靠geline读入一行 stringstream ss(line); //每行先读入字符串，然后再区分每个数字 int num; int sum=0; while(ss\u0026gt;\u0026gt; num){ // 将逗号输出出去 ss.get(); sum += num; } //计算总和 cout\u0026lt;\u0026lt; \u0026#34;sum = \u0026#34;\u0026lt;\u0026lt; sum\u0026lt;\u0026lt; endl; } } string流类基础 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 输入流 stringstream ss; ss \u0026lt;\u0026lt; \u0026#34;GodFishhh\u0026#34;; // 输出为字符串形式 cout \u0026lt;\u0026lt; ss.str() \u0026lt;\u0026lt; endl; // 偷看下一个字符, 流内还有字符 // \u0026#34;asdfasdf\u0026#34;, 哪怕运行一万次, 也是输出 a int peek(); // 获取字符 int get(); ostringstream oss; oss \u0026lt;\u0026lt; \u0026#34;GodFishhh and AFish\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 20030331 \u0026lt;\u0026lt; endl; // 成员函数str()的无参数形式 cout \u0026lt;\u0026lt; oss.str() \u0026lt;\u0026lt; endl; // 成员函数str()的有参数形式 // oss.str(\u0026#34;with parameter\u0026#34;); oss.str(\u0026#34;after \u0026#34;); cout \u0026lt;\u0026lt; oss.str() \u0026lt;\u0026lt; endl; ss \u0026lt;\u0026lt; \u0026#34;AFish\u0026#34;\u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ss.str(); // 清空 ss.clear(); ","date":"2023-10-05T16:29:20Z","permalink":"https://li54426.github.io/p/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/","title":"ACM输入输出总结"},{"content":" content {:toc} 数值类型的问题 整型与浮点型 在 C++ 中，当一个浮点数和一个整数进行乘法运算时，整数会被隐式地转换成与浮点数相同的类型，然后进行乘法运算。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void test1(){ float f=3.5; int m =6; long k=21; cout\u0026lt;\u0026lt; \u0026#34;k/2=\u0026#34;\u0026lt;\u0026lt; k/2\u0026lt;\u0026lt; endl; double ss=f * m + k/2; cout\u0026lt;\u0026lt;\u0026#34;ss=\u0026#34;\u0026lt;\u0026lt; ss\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt; \u0026#34;m * f =\u0026#34; \u0026lt;\u0026lt; m* f\u0026lt;\u0026lt; endl; } // 输出结果如下 // k/2=10 // ss=31 // m * f =21 // sizeof a = 12 整型与大整形 在 C++ 中，当一个表达式中同时包含 int 和 long long 类型时，会发生类型转换的情况如下：\n若参与运算量的类型不同，则先转换成同一类型，然后进行运算。 转换按数据长度增加的方向进行，以保证精度不降低。如 int 型和 long 型运算时，先把 int 量转成 long 型后再进行运算 1 2 3 4 5 6 7 8 9 10 11 12 13 void test1(){ int m =6; long k=21; cout\u0026lt;\u0026lt; \u0026#34;sizeof(int) = \u0026#34;\u0026lt;\u0026lt; sizeof(int)\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;sizeof= int + long= \u0026#34;\u0026lt;\u0026lt; sizeof(m + k)\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;sizeof = long + int= \u0026#34;\u0026lt;\u0026lt; sizeof(k + m)\u0026lt;\u0026lt; endl; } sizeof(int) = 4 sizeof= int + long= 8 sizeof = long + int= 8 整型与参数模板 如果在使用模板函数时, 可以设置初值为 long long类型 例如 0LL 1 accumulate(nums.begin(), nums.end(), 0LL); 数位补足 1 2 3 4 5 6 7 8 9 10 11 void test2(){ union{ char name[10]; int n; }a; cout\u0026lt;\u0026lt; \u0026#34;sizeof a = \u0026#34;\u0026lt;\u0026lt; sizeof a \u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; sizeof (int) \u0026lt;\u0026lt;endl; } // sizeof a = 12 // sizeof int = 4 string 与 char * char *赋值 当你尝试将一个字符串字面值（例如：\u0026ldquo;test\u0026rdquo;）赋值给一个字符数组时，会发生错误。这是因为字符串字面值在 C++ 中被视为一个常量字符数组，并且具有固定的大小，无法直接赋值给一个已经定义的字符数组。 a = 'c' 也是错误的, 必须是 a[0] = 'c'; 1 2 3 4 5 6 7 8 9 10 11 void test_string_char(){ char a[5]; // 错误示例 a =\u0026#34;test\u0026#34;; // 正确示例 strcpy(a, \u0026#34;test\u0026#34;); cout\u0026lt;\u0026lt; a\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;success\u0026#34;\u0026lt;\u0026lt; endl; } 作用域 变量的作用域 不同作用域内可以重复定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; using namespace std; int n = 0; int main(){ int n = 1; cout\u0026lt;\u0026lt; \u0026#34;全局n=\u0026#34;\u0026lt;\u0026lt; ::n\u0026lt;\u0026lt; endl; int n = 1; cout\u0026lt;\u0026lt; \u0026#34;函数内n=\u0026#34;\u0026lt;\u0026lt; n\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; { int n = 2; cout\u0026lt;\u0026lt; \u0026#34;括号内n=\u0026#34;\u0026lt;\u0026lt; n\u0026lt;\u0026lt; endl;; } } // 全局n=0 // 函数内 n=1 // 括号内 n=2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: bool isMatch(string s, string p) { // s is long , p is short return dp(s, 0, p, 0); } bool dp(string \u0026amp;s, int i, string \u0026amp;p, int j){ // * 的作用可以复制, 也可以擦除 int len1 = s.size(), len2= p.size(); if(i\u0026lt; len1 \u0026amp;\u0026amp; j\u0026lt; len2){ if(s[i] == p[j] || p[j] == \u0026#39;.\u0026#39;){ // 特赦情况 if(j\u0026lt; len2-1 \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39;){ // cout\u0026lt;\u0026lt; \u0026#34;s[i] == p[j] || p[j] == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39; \u0026#34;\u0026lt;\u0026lt; \u0026#34;i=\u0026#34;\u0026lt;\u0026lt; i\u0026lt;\u0026lt; \u0026#34;\\tj=\u0026#34;\u0026lt;\u0026lt;j \u0026lt;\u0026lt; endl; return dp(s, i+1, p, j) || dp(s, i, p, j+2); }else{ return dp(s, i+1, p, j+1); } }else{ if(j\u0026lt; len2 -1 \u0026amp;\u0026amp; p[j+1] ==\u0026#39;*\u0026#39;){ return dp(s, i, p, j+2); }else{ return 0; } } }else if(i == len1){ while(j\u0026lt; len2-1 \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39;){ j+=2; } return j == len2; } return 0; } }; ","date":"2023-09-22T21:08:05Z","permalink":"https://li54426.github.io/p/c-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/","title":"C++的一些基础问题"},{"content":" content {:toc} 函数模板不能使用 auto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 bool cmp(pair\u0026lt;int, int\u0026gt; \u0026amp;a, pair\u0026lt;int, int\u0026gt; \u0026amp;b){ if( a.first == b.first){ a.second = b.second; return 1; } return 0; } class Solution { public: vector\u0026lt;int\u0026gt; smallestSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 找一个最短的子数组, 使得 | 之后的值最大 // 按位或的性质? // 从x=nums[i]出发,OR的结果至多有多少种? // 关键:1不能变成0, 0可以变成1至多能变多少次?变29次,总共30种 int len = nums.size(); vector\u0026lt;int\u0026gt; res(len, 0); vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; ors; for(int i= len-1; i\u0026gt;-1; --i){ ors.push_back({nums[i], i}); for(int j = 0; j\u0026lt; ors.size(); ++j){ ors[j].first |= nums[i]; } auto it = unique(ors.begin(), ors.end(), cmp); ors.resize(it - ors.begin()); res[i] = ors[0].second-i +1; } return res; } }; 在 C++ 中，使用 auto 关键字可以让编译器自动推导变量的类型。然而，在函数模板中，编译器无法自动推导函数参数的类型，因此必须使用显示的类型。\n在给定的代码中，cmp 函数被用作 unique 函数的比较函数。unique 函数是一个函数模板，它接受两个迭代器和一个比较函数作为参数，并在指定范围内移除相邻的重复元素。\n因为 cmp 函数是作为比较函数传递给 unique 函数的，所以编译器无法自动推导参数的类型。因此，参数类型必须显式地指定为 pair\u0026lt;int, int\u0026gt;\u0026amp;，以便 unique 函数正确调用 cmp 函数进行比较。\n如果将参数类型改为 auto，编译器将无法确定参数类型，从而无法正确调用 cmp 函数，导致编译错误。\nlambda表达式 使用 auto 1 2 vector\u0026lt;int\u0026gt; aaaa (7, 0); unique (aaaa.begin (), aaaa.end (), [](auto a, auto b){return a== b;} ); 对于标准库算法函数（如 unique），它们是在 C++98/03 标准中定义的，不支持使用模板参数推导，因此无法直接使用 lambda 表达式作为比较函数。\n在 C++11 引入 lambda 表达式之前，为了使用自定义比较函数，我们通常需要使用函数指针或函数对象来传递函数。这要求我们定义一个具体的函数或函数对象，并显式地指定其类型。\n然而，在 C++11 之后的版本（包括 C++11、C++14 和 C++17），lambda 表达式提供了更简洁和灵活的方式来定义匿名函数，并可以在标准库算法中直接使用。\n所以，你可以使用 lambda 表达式作为比较函数传递给 unique 函数，而不需要使用函数指针或函数对象。这种语法糖使代码更简洁、可读性更好，并且能够自动推导参数类型。\n总而言之，C++11 以后的标准支持 lambda 表达式作为比较函数的直接传递，而之前的标准则需要使用函数指针或函数对象来传递自定义函数。\n","date":"2023-08-23T11:43:45Z","permalink":"https://li54426.github.io/p/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E-auto-%E5%85%B3%E9%94%AE%E5%AD%97/","title":"函数模板与 auto 关键字"},{"content":" content {:toc} 引用来实现多态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; using namespace std; class Base { public: virtual void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Base class.\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Derived class.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Derived derivedObj; Base\u0026amp; baseRef = derivedObj; // 使用基类引用引用派生类对象 baseRef.print(); // 调用的是 Derived 类中的 print 函数 return 0; } 不涉及多态时, 删除对象会发生什么 结果, 还能运行函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; using namespace std; class Base { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Base class.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base * p = new Base(); delete(p); p-\u0026gt; print(); cout\u0026lt;\u0026lt; \u0026#34;success\u0026#34;\u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;iostream\u0026gt; using namespace std; class Base { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;This is Base class.\u0026#34; \u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;a = \u0026#34;\u0026lt;\u0026lt; a \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } int a = 0; }; int main() { Base * p = new Base(); p-\u0026gt;print(); // a = 0; delete(p); p-\u0026gt; print(); // a = 5898 return 0; } ","date":"2023-08-14T15:09:19Z","permalink":"https://li54426.github.io/p/c-%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%A5%87%E6%80%AA%E7%9A%84%E4%BA%8B%E6%83%85/","title":"c++中那些奇怪的事情"},{"content":" content {:toc} 规范 1 2 3 4 5 \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;body\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;footer\u0026gt; type: 必填 commit 类型，有业内常用的字段，也可以根据需要自己定义 feat 增加新功能 fix 修复问题 / BUG style 代码风格相关无影响运行结果的 perf 优化 / 性能提升 refactor 重构 revert 撤销修改 test 测试相关 docs 文档 / 注释 chore 依赖更新 / 脚手架配置修改等 workflow 工作流改进 ci 持续集成 types 类型定义文件更改 wip 开发中 undef 不确定的分类 scope: commit 影响的范围，比如某某组件、某某页面 subject: 必填 简短的概述提交的代码，建议符合 50/72 formatting body: commit 具体修改内容，可以分为多行，建议符合 50/72 formatting footer: 其他备注，包括 breaking changes 和 issues 两部分 ","date":"2023-07-30T19:08:53Z","permalink":"https://li54426.github.io/p/commit-%E8%A7%84%E8%8C%83/","title":"commit 规范"},{"content":" content {:toc} 0 代码风格 C++ 风格指南 Cpplint 是一个 Python 脚本，作为一款开源免费的代码静态检测工具，Google 也使用它作为自己的 C++ 代码检测工具，也就是说，只要你想代码遵从 Google C++ 代码规范，那么 Cpplint 将会提供很好的代码静态检测支持。 1. 命名规则 文件名要全部小写, 可以包含下划线 (_) 或连字符 (-), 依照项目的约定. 如果没有约定, 那么“_”更好. 内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中. 类名称的每个单词首字母均大写, 不包含下划线: 形如MyExcitingClass, MyExcitingEnum. 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 常量 声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以“k”开头, 大小写混合.const int kDaysInAWeek = 7; 函数名的每个单词首字母大写 (即“驼峰变量名”或“帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 StartRpc() 而非 StartRPC()). 较好的起名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int price_count_reader; // 用于读取价格计数器 int num_errors; // 错误数量 int num_dns_connections; // DNS 连接数量 int count; // 计数器 int error_count; // 错误数量 int num_completed_connections; // 完成的连接数量 int web_gateway_connections; // Web 网关连接数量 int page_cache_reader; // 用于读取页面缓存 int customer_id; // 客户 ID // 类内变量名的规范 string table_name; // 好 - 用下划线. string tablename; // 好 - 全小写. string tableName; // 差 - 混合大小写 // 常量命名规范 const int kDaysInAWeek = 7; 2 注释风格 下面的规则描述了如何注释以及在哪儿注释\n三层的注释\n文件注释\n类注释\n函数注释\n变量注释/ 实现注释\n使用 // 或 /* */, 统一就好.\n文件注释描述了该文件的内容. 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释\n我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.\n1 2 3 4 5 6 7 8 9 ReturnType LongClassName::ReallyReallyReallyLongFunctionName( Type par_name1, // 4 space indent Type par_name2, Type par_name3) { DoSomething(); // 2 space indent ... } ","date":"2023-07-30T18:47:50Z","permalink":"https://li54426.github.io/p/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/","title":"代码风格"},{"content":" content {:toc} 1 allocator( 配置器 ) 1.1 代码分布 \u0026lt;stl_construct.h\u0026gt; 定义了全局函数construct()和destroy()，负责对象的构造和析构。 \u0026lt;stl_alloc.h\u0026gt; 定义了一二级配置器，配置器统称为alloc而非allocator！ \u0026lt;stl_uninitialized.h\u0026gt; 定义了一些全局函数，用来填充(fill)或者复制(copy)大块内存数据，也隶属于STL标准规范。 G 2.9 使用的是 alloc, 在G4.9中，分配器变成了new_allocator，旧的分配器alloc改名为_pool_alloc。STL标准告诉我们, 分配器在****中,\n考虑到小型区块所可能造成的内存破碎问题,SGI设计了双层级配置器,\n第一级配置器直接使用malloc()和free(), SGI第一级配置器的 allocate()和realloc都是在调用malloc和realloc()；不成功后，改调用oom_malloc()和oom_realloc();后两者都有内循环不断调用客户端注册的\u0026quot;__malloc_alloc_oom_handler “，以期望在某次调用之后获得足够的内存而圆满完成任务，但是如果没有注册”__malloc_alloc_oom_handler \u0026ldquo;，那么oom_malloc()和oom_realloc()便直接丢出bad_alloc异常信息或者exit(1)硬生生终止程序。\n第二级配置器则视情况采用不同的策略:当配置区块超过128 bytes时, 视之为\u0026quot;足够大\u0026rdquo;,便调用第一级配置器;当配置区块小于128 bytes时,视之为\u0026quot;过小\u0026quot;,为了降低额外负担, 便采用复杂的memory pool整理方式,而不再求助于第一级配置器 .\n所谓C++ new handler 机制是，你可以要求系统在内存配置需求无法被满足时，调用一个你所指定的函数。换句话说，-旦：：operator new无法完成任务，在丢出std:：bad_alloc异常状态之前，会先调用由客端指定的处理例程，该处理例\n整个 STL 的操作对象 都放在容器之内, 容器一定需要空间以配置资料 STL规则告诉我们配置器定义与\u0026lt;memory\u0026gt;中, 1 2 3 //----------memory.h---------- #include \u0026lt;stl_alloc.h\u0026gt; #include \u0026lt;stl_construct.h\u0026gt; 1.2 defalloc.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 文件目录 defalloc.h //仅仅是对 malloc 的包装 template \u0026lt;class T\u0026gt; class allocator { public: pointer allocate(size_type n) { return ::allocate((difference_type)n, (pointer)0);//函数2 } void deallocate(pointer p) { ::deallocate(p); } pointer address(reference x) { return (pointer)\u0026amp;x; } const_pointer const_address(const_reference x) { return (const_pointer)\u0026amp;x; } size_type init_page_size() { return max(size_type(1), size_type(4096/sizeof(T))); } size_type max_size() const { return max(size_type(1), size_type(UINT_MAX/sizeof(T))); } }; //函数2 template \u0026lt;class T\u0026gt; inline T* allocate(ptrdiff_t size, T*) { set_new_handler(0); T* tmp = (T*)(::operator new((size_t)(size * sizeof(T)))); if (tmp == 0) { cerr \u0026lt;\u0026lt; \u0026#34;out of memory\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } return tmp; } 1.3 stl_alloc.h __malloc_alloc_template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 // stl_alloc.h __malloc_alloc_template // 第一级配置器 // 该泛型类没有类型参数； //“__inst”是一个写死的int类型，但无实际意义 template \u0026lt;int __inst\u0026gt; class __malloc_alloc_template { private: //以下两个函数是，malloc 申请失败后（内存不足时）的处理方法 //用来申请空间，参数是申请的大小 static void* _S_oom_malloc(size_t); //用来扩增一个旧的内存空间 //参数1，是旧的空间地址；参数2，是重新申请的大小 static void* _S_oom_realloc(void*, size_t); #ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG //这是一个函数指针（指向函数的指针） static void (* __malloc_alloc_oom_handler)(); #endif public: static void* allocate(size_t __n) { // 调用 malloc() void* __result = malloc(__n); // 如果申请失败，改用 _S_oom_malloc() if (0 == __result) __result = _S_oom_malloc(__n); return __result; } //释放空间，参数1，地址指针；参数2，大小 //（很显然这里的第二参数没有意义） // 调用 free()释放空间 static void deallocate(void* __p, size_t /* __n */) { free(__p); //(为何__n 没有意义，c语言得知，free释放空间，是全部释放，不存在只释放一部分的情况) } //对一段旧空间扩容 static void* reallocate(void* __p, size_t /* old_sz */, size_t __new_sz) { void* __result = realloc(__p, __new_sz); // 如果申请失败，改用 _S_oom_malloc() if (0 == __result) __result = _S_oom_realloc(__p, __new_sz); return __result; } //动态指定，针对内存不足时的处理方法（注意书写格式） static void (* __set_malloc_handler(void (*__f)()))() { void (* __old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = __f; return(__old); } }; // malloc_alloc 针对内存不足时的处理方法 #ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG // 默认为0 template \u0026lt;int __inst\u0026gt; void (* __malloc_alloc_template\u0026lt;__inst\u0026gt;::__malloc_alloc_oom_handler)() = 0; #endif template \u0026lt;int __inst\u0026gt; void* __malloc_alloc_template\u0026lt;__inst\u0026gt;::_S_oom_malloc(size_t __n) { void (* __my_malloc_handler)(); //声明一个处理内存不足的函数指针； void* __result; // 一直申请直到失败或成功 for (;;) { __my_malloc_handler = __malloc_alloc_oom_handler; //当 \u0026#34;内存不足处理方法\u0026#34; 并未被设置，便调用 __THROW_BAD_ALLOC，抛出异常信息 if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; } // 调用内存不足时的处理函数 (*__my_malloc_handler)(); __result = malloc(__n); // 再次尝试申请内存 if (__result) return(__result); } } // 给一个已经分配了地址的指针重新分配空间 template \u0026lt;int __inst\u0026gt; void* __malloc_alloc_template\u0026lt;__inst\u0026gt;::_S_oom_realloc(void* __p, size_t __n) { void (* __my_malloc_handler)(); void* __result; for (;;) { __my_malloc_handler = __malloc_alloc_oom_handler; if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; } (*__my_malloc_handler)(); __result = realloc(__p, __n); if (__result) return(__result); } } 1.4 stl_alloc.h __default_alloc_template 两级结构, 第一级是 链表( free list ) 第二级是内存池 内存池不够的话, 继续 malloc\n其实 free list 可以和内存池相互转换,\n当 free list 某个大小的结点不足时, 可以调用内存池中的内存\n当内存池空的时候, 可以从free list中 调用 内存\n1 2 3 4 5 6 7 if(链表够): 从链表中取 else: if(内存池够): 从内存池中取(static refill(size_t __n)函数) refill调用 static _chunk_alloc(ize_t __size, int \u0026amp;__nobjs)函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // stl_alloc.h __default_alloc_template template \u0026lt;bool threads, int inst\u0026gt; class __default_alloc_template { private: static const int _ALIGN = 8; // 调整到 8字节 static const int _MAX_BYTES = 128; // 最大字节数 static const int _NFREELISTS = 16; // free lists 数目 _MAX_BYTES/_ALIGN static size_t _S_round_up(size_t __bytes){// 调整到 8字节 return (((__bytes) + (size_t) _ALIGN-1) \u0026amp; ~((size_t) _ALIGN - 1)); } union _Obj{ union _Obj* _M_free_list_link; char _M_client_data[1]; };//感觉定义一个结构体, 元素只有一个 指向 自己的 地址也可以 // 静态变量 static _Obj* volatile _S_free_list[]; // 确定应在哪个 list static size_t _S_freelist_index(size_t __bytes){ return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1); } static void* _S_refill(size_t __n); static char* _S_chunk_alloc(size_t __size, int \u0026amp;__nobjs); // Chunk allocation state, chunk_alloc 里使用 static char* _S_start_free; // 内存池起始地址 static char* _S_end_free; // 内存池结束地址 static size_t _S_heap_size; // 内存池大小 public: //-------接口---------- static void *allocate(size_t __n){ void *__ret = 0; if (__n \u0026gt; (size_t) _MAX_BYTES){ __ret = malloc_alloc::allocate(__n); } else{ //volatile 告诉编译器 不进行优化 _Obj* volatile* __my_free_list = _S_free_list + _S_freelist_index(__n); _Obj* __result = *__my_free_list; if (__result == 0) __ret = _S_refill(_S_round_up(__n)); //重填链表 else{ //和链表一样, 指向下一个结点 *__my_free_list = __result -\u0026gt; _M_free_list_link; __ret = __result; } } return __ret; }; static void deallocate(void* __p, size_t __n){ // 小于128的存储块, 要将他返回到那个链表中 if (__n \u0026gt; (size_t) _MAX_BYTES) malloc_alloc::deallocate(__p, __n); else { _Obj* volatile* __my_free_list = _S_free_list + _S_freelist_index(__n); _Obj* __q = (_Obj*)__p; __q -\u0026gt; _M_free_list_link = *__my_free_list; *__my_free_list = __q; } } static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz){ void *__result; size_t __copy_sz; if (__old_sz \u0026gt; (size_t) _MAX_BYTES \u0026amp;\u0026amp; __new_sz \u0026gt; (size_t) _MAX_BYTES){ //原来的大小比128大 return(realloc(__p, __new_sz)); } if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p); __result = allocate(__new_sz); __copy_sz = __new_sz \u0026gt; __old_sz? __old_sz : __new_sz; memcpy(__result, __p, __copy_sz); deallocate(__p, __old_sz); return(__result); } }; template \u0026lt;bool __threads, int __inst\u0026gt; char* __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_S_start_free = 0; template \u0026lt;bool __threads, int __inst\u0026gt; char* __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_S_end_free = 0; template \u0026lt;bool __threads, int __inst\u0026gt; size_t __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_S_heap_size = 0; template \u0026lt;bool __threads, int __inst\u0026gt; typename __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_Obj* volatile __default_alloc_template\u0026lt;__threads, __inst\u0026gt; ::_S_free_list[ __default_alloc_template\u0026lt;__threads, __inst\u0026gt;::_NFREELISTS ] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 // 返回一个大小为 n 的对象(假定 n 已经适当上调至 8 的倍数), // 因为free list中没有了节点, 所以尝试为对应的 free list 增加节点数目 // 默认取得20个新节点, 但如果内存池空间不足,获得的节点数可能小于20, 其中一个节点返回给调用者, 剩下的节点添入对应 free list template \u0026lt;bool __threads, int __inst\u0026gt; void *__default_alloc_template\u0026lt;__threads, __inst\u0026gt;:: _S_refill(size_t __n){ //重填链表, 默认重新要20个节点 int __nobjs = 20; // 注意参数 nobjs 是引用类型 char* __chunk = _S_chunk_alloc(__n, __nobjs); _Obj* volatile* __my_free_list; _Obj* __result; _Obj* __current_obj; _Obj* __next_obj; // 仅获得一个区块, 分配给调用者用, free list 无新节点 if (1 == __nobjs) return(__chunk); // 将多余区块纳入 free list __my_free_list = _S_free_list + _S_freelist_index(__n); __result = (_Obj*)__chunk; *__my_free_list = __next_obj = (_Obj*)(__chunk + __n); // 因为原始的内存里面的内容都是空的, 或者没有意义的, 需要将各节点串联起来, 第0个区块将返回给调用者 for (int __i = 1; __i \u0026lt; __nobjs - 1; __i++){ __current_obj = __next_obj; __next_obj = (_Obj*)((char*)__next_obj + __n); __current_obj -\u0026gt; _M_free_list_link = __next_obj; } __next_obj -\u0026gt; _M_free_list_link = 0; return(__result); } // 被 refill() 调用, 从内存池中取空间给 free list 使用 // 个人感觉没有必要, 毕竟这一个函数也只有 refill 调用(错误) // 为了递归调用自己(从freelist中找到了能用的 块 ) // 分配 nobjs 个大小为 size 的区块, template \u0026lt;bool __threads, int __inst\u0026gt; char *__default_alloc_template\u0026lt;__threads, __inst\u0026gt;:: _S_chunk_alloc(size_t __size, int \u0026amp;__nobjs){ char *__result; size_t __total_bytes = __size * __nobjs; size_t __bytes_left = _S_end_free - _S_start_free; // 内存池剩余空间 if (__bytes_left \u0026gt;= __total_bytes){ // 内存池剩余空间完全满足需求量 __result = _S_start_free; _S_start_free += __total_bytes; return(__result); } else if (__bytes_left \u0026gt;= __size){ // 内存池剩余空间不能完全满足需求量, 但能够供应至少一个区块 __nobjs = (int)(__bytes_left/__size); __total_bytes = __size * __nobjs; __result = _S_start_free; _S_start_free += __total_bytes; return(__result); } else{ // 内存池剩余空间连一个区块的大小能不能提供 // 利用 malloc() 从 heap 中配置内存, 大小为需求量的两倍, 再加上一个随着配置次数增加而越来越大的附加量 size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size \u0026gt;\u0026gt; 4); // 因为要创建新的内存池了, 所以 将 旧的 内存池中剩余的残余空间分配到适当的 free list 中 if (__bytes_left \u0026gt; 0){ _Obj* volatile* __my_free_list = _S_free_list + _S_freelist_index(__bytes_left); ((_Obj*)_S_start_free) -\u0026gt; _M_free_list_link = *__my_free_list; *__my_free_list = (_Obj*)_S_start_free; } // 尝试从 heap 中配置内存 _S_start_free = (char*)malloc(__bytes_to_get); if (0 == _S_start_free){ // heap 空间不足, malloc() 失败, 无法获得内存 size_t __i; _Obj* volatile* __my_free_list; _Obj* __p; // 从free list 找, 因为可能有些块比你需要的块 大 可以把他切割掉 for (__i = __size; __i \u0026lt;= (size_t)_MAX_BYTES; __i += (size_t)_ALIGN){ __my_free_list = _S_free_list + _S_freelist_index(__i); __p = *__my_free_list; if (0 != __p){ *__my_free_list = __p -\u0026gt; _M_free_list_link; _S_start_free = (char*)__p; _S_end_free = _S_start_free + __i; // 现在至少能提供一个区块了, 递归调用自己以修正 nobjs return(_S_chunk_alloc(__size, __nobjs)); } } // 连 free list 里也没有可用内存了 _S_end_free = 0; // 调用一级配置器看能不能有点用 // 一级配置器有 out-of-memory 处理机制, 或许有机会改善现在的情况, 如果无法改善, 抛出bad_alloc异常 _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get); } _S_heap_size += __bytes_to_get; _S_end_free = _S_start_free + __bytes_to_get; return(_S_chunk_alloc(__size, __nobjs)); } } ","date":"2023-07-25T21:19:24Z","permalink":"https://li54426.github.io/p/cpp_stl_1_alloctor/","title":"cpp_STL_1_alloctor"},{"content":" content {:toc} 类内成员 1.1 类内的静态变量 static 优点:\nstatic的名字在类的作用域内, 是类的一部分, 而不是对象的一部分 static成员可以是私有成员 所有对象共享同一份数据 类内声明，类外初始化 在编译阶段分配内存 1.2 静态成员函数 在类中声明函数的前面加static就成了静态成员函数, 可以通过对象来访问, 也可以通过类名来访问 所有对象共享同一个函数 静态成员函数只能访问静态成员变量, 静态成员函数没有this指针，既然它没有指向某一对象，就无法对一个对象中的非静态成员进行默认访问 泛整型可以类内直接初始化，包括bool short int long等，其余类型包括float，double及string等都不可以。\n1 2 3 4 5 class A{ public: static int staint; }; int A::staint = 0; 1.3 操作符 重载 作用 : 对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n一般的重载运算符\n加号运算符重载 左移运算符重载 :: 可以输出自定义数据类型 递增运算符重载 赋值运算符重载 关系运算符重载 函数调用运算符重载 Note: :: .* . ?= 不能重载\n3 模板 3.1 模板简介 ​\t泛型编程就是以独立于任何特定类型的方式编写代码, 使用泛型程序时， 需要提供具体程序实例所操作的类型或值. ​\t泛型程序设计背后有一种隐含的共性：模板机制 ​\twhy: 除了类型之外， 其余代码看起来是相同的。\n包括:\n函数模板 类模板 3.2 函数模板 函数模板提供了一种函数行为，该函数行为可以用多重不同类型进行调用。也就是说，函数模板代表一个函数家族。\n1 2 3 4 5 6 7 8 9 10 11 12 //尖括号内的是 一个或者多个模板形参 //模板形参定义了特定类型的局部变量但是不初始化， 只有当运行时才初始化. template\u0026lt;typename T\u0026gt; int compare(const T \u0026amp;a, const T \u0026amp;b){ if(a \u0026lt;b) return -1; else if(a \u0026gt;b) return 1; else return 0; } //使用函数模板时, 编译器会自己推断哪个或者哪些模板实参绑定到形参 //一旦编译器确定了实际的模板实参， 就是, 实例化了函数模板的一个实例 cout\u0026lt;\u0026lt; compare(1, 0); 3.3 类模板 类模板与函数模板区别主要有两点：\n类模板没有自动类型推导的使用方式\n类模板在模板参数列表中可以有默认参数\n类模板中成员函数和普通类中成员函数创建时机是有区别的：\n普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建 3.4 类模板的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;class NameType, class AgeType = int\u0026gt; class Person{}; void test01(){ // 错误 类模板使用时候，不可以用自动类型推导 // Person p(\u0026#34;孙悟空\u0026#34;, 1000); //必须使用显示指定类型的方式，使用类模板 Person \u0026lt;string ,int\u0026gt;p(\u0026#34;孙悟空\u0026#34;, 1000); } void test02(){ //类模板中的模板参数列表 可以指定默认参数 Person \u0026lt;string\u0026gt; p(\u0026#34;猪八戒\u0026#34;, 999); } 3.5 类模板 做 函数参数 一共有三种传入方式：\n指定传入的类型 \u0026mdash; 直接显示对象的数据类型**( 最常用 )** 参数模板化 \u0026mdash; 将对象中的参数变为模板进行传递 整个类模板化 \u0026mdash; 将这个对象类型 模板化进行传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 template\u0026lt;class NameType, class AgeType = int\u0026gt; class Person{}; //1、指定传入的类型 void printPerson1(Person\u0026lt;string, int\u0026gt; \u0026amp;p){ p.showPerson(); } void test01(){ Person \u0026lt;string, int \u0026gt;p(\u0026#34;孙悟空\u0026#34;, 100); printPerson1(p); } //2、参数模板化 template \u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt;\u0026amp;p){ p.showPerson(); cout \u0026lt;\u0026lt; \u0026#34;T1的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T2的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; } void test02(){ Person \u0026lt;string, int \u0026gt;p(\u0026#34;猪八戒\u0026#34;, 90); printPerson2(p); } //3、整个类模板化 template\u0026lt;class T\u0026gt; void printPerson3(T \u0026amp; p){ cout \u0026lt;\u0026lt; \u0026#34;T的类型为： \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl; p.showPerson(); } void test03(){ Person \u0026lt;string, int \u0026gt;p(\u0026#34;唐僧\u0026#34;, 30); printPerson3(p); } int main() { test01(); test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 3.6 类内的 模板对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;class T\u0026gt; class stack{ private: vector \u0026lt;T\u0026gt; elem(n); public: void pop(); void push(T); }; //可以有非模板类型参数, 非模板类型参数是有限制的, 可以是长整数, 或者指向外部链接对象的指针 template\u0026lt;class T, int max\u0026gt; stack{}; //在定义函数时, 模板定义了几个形参就要带着几个形参 template\u0026lt;class T, int max\u0026gt; stack :: pop(){ } 3.7 特化 有时候我们可能需要为某些特定类型或特定情况提供特殊的实现方式。这就是模板的特化的作用。 偏特化与完全特化类似，但存在一定的区别。完全特化是对模板的所有类型参数都进行具体化，而偏特化则只对其中的部分类型参数进行特化。所以偏特化以后, 依旧是 模板 偏特化的定义: 提供另一份 template 的定义式, 本是一就是templatized\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 泛化, 特化 template \u0026lt;class T, class Allocalloc\u0026gt; class vector { }; // 个数的偏特化 - 原来是两个模板参数, 现在是一个 // 针对某个类型做特别的优化 template\u0026lt;class Alloc\u0026gt; class vector\u0026lt;bool, Alloc\u0026gt; { }; //范围的偏特化 -指针类型 template\u0026lt;class T\u0026gt; class demo{}; template\u0026lt;class T\u0026gt; class demo\u0026lt;T*\u0026gt;{ }; ","date":"2023-07-25T21:19:24Z","permalink":"https://li54426.github.io/p/cpp_stl_o_basic/","title":"cpp_STL_O_basic"},{"content":" content {:toc} cpp感想(1)\u0026mdash;指针 版本号: V1.2\n1 第一版本感想 一开始认为只是一个存储地址的变量, 但是发现有些片面了\n2 第二版感想 想了很久发现, 没有一个词能够很好的形容指针, 感觉协议还靠边一点\n协议, 协议就是一些特殊的规则集合\n指针 是我们自己定义的操纵内存的接口\n我现在的理解就是 指针 = 地址 + 协议\n地址是指在内存中的位置, 协议是指如何管理指向的内存,\n2.1 void指针 ​\tvoid指针不是空指针, 而是可以没有约束( 协议 )的指针, 任何指针指都可以赋值给他, 但是不能用void指针进行操作, 要转换后才能进行操作 ​\t因为void*可以接受任何类型指针，就是所谓的上转型（upcasting），将一个更具体的指针转换成一个类型更泛化的指针。编译器知道这种类型转换并不会带来风险。如果进行下转型（downcasting），就告诉编译器，我现在有一个类型更加泛化的指针，我知道此指针具体类型是什么，但是如果涉及引用就想要进行强制转换。\n1 2 char a[10]; void *b = a; 2.2 malloc 函数 malloc 函数 返回的指针就是void * 类型, 也就是没有协议的类型\n2.3 链表\u0026mdash;来自数据结构 1 2 3 4 typedef struct Listnode{ datatype data; struct Listnode *next; }listnode; 为什么可以做到嵌套定义 :\nListnode 类型的变量可以有两个元素, 一个是数据域, 另一个是指针.这两个的大小和组织形式都是固定的, 例如, datatype为int时, 占据8个字节, 指针一般占据8个字节. 这就占据16个字节. Listnode 指针的协议就可以这么来描述: 大小为16个字节, 类内元素排列是 int ( 8 )+ 指针 ( 8 ) 2.4 obj\u0026mdash;来自SGIGCC2.9 1 2 3 4 5 union obj { union obj * free_list_link; char client_data[1]; /* The client sees this. */ }; //其实就是告诉指针, 这块内存中存储的是个地址, 并且占用8个字节的内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct listnode{ listnode *next; }; typedef struct listnode listnode; int main() { // your code goes here listnode a,b; a.next = \u0026amp;b; cout\u0026lt;\u0026lt; \u0026#34;sizeof listnode = \u0026#34;\u0026lt;\u0026lt; sizeof(listnode)\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;the address of a =\u0026#34;\u0026lt;\u0026lt; \u0026amp;a\u0026lt;\u0026lt; \u0026#34;the address of b =\u0026#34;\u0026lt;\u0026lt; \u0026amp;b\u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt; \u0026#34;the a.next = \u0026#34;\u0026lt;\u0026lt; a.next \u0026lt;\u0026lt;endl; return 0; } /* sizeof listnode = 8 the address of a =0x7ffc8f28fcf8 the address of b =0x7ffc8f28fd00 the a.next = 0x7ffc8f28fd00 */ 2.5 short和int\u0026mdash;来自编程范式(视频) 1 2 3 4 5 6 int arr[5]; arr[3]= 128; ((short*)arr)[6]= 2; //arr被重新解释成2bytes的short型，此时，之前赋值128的地方变为arr[7] //因为short占用的字节小, 因此你可以通过short指针的方式来进行操控一部分内存 ","date":"2023-07-03T23:13:54Z","permalink":"https://li54426.github.io/p/c-%E6%84%9F%E6%83%B3%E4%B9%8B%E6%8C%87%E9%92%881/","title":"c++感想之指针1"}]